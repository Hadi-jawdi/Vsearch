"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/sources";
exports.ids = ["pages/api/sources"];
exports.modules = {

/***/ "@mozilla/readability":
/*!***************************************!*\
  !*** external "@mozilla/readability" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("@mozilla/readability");

/***/ }),

/***/ "jsdom":
/*!************************!*\
  !*** external "jsdom" ***!
  \************************/
/***/ ((module) => {

module.exports = require("jsdom");

/***/ }),

/***/ "cheerio":
/*!**************************!*\
  !*** external "cheerio" ***!
  \**************************/
/***/ ((module) => {

module.exports = import("cheerio");;

/***/ }),

/***/ "(api)/./pages/api/sources.ts":
/*!******************************!*\
  !*** ./pages/api/sources.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mozilla/readability */ \"@mozilla/readability\");\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mozilla_readability__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheerio */ \"cheerio\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsdom */ \"jsdom\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsdom__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([cheerio__WEBPACK_IMPORTED_MODULE_1__]);\ncheerio__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Timeout for fetch requests (15 seconds)\nconst FETCH_TIMEOUT = 15000;\n// User agent rotation for requests\nconst USER_AGENTS = [\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36\",\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0\",\n    \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/96.0.4664.53 Mobile/15E148 Safari/604.1\"\n];\n// Get a random user agent\nconst getRandomUserAgent = ()=>USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];\n// Maximum number of retries for fetch requests\nconst MAX_RETRIES = 3;\n// Delay between retries (in ms)\nconst RETRY_DELAY = 1000;\n// Number of sources to return\nconst DEFAULT_SOURCE_COUNT = 4;\n// List of domains to exclude from results\nconst EXCLUDED_DOMAINS = [\n    \"google\",\n    \"facebook\",\n    \"twitter\",\n    \"instagram\",\n    \"youtube\",\n    \"tiktok\",\n    \"bing\",\n    \"duckduckgo\",\n    \"pinterest\",\n    \"linkedin\",\n    \"reddit\",\n    \"quora\"\n];\n/**\r\n * Enhanced fetch with timeout, retries, and exponential backoff\r\n */ async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT) {\n    let lastError = null;\n    // Try multiple times with exponential backoff\n    for(let attempt = 0; attempt < MAX_RETRIES; attempt++){\n        const controller = new AbortController();\n        const timeoutMs = timeout * (attempt + 1); // Increase timeout with each retry\n        const id = setTimeout(()=>controller.abort(), timeoutMs);\n        // Add default headers including a random user agent\n        const headers = {\n            \"User-Agent\": getRandomUserAgent(),\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"Cache-Control\": \"no-cache\",\n            \"Pragma\": \"no-cache\",\n            ...options.headers\n        };\n        try {\n            // Add a small delay between retries with exponential backoff\n            if (attempt > 0) {\n                await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * Math.pow(2, attempt - 1)));\n                console.log(`Retry attempt ${attempt + 1} for ${url}`);\n            }\n            const response = await fetch(url, {\n                ...options,\n                headers,\n                signal: controller.signal,\n                redirect: \"follow\"\n            });\n            clearTimeout(id);\n            // Check if we got a successful response\n            if (response.ok) {\n                return response;\n            } else {\n                // For certain status codes, we might want to retry\n                if (response.status === 429 || response.status >= 500) {\n                    lastError = new Error(`HTTP error ${response.status}: ${response.statusText}`);\n                    continue; // Retry\n                }\n                return response; // Return the response even if it's not ok\n            }\n        } catch (error) {\n            clearTimeout(id);\n            lastError = error;\n            // Don't retry if it's a CORS error or if the request was aborted\n            if (error.name === \"AbortError\" || error.message.includes(\"CORS\")) {\n                throw error;\n            }\n        // Continue to next retry attempt\n        }\n    }\n    // If we've exhausted all retries, throw the last error\n    throw lastError || new Error(`Failed to fetch ${url} after ${MAX_RETRIES} attempts`);\n}\n/**\r\n * Main handler for the sources API\r\n */ const searchHandler = async (req, res)=>{\n    // Only allow POST requests\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            sources: [],\n            error: \"Method not allowed\"\n        });\n    }\n    const startTime = Date.now();\n    try {\n        const { query , searchEngine =\"google\" , sourceCount =DEFAULT_SOURCE_COUNT  } = req.body;\n        // Validate input\n        if (!query || typeof query !== \"string\") {\n            return res.status(400).json({\n                sources: [],\n                error: \"Invalid query provided\"\n            });\n        }\n        // Limit source count to reasonable values\n        const limitedSourceCount = Math.min(Math.max(1, sourceCount), 8);\n        let allLinks = [];\n        let usedEngines = [];\n        // Get links from selected search engine(s)\n        if (searchEngine === \"all\") {\n            // Fetch from all search engines in parallel\n            console.log(`Fetching from all search engines for query: \"${query}\"`);\n            const [googleLinks, bingLinks, duckduckgoLinks] = await Promise.all([\n                getGoogleLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Google links:\", err);\n                    return [];\n                }),\n                getBingLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Bing links:\", err);\n                    return [];\n                }),\n                getDuckDuckGoLinks(query).catch((err)=>{\n                    console.error(\"Error fetching DuckDuckGo links:\", err);\n                    return [];\n                })\n            ]);\n            console.log(`Found links - Google: ${googleLinks.length}, Bing: ${bingLinks.length}, DuckDuckGo: ${duckduckgoLinks.length}`);\n            if (googleLinks.length > 0) usedEngines.push(\"google\");\n            if (bingLinks.length > 0) usedEngines.push(\"bing\");\n            if (duckduckgoLinks.length > 0) usedEngines.push(\"duckduckgo\");\n            allLinks = [\n                ...googleLinks,\n                ...bingLinks,\n                ...duckduckgoLinks\n            ];\n        } else {\n            // Fetch from a single search engine\n            console.log(`Fetching from ${searchEngine} for query: \"${query}\"`);\n            try {\n                switch(searchEngine){\n                    case \"google\":\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                        break;\n                    case \"bing\":\n                        allLinks = await getBingLinks(query);\n                        usedEngines.push(\"bing\");\n                        break;\n                    case \"duckduckgo\":\n                        allLinks = await getDuckDuckGoLinks(query);\n                        usedEngines.push(\"duckduckgo\");\n                        break;\n                    default:\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                }\n                console.log(`Found ${allLinks.length} links from ${searchEngine}`);\n            } catch (error) {\n                console.error(`Error fetching links from ${searchEngine}:`, error);\n                // Try Google as fallback if another engine fails\n                if (searchEngine !== \"google\") {\n                    console.log(\"Trying Google as fallback\");\n                    try {\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines = [\n                            \"google (fallback)\"\n                        ];\n                    } catch (fallbackError) {\n                        console.error(\"Fallback to Google also failed:\", fallbackError);\n                    }\n                }\n            }\n        }\n        // Filter and deduplicate links\n        const filteredLinks = filterAndDeduplicateLinks(allLinks);\n        // Limit to requested number of sources\n        const finalLinks = filteredLinks.slice(0, limitedSourceCount);\n        if (finalLinks.length === 0) {\n            return res.status(200).json({\n                sources: [],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: 0,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 0\n                }\n            });\n        }\n        // Scrape text from links with timeout and concurrency control\n        const sources = await scrapeSourcesWithTimeout(finalLinks);\n        // Process and clean up sources\n        const processedSources = processSources(sources);\n        // If we still don't have any valid sources after processing, create a fallback source\n        if (processedSources.length === 0) {\n            // Create a fallback source with search information\n            const fallbackSource = {\n                url: `https://www.google.com/search?q=${encodeURIComponent(query)}`,\n                title: `Search results for: ${query}`,\n                text: `We couldn't extract detailed information from the search results for \"${query}\".\r\n        This could be due to various reasons such as website restrictions or content formatting.\r\n\r\n        You can try:\r\n        1. Rephrasing your query to be more specific\r\n        2. Using a different search engine (try Bing or DuckDuckGo)\r\n        3. Searching for a related but different topic\r\n\r\n        The search was performed using ${usedEngines.join(\"+\")} and found ${allLinks.length} potential sources.`\n            };\n            // Return the fallback source\n            res.status(200).json({\n                sources: [\n                    fallbackSource\n                ],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 1,\n                    fallback: true\n                }\n            });\n        } else {\n            // Return the processed sources\n            res.status(200).json({\n                sources: processedSources,\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: processedSources.length\n                }\n            });\n        }\n    } catch (err) {\n        console.error(\"Error in sources API:\", err);\n        res.status(500).json({\n            sources: [],\n            error: \"Failed to fetch sources. Please try again.\"\n        });\n    }\n};\n/**\r\n * Filter and deduplicate links\r\n */ function filterAndDeduplicateLinks(links) {\n    // First, filter out invalid URLs and excluded domains\n    const validLinks = links.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const domain = url.hostname;\n            // Check if domain is in exclude list\n            return !EXCLUDED_DOMAINS.some((excluded)=>domain.includes(excluded));\n        } catch  {\n            return false;\n        }\n    });\n    // Then, deduplicate by domain\n    const uniqueDomains = new Set();\n    return validLinks.filter((link)=>{\n        try {\n            const domain = new URL(link).hostname;\n            if (uniqueDomains.has(domain)) return false;\n            uniqueDomains.add(domain);\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n}\n/**\r\n * Process and clean up sources\r\n */ function processSources(sources) {\n    const filteredSources = sources.filter((source)=>source !== undefined && source.text && source.text.length > 100);\n    // Truncate long texts and add metadata\n    return filteredSources.map((source)=>({\n            ...source,\n            text: source.text.slice(0, 1500),\n            title: extractTitle(source.url)\n        }));\n}\n/**\r\n * Extract a readable title from URL\r\n */ function extractTitle(url) {\n    try {\n        const { hostname , pathname  } = new URL(url);\n        // Get domain without www\n        const domain = hostname.replace(/^www\\./, \"\");\n        // Get last path segment without extension\n        const pathSegment = pathname.split(\"/\").filter(Boolean).pop() || \"\";\n        const cleanPathSegment = pathSegment.replace(/\\.\\w+$/, \"\").replace(/-|_/g, \" \");\n        if (cleanPathSegment) {\n            return `${cleanPathSegment.charAt(0).toUpperCase() + cleanPathSegment.slice(1)} - ${domain}`;\n        }\n        return domain;\n    } catch  {\n        return url;\n    }\n}\n/**\r\n * Scrape sources with timeout\r\n */ /**\r\n * Advanced web scraping with multiple extraction techniques and smart content detection\r\n */ async function scrapeSourcesWithTimeout(links) {\n    // Use a more controlled approach with concurrency limit and prioritization\n    const MAX_CONCURRENT = 4;\n    const results = [];\n    // Prioritize links based on domain reputation and URL structure\n    const prioritizedLinks = prioritizeLinks([\n        ...links\n    ]);\n    const pendingLinks = prioritizedLinks;\n    console.log(`Scraping ${pendingLinks.length} links with priority order`);\n    // Process links in batches to control concurrency\n    while(pendingLinks.length > 0){\n        const batch = pendingLinks.splice(0, MAX_CONCURRENT);\n        console.log(`Processing batch of ${batch.length} links`);\n        const batchResults = await Promise.all(batch.map(async (link)=>{\n            try {\n                // Try multiple extraction techniques\n                for(let technique = 0; technique < 3; technique++){\n                    try {\n                        console.log(`Fetching ${link} with technique ${technique + 1}`);\n                        // Adjust timeout based on technique\n                        const techniqueTimeout = FETCH_TIMEOUT + technique * 5000;\n                        // Use different fetch options based on technique\n                        const fetchOptions = {\n                            headers: {\n                                // Add referer for some techniques\n                                ...technique > 0 ? {\n                                    \"Referer\": \"https://www.google.com/\"\n                                } : {}\n                            }\n                        };\n                        const response = await fetchWithTimeout(link, fetchOptions, techniqueTimeout);\n                        if (!response.ok) {\n                            console.warn(`Failed to fetch ${link}: ${response.status}, technique ${technique + 1}`);\n                            // For certain status codes, we might want to skip to next technique\n                            if (response.status === 403 || response.status === 429) {\n                                continue;\n                            }\n                            // For other status codes, we might want to try a different approach\n                            if (technique < 2) {\n                                continue;\n                            } else {\n                                break; // Give up on this link after all techniques fail\n                            }\n                        }\n                        // Get content type to handle different types of content\n                        const contentType = response.headers.get(\"content-type\") || \"\";\n                        // Skip non-HTML content\n                        if (!contentType.includes(\"text/html\") && !contentType.includes(\"application/xhtml+xml\") && !contentType.includes(\"text/plain\")) {\n                            console.warn(`Skipping non-HTML content: ${contentType} for ${link}`);\n                            continue;\n                        }\n                        const html = await response.text();\n                        // Skip if we got a very small response (likely an error page)\n                        if (html.length < 800) {\n                            console.warn(`Too small response from ${link}: ${html.length} chars`);\n                            continue;\n                        }\n                        // Check for common error patterns in the HTML\n                        if (html.includes(\"captcha\") || html.includes(\"CAPTCHA\") || html.includes(\"access denied\") || html.includes(\"Access Denied\") || html.includes(\"403 Forbidden\")) {\n                            console.warn(`Detected access restriction in ${link}`);\n                            continue;\n                        }\n                        // Parse the HTML with different methods based on technique\n                        let extractedContent = null;\n                        // Technique 1: Use Readability\n                        if (technique === 0) {\n                            extractedContent = await extractWithReadability(html, link);\n                        }\n                        // Technique 2: Use custom content extraction\n                        if (technique === 1 || !extractedContent) {\n                            extractedContent = await extractWithCustomSelectors(html, link);\n                        }\n                        // Technique 3: Use simplified extraction\n                        if (technique === 2 || !extractedContent) {\n                            extractedContent = await extractWithSimplifiedMethod(html, link);\n                        }\n                        // If we successfully extracted content\n                        if (extractedContent && extractedContent.text.length > 200) {\n                            console.log(`Successfully extracted ${extractedContent.text.length} chars from ${link}`);\n                            // Clean and process the text\n                            const processedText = processExtractedText(extractedContent.text);\n                            return {\n                                url: link,\n                                text: processedText,\n                                title: extractedContent.title || extractTitle(link)\n                            };\n                        }\n                    } catch (techniqueError) {\n                        console.warn(`Technique ${technique + 1} failed for ${link}:`, techniqueError);\n                    }\n                }\n                // All techniques failed\n                console.error(`All extraction techniques failed for ${link}`);\n                return null;\n            } catch (error) {\n                console.error(`Error scraping ${link}:`, error);\n                return null;\n            }\n        }));\n        results.push(...batchResults);\n        // If we have enough good results, we can stop early\n        const validResults = results.filter(Boolean);\n        if (validResults.length >= 3) {\n            console.log(`Got ${validResults.length} good results, stopping early`);\n            break;\n        }\n    }\n    // Filter out null results and ensure we have at least some content\n    const validSources = results.filter(Boolean);\n    // Sort sources by content quality (length and readability)\n    const sortedSources = sortSourcesByQuality(validSources);\n    // If we have no valid sources, create intelligent fallback sources\n    if (sortedSources.length === 0 && links.length > 0) {\n        console.log(\"No valid sources found, creating fallback sources\");\n        return createFallbackSources(links);\n    }\n    return sortedSources;\n}\n/**\r\n * Prioritize links based on domain reputation and URL structure\r\n */ function prioritizeLinks(links) {\n    // Score each link\n    const scoredLinks = links.map((link)=>{\n        try {\n            const url = new URL(link);\n            let score = 0;\n            // Prefer certain domains\n            const hostname = url.hostname.toLowerCase();\n            // Higher score for reputable domains\n            if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\") || hostname.includes(\"github.com\") || hostname.includes(\"stackoverflow.com\") || hostname.includes(\"medium.com\")) {\n                score += 30;\n            }\n            // Prefer shorter URLs (often main pages)\n            score -= url.pathname.split(\"/\").length * 2;\n            // Prefer URLs without query parameters\n            score -= url.search.length > 0 ? 5 : 0;\n            // Avoid certain patterns\n            if (url.pathname.includes(\"login\") || url.pathname.includes(\"signup\") || url.pathname.includes(\"account\")) {\n                score -= 20;\n            }\n            return {\n                link,\n                score\n            };\n        } catch  {\n            return {\n                link,\n                score: -100\n            }; // Invalid URLs get lowest priority\n        }\n    });\n    // Sort by score (highest first)\n    scoredLinks.sort((a, b)=>b.score - a.score);\n    // Return just the links\n    return scoredLinks.map((item)=>item.link);\n}\n/**\r\n * Extract content using Mozilla's Readability\r\n */ async function extractWithReadability(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url,\n            runScripts: \"outside-only\",\n            pretendToBeVisual: true\n        });\n        const reader = new _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__.Readability(dom.window.document);\n        const article = reader.parse();\n        if (article && article.textContent && article.textContent.length > 200) {\n            return {\n                text: article.textContent,\n                title: article.title || dom.window.document.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Readability extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\r\n * Extract content using custom selectors for different site types\r\n */ async function extractWithCustomSelectors(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url\n        });\n        const doc = dom.window.document;\n        // Get the hostname to apply site-specific selectors\n        const hostname = new URL(url).hostname.toLowerCase();\n        // Define selectors for different site types\n        let selectors = [];\n        // Wikipedia-specific selectors\n        if (hostname.includes(\"wikipedia.org\")) {\n            selectors = [\n                \"#mw-content-text\",\n                \".mw-parser-output\"\n            ];\n        } else if (hostname.includes(\"github.com\")) {\n            selectors = [\n                \".markdown-body\",\n                \"article.markdown-body\",\n                \".repository-content\"\n            ];\n        } else if (hostname.includes(\"stackoverflow.com\")) {\n            selectors = [\n                \".post-text\",\n                \".answer\"\n            ];\n        } else if (hostname.includes(\"news\") || hostname.includes(\"bbc\") || hostname.includes(\"cnn\") || hostname.includes(\"nytimes\")) {\n            selectors = [\n                \".article-body\",\n                \".story-body\",\n                \".article__content\",\n                '[itemprop=\"articleBody\"]'\n            ];\n        } else {\n            selectors = [\n                \"main\",\n                \"article\",\n                '[role=\"main\"]',\n                \"#content\",\n                \".content\",\n                \".post-content\",\n                \".entry-content\",\n                \".article-content\",\n                \".post-body\",\n                \".page-content\",\n                \".main-content\",\n                \".body-content\"\n            ];\n        }\n        // Try each selector\n        for (const selector of selectors){\n            const elements = doc.querySelectorAll(selector);\n            if (elements.length > 0) {\n                // Combine text from all matching elements\n                let combinedText = \"\";\n                elements.forEach((el)=>{\n                    combinedText += el.textContent + \"\\n\\n\";\n                });\n                if (combinedText.length > 200) {\n                    return {\n                        text: combinedText,\n                        title: doc.title || extractTitle(url)\n                    };\n                }\n            }\n        }\n        // If no content found with selectors, try to find the largest text block\n        const textBlocks = findLargestTextBlocks(doc);\n        if (textBlocks && textBlocks.length > 200) {\n            return {\n                text: textBlocks,\n                title: doc.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Custom extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\r\n * Extract content using a simplified method (fallback)\r\n */ async function extractWithSimplifiedMethod(html, url) {\n    try {\n        // Use cheerio for lightweight parsing\n        const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n        // Remove script, style, nav, footer, and other non-content elements\n        $(\"script, style, nav, footer, header, aside, .sidebar, .footer, .header, .navigation, .nav, .menu, .comments, .ads, .ad\").remove();\n        // Get the title\n        const title = $(\"title\").text() || extractTitle(url);\n        // Get all paragraphs\n        const paragraphs = [];\n        $(\"p\").each((_, el)=>{\n            const text = $(el).text().trim();\n            if (text.length > 20) {\n                paragraphs.push(text);\n            }\n        });\n        // If we found paragraphs, join them\n        if (paragraphs.length > 0) {\n            return {\n                text: paragraphs.join(\"\\n\\n\"),\n                title\n            };\n        }\n        // Fallback: get all text from body\n        const bodyText = $(\"body\").text();\n        if (bodyText.length > 200) {\n            // Clean up the text\n            const cleanedText = bodyText.replace(/\\s+/g, \" \").trim().split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 20).join(\"\\n\\n\");\n            if (cleanedText.length > 200) {\n                return {\n                    text: cleanedText,\n                    title\n                };\n            }\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Simplified extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\r\n * Find the largest text blocks in a document\r\n */ function findLargestTextBlocks(doc) {\n    // Get all elements with substantial text\n    const textElements = [];\n    // Function to recursively process elements\n    function processElement(element) {\n        // Skip certain elements\n        const tagName = element.tagName.toLowerCase();\n        if ([\n            \"script\",\n            \"style\",\n            \"nav\",\n            \"header\",\n            \"footer\"\n        ].includes(tagName)) {\n            return;\n        }\n        // Check if this element has direct text\n        const directText = Array.from(element.childNodes).filter((node)=>node.nodeType === 3) // Text nodes only\n        .map((node)=>node.textContent || \"\").join(\"\").trim();\n        // If this element has substantial direct text, add it\n        if (directText.length > 50) {\n            textElements.push({\n                element,\n                length: directText.length\n            });\n        }\n        // Process children\n        Array.from(element.children).forEach(processElement);\n    }\n    // Start processing from body\n    processElement(doc.body);\n    // Sort by text length (largest first)\n    textElements.sort((a, b)=>b.length - a.length);\n    // Take the top elements that likely contain main content\n    const mainContentElements = textElements.slice(0, 10);\n    // Extract and join their text\n    return mainContentElements.map((item)=>item.element.textContent || \"\").join(\"\\n\\n\");\n}\n/**\r\n * Process and clean extracted text\r\n */ function processExtractedText(text) {\n    // Remove excessive whitespace\n    let processed = text.replace(/\\s+/g, \" \");\n    // Split into lines and clean each line\n    processed = processed.split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 0).join(\"\\n\");\n    // Remove duplicate paragraphs\n    const paragraphs = processed.split(\"\\n\\n\");\n    const uniqueParagraphs = Array.from(new Set(paragraphs));\n    processed = uniqueParagraphs.join(\"\\n\\n\");\n    // Limit length to avoid extremely long texts\n    if (processed.length > 8000) {\n        processed = processed.substring(0, 8000) + \"...\";\n    }\n    return processed;\n}\n/**\r\n * Sort sources by quality\r\n */ function sortSourcesByQuality(sources) {\n    return [\n        ...sources\n    ].sort((a, b)=>{\n        // Calculate quality score based on text length and other factors\n        const scoreA = calculateContentQualityScore(a);\n        const scoreB = calculateContentQualityScore(b);\n        return scoreB - scoreA;\n    });\n}\n/**\r\n * Calculate content quality score\r\n */ function calculateContentQualityScore(source) {\n    let score = 0;\n    // Length is a primary factor\n    score += Math.min(source.text.length / 100, 50);\n    // Prefer sources with titles\n    score += source.title ? 10 : 0;\n    // Prefer sources from reputable domains\n    try {\n        const hostname = new URL(source.url).hostname.toLowerCase();\n        if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\")) {\n            score += 20;\n        }\n    } catch  {\n    // Invalid URL\n    }\n    return score;\n}\n/**\r\n * Create fallback sources when extraction fails\r\n */ function createFallbackSources(links) {\n    // Create at least one fallback source\n    const fallbackSources = [];\n    // Try to create sources from the top 3 links\n    const topLinks = links.slice(0, 3);\n    for (const link of topLinks){\n        try {\n            const domain = new URL(link).hostname.replace(\"www.\", \"\");\n            fallbackSources.push({\n                url: link,\n                text: `This information is from ${domain}. The content could not be fully extracted due to website restrictions. Please visit the website directly for complete information.`,\n                title: `Information from ${domain}`\n            });\n        } catch  {\n        // Skip invalid URLs\n        }\n    }\n    // If we couldn't create any fallback sources, create a generic one\n    if (fallbackSources.length === 0 && links.length > 0) {\n        fallbackSources.push({\n            url: links[0],\n            text: `Information could not be retrieved from the sources. This might be due to website restrictions or technical limitations. Try refining your search query or visiting the websites directly.`,\n            title: `Search Results`\n        });\n    }\n    return fallbackSources;\n}\n/**\r\n * Advanced Google search with multiple extraction techniques and fallbacks\r\n */ async function getGoogleLinks(query) {\n    try {\n        console.log(`Making Google search request for: \"${query}\"`);\n        // Try multiple search variations to improve results\n        const searchVariations = [\n            // Standard search\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=30`,\n            // Search with verbatim option to get exact matches\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=li:1`,\n            // Search with recent results\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=qdr:y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying search variation ${i + 1}: ${searchUrl}`);\n                // Add additional headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.google.com/\",\n                        \"DNT\": \"1\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\",\n                        \"sec-ch-ua\": '\"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"',\n                        \"sec-ch-ua-mobile\": \"?0\",\n                        \"sec-ch-ua-platform\": '\"Windows\"'\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Google search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Google variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                if (html.includes(\"unusual traffic\") || html.includes(\"CAPTCHA\") || html.includes(\"detected unusual traffic\")) {\n                    console.warn(`Google variation ${i + 1} blocked or returned a CAPTCHA`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractGoogleLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Google variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Google search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Google`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Google links:\", error);\n        return [];\n    }\n}\n/**\r\n * Extract links from Google search results HTML using multiple methods\r\n */ function extractGoogleLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Standard Google search results - look for redirects\n    $(\"a\").each((_, link)=>{\n        const href = $(link).attr(\"href\");\n        if (href && href.startsWith(\"/url?q=\")) {\n            try {\n                const cleanedHref = decodeURIComponent(href.replace(\"/url?q=\", \"\").split(\"&\")[0]);\n                if (isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Look for result containers and extract links\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 2\");\n        // Modern Google selectors\n        $(\".g .yuRUbf > a, .g .rc > a, .g h3.r > a, .tF2Cxc > div.yuRUbf > a, .hlcw0c .yuRUbf > a\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.startsWith(\"http\") && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    // Method 3: Extract from cite elements\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 3\");\n        $(\".iUh30, .tjvcx, .qzEoUe\").each((_, element)=>{\n            const parentLink = $(element).closest(\"a\").attr(\"href\");\n            if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n                links.push(parentLink);\n            } else {\n                // Try to construct URL from cite text\n                const citeText = $(element).text().trim();\n                if (citeText && !citeText.includes(\"...\") && citeText.includes(\".\")) {\n                    try {\n                        let url = citeText;\n                        if (!url.startsWith(\"http\")) {\n                            url = \"https://\" + url;\n                        }\n                        if (isValidUrl(url) && !links.includes(url)) {\n                            links.push(url);\n                        }\n                    } catch (e) {\n                    // Skip invalid URLs\n                    }\n                }\n            }\n        });\n    }\n    // Method 4: Last resort - find any external links\n    if (links.length < 3) {\n        console.log(\"Using Google extraction method 4 (last resort)\");\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"google.com\") && !href.includes(\"accounts.\") && !href.includes(\"support.\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\r\n * Filter and clean a list of URLs\r\n */ function filterAndCleanLinks(links) {\n    // Remove duplicates\n    let uniqueLinks = Array.from(new Set(links));\n    // Filter out invalid and unwanted URLs\n    uniqueLinks = uniqueLinks.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const hostname = url.hostname.toLowerCase();\n            // Filter out common non-content domains\n            const invalidDomains = [\n                \"google.com\",\n                \"youtube.com\",\n                \"facebook.com\",\n                \"twitter.com\",\n                \"instagram.com\",\n                \"linkedin.com\",\n                \"pinterest.com\",\n                \"amazon.com\",\n                \"ebay.com\",\n                \"netflix.com\",\n                \"apple.com\",\n                \"microsoft.com\",\n                \"play.google.com\",\n                \"accounts.google.com\",\n                \"support.google.com\",\n                \"maps.google.com\",\n                \"policies.google.com\",\n                \"translate.google.com\",\n                \"chrome.google.com\",\n                \"docs.google.com\",\n                \"drive.google.com\",\n                \"mail.google.com\",\n                \"calendar.google.com\"\n            ];\n            if (invalidDomains.some((domain)=>hostname.includes(domain))) {\n                return false;\n            }\n            // Filter out URLs with certain patterns\n            const invalidPatterns = [\n                \"/search?\",\n                \"/login\",\n                \"/signin\",\n                \"/signup\",\n                \"/register\",\n                \"/account\",\n                \"/cart\",\n                \"/checkout\",\n                \"/privacy\",\n                \"/terms\",\n                \"/contact\",\n                \"/about\",\n                \"/help\",\n                \"/support\",\n                \"/faq\",\n                \"/download\",\n                \"/subscribe\",\n                \"/membership\",\n                \"/pricing\"\n            ];\n            if (invalidPatterns.some((pattern)=>url.pathname.includes(pattern))) {\n                return false;\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n    // Limit to a reasonable number\n    return uniqueLinks.slice(0, 20);\n}\n/**\r\n * Validate if a string is a valid URL and meets content criteria\r\n */ function isValidUrl(url) {\n    try {\n        new URL(url);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Enhanced Bing search with multiple extraction techniques\r\n */ async function getBingLinks(query) {\n    try {\n        console.log(`Making Bing search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard search\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&count=30`,\n            // Search with news\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=news`,\n            // Search with freshness filter\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=ex1%3a\"ez5\"`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from Bing, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying Bing search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.bing.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Bing search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Bing variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractBingLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Bing variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Bing search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Bing`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Bing links:\", error);\n        return [];\n    }\n}\n/**\r\n * Extract links from Bing search results HTML\r\n */ function extractBingLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main search results\n    $(\".b_algo h2 a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 2: Extract from cite elements\n    $(\".b_caption cite\").each((_, element)=>{\n        const parentLink = $(element).closest(\".b_algo\").find(\"h2 a\").attr(\"href\");\n        if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n            links.push(parentLink);\n        }\n    });\n    // Method 3: Extract from deep links\n    $(\".b_deeplinks a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 4: Last resort - find any external links\n    if (links.length < 5) {\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"bing.com\") && !href.includes(\"microsoft.com\") && !href.includes(\"msn.com\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\r\n * Enhanced DuckDuckGo search with multiple extraction techniques\r\n */ async function getDuckDuckGoLinks(query) {\n    try {\n        console.log(`Making DuckDuckGo search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard HTML search\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`,\n            // With region set to US\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&kl=us-en`,\n            // With time filter for recent results\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&df=y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from DuckDuckGo, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying DuckDuckGo search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://duckduckgo.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`DuckDuckGo search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from DuckDuckGo variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using our custom function\n                const extractedLinks = extractDuckDuckGoLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from DuckDuckGo variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with DuckDuckGo search variation ${i + 1}:`, variationError);\n            }\n        }\n        // If HTML search failed, try the lite version as fallback\n        if (allLinks.length === 0) {\n            try {\n                console.log(\"Trying DuckDuckGo Lite as fallback\");\n                const liteUrl = `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(query)}`;\n                const response = await fetchWithTimeout(liteUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\"\n                    }\n                });\n                if (response.ok) {\n                    const html = await response.text();\n                    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n                    // Extract links from the lite version\n                    $(\"a[href^='http']\").each((_, element)=>{\n                        const href = $(element).attr(\"href\");\n                        if (href && !href.includes(\"duckduckgo.com\") && isValidUrl(href) && !allLinks.includes(href)) {\n                            allLinks.push(href);\n                        }\n                    });\n                    console.log(`Found ${allLinks.length} links from DuckDuckGo Lite fallback`);\n                }\n            } catch (liteError) {\n                console.error(\"Error with DuckDuckGo Lite fallback:\", liteError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from DuckDuckGo`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching DuckDuckGo links:\", error);\n        return [];\n    }\n}\n/**\r\n * Extract links from DuckDuckGo search results HTML\r\n */ function extractDuckDuckGoLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main result links\n    $(\".result__a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href) {\n            try {\n                // DuckDuckGo uses relative URLs with parameters\n                const url = new URL(href, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Extract from result snippets\n    $(\".result__snippet\").each((_, element)=>{\n        const parentLink = $(element).closest(\".result\").find(\".result__a\").attr(\"href\");\n        if (parentLink) {\n            try {\n                const url = new URL(parentLink, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 3: Last resort - find any external links\n    if (links.length < 3) {\n        $(\"a[href^='/']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.includes(\"uddg=\")) {\n                try {\n                    const url = new URL(href, \"https://duckduckgo.com\");\n                    const cleanedHref = url.searchParams.get(\"uddg\");\n                    if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                        links.push(cleanedHref);\n                    }\n                } catch (e) {\n                // Skip invalid URLs\n                }\n            }\n        });\n    }\n    return links;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (searchHandler);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1lBQ1Ysb0JBQW9CO1lBQ3RCO1FBQ0YsQ0FBQztJQUNIO0lBRUEsa0RBQWtEO0lBQ2xELElBQUkzSCxNQUFNbkYsTUFBTSxHQUFHLEdBQUc7UUFDcEJtSyxFQUFFLGdCQUFnQkksSUFBSSxDQUFDLENBQUNDLEdBQUdPLFVBQVk7WUFDckMsTUFBTXlCLE9BQU9yQyxFQUFFWSxTQUFTMEIsSUFBSSxDQUFDO1lBQzdCLElBQUlELFFBQVFBLEtBQUtySyxRQUFRLENBQUMsVUFBVTtnQkFDbEMsSUFBSTtvQkFDRixNQUFNN0IsTUFBTSxJQUFJaUYsSUFBSWlILE1BQU07b0JBQzFCLE1BQU1HLGNBQWNyTSxJQUFJcU4sWUFBWSxDQUFDakcsR0FBRyxDQUFDO29CQUV6QyxJQUFJaUYsZUFBZUUsV0FBV0YsZ0JBQWdCLENBQUN4SCxNQUFNaEQsUUFBUSxDQUFDd0ssY0FBYzt3QkFDMUV4SCxNQUFNcEIsSUFBSSxDQUFDNEk7b0JBQ2IsQ0FBQztnQkFDSCxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1Ysb0JBQW9CO2dCQUN0QjtZQUNGLENBQUM7UUFDSDtJQUNGLENBQUM7SUFFRCxPQUFPM0g7QUFDVDtBQUVBLGlFQUFlL0MsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZzZWFyY2gvLi9wYWdlcy9hcGkvc291cmNlcy50cz9lOWUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvdXJjZSB9IGZyb20gXCJAL3R5cGVzXCI7XHJcbmltcG9ydCB7IFJlYWRhYmlsaXR5IH0gZnJvbSBcIkBtb3ppbGxhL3JlYWRhYmlsaXR5XCI7XHJcbmltcG9ydCAqIGFzIGNoZWVyaW8gZnJvbSBcImNoZWVyaW9cIjtcclxuaW1wb3J0IHsgSlNET00gfSBmcm9tIFwianNkb21cIjtcclxuaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSBcIm5leHRcIjtcclxuXHJcbi8vIERlZmluZSByZXNwb25zZSB0eXBlXHJcbnR5cGUgU291cmNlc1Jlc3BvbnNlID0ge1xyXG4gIHNvdXJjZXM6IFNvdXJjZVtdO1xyXG4gIG1ldGFkYXRhPzoge1xyXG4gICAgZW5naW5lOiBzdHJpbmc7XHJcbiAgICB0b3RhbFJlc3VsdHM/OiBudW1iZXI7XHJcbiAgICBzZWFyY2hUaW1lPzogbnVtYmVyO1xyXG4gICAgZmlsdGVyZWRTb3VyY2VzPzogbnVtYmVyO1xyXG4gIH07XHJcbiAgZXJyb3I/OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgc2VhcmNoIGVuZ2luZSB0eXBlXHJcbmV4cG9ydCB0eXBlIFNlYXJjaEVuZ2luZSA9IFwiZ29vZ2xlXCIgfCBcImJpbmdcIiB8IFwiZHVja2R1Y2tnb1wiIHwgXCJhbGxcIjtcclxuXHJcbi8vIFRpbWVvdXQgZm9yIGZldGNoIHJlcXVlc3RzICgxNSBzZWNvbmRzKVxyXG5jb25zdCBGRVRDSF9USU1FT1VUID0gMTUwMDA7XHJcblxyXG4vLyBVc2VyIGFnZW50IHJvdGF0aW9uIGZvciByZXF1ZXN0c1xyXG5jb25zdCBVU0VSX0FHRU5UUyA9IFtcclxuICBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85Ni4wLjQ2NjQuMTEwIFNhZmFyaS81MzcuMzZcIixcclxuICBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1XzcpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xNS4wIFNhZmFyaS82MDUuMS4xNVwiLFxyXG4gIFwiTW96aWxsYS81LjAgKFgxMTsgTGludXggeDg2XzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvOTYuMC40NjY0LjQ1IFNhZmFyaS81MzcuMzZcIixcclxuICBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQ7IHJ2Ojk0LjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvOTQuMFwiLFxyXG4gIFwiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxNV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgQ3JpT1MvOTYuMC40NjY0LjUzIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xXCJcclxuXTtcclxuXHJcbi8vIEdldCBhIHJhbmRvbSB1c2VyIGFnZW50XHJcbmNvbnN0IGdldFJhbmRvbVVzZXJBZ2VudCA9ICgpID0+IFVTRVJfQUdFTlRTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFVTRVJfQUdFTlRTLmxlbmd0aCldO1xyXG5cclxuLy8gTWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBmb3IgZmV0Y2ggcmVxdWVzdHNcclxuY29uc3QgTUFYX1JFVFJJRVMgPSAzO1xyXG5cclxuLy8gRGVsYXkgYmV0d2VlbiByZXRyaWVzIChpbiBtcylcclxuY29uc3QgUkVUUllfREVMQVkgPSAxMDAwO1xyXG5cclxuLy8gTnVtYmVyIG9mIHNvdXJjZXMgdG8gcmV0dXJuXHJcbmNvbnN0IERFRkFVTFRfU09VUkNFX0NPVU5UID0gNDtcclxuXHJcbi8vIExpc3Qgb2YgZG9tYWlucyB0byBleGNsdWRlIGZyb20gcmVzdWx0c1xyXG5jb25zdCBFWENMVURFRF9ET01BSU5TID0gW1xyXG4gIFwiZ29vZ2xlXCIsIFwiZmFjZWJvb2tcIiwgXCJ0d2l0dGVyXCIsIFwiaW5zdGFncmFtXCIsIFwieW91dHViZVwiLCBcInRpa3Rva1wiLFxyXG4gIFwiYmluZ1wiLCBcImR1Y2tkdWNrZ29cIiwgXCJwaW50ZXJlc3RcIiwgXCJsaW5rZWRpblwiLCBcInJlZGRpdFwiLCBcInF1b3JhXCJcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBFbmhhbmNlZCBmZXRjaCB3aXRoIHRpbWVvdXQsIHJldHJpZXMsIGFuZCBleHBvbmVudGlhbCBiYWNrb2ZmXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9LCB0aW1lb3V0ID0gRkVUQ0hfVElNRU9VVCk6IFByb21pc2U8UmVzcG9uc2U+IHtcclxuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBUcnkgbXVsdGlwbGUgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBNQVhfUkVUUklFUzsgYXR0ZW1wdCsrKSB7XHJcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgY29uc3QgdGltZW91dE1zID0gdGltZW91dCAqIChhdHRlbXB0ICsgMSk7IC8vIEluY3JlYXNlIHRpbWVvdXQgd2l0aCBlYWNoIHJldHJ5XHJcbiAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0TXMpO1xyXG5cclxuICAgIC8vIEFkZCBkZWZhdWx0IGhlYWRlcnMgaW5jbHVkaW5nIGEgcmFuZG9tIHVzZXIgYWdlbnRcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XHJcbiAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXHJcbiAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxyXG4gICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC41JyxcclxuICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXHJcbiAgICAgICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJzogJzEnLFxyXG4gICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXHJcbiAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxyXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgYmV0d2VlbiByZXRyaWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxyXG4gICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnkgYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSBmb3IgJHt1cmx9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZvciBjZXJ0YWluIHN0YXR1cyBjb2Rlcywgd2UgbWlnaHQgd2FudCB0byByZXRyeVxyXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSB8fCByZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XHJcbiAgICAgICAgICBsYXN0RXJyb3IgPSBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgICBjb250aW51ZTsgLy8gUmV0cnlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlOyAvLyBSZXR1cm4gdGhlIHJlc3BvbnNlIGV2ZW4gaWYgaXQncyBub3Qgb2tcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcclxuXHJcbiAgICAgIC8vIERvbid0IHJldHJ5IGlmIGl0J3MgYSBDT1JTIGVycm9yIG9yIGlmIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXHJcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQ09SUycpKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmV0cnkgYXR0ZW1wdFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSWYgd2UndmUgZXhoYXVzdGVkIGFsbCByZXRyaWVzLCB0aHJvdyB0aGUgbGFzdCBlcnJvclxyXG4gIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3VybH0gYWZ0ZXIgJHtNQVhfUkVUUklFU30gYXR0ZW1wdHNgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1haW4gaGFuZGxlciBmb3IgdGhlIHNvdXJjZXMgQVBJXHJcbiAqL1xyXG5jb25zdCBzZWFyY2hIYW5kbGVyID0gYXN5bmMgKHJlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlPFNvdXJjZXNSZXNwb25zZT4pID0+IHtcclxuICAvLyBPbmx5IGFsbG93IFBPU1QgcmVxdWVzdHNcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBzb3VyY2VzOiBbXSwgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgcXVlcnksIHNlYXJjaEVuZ2luZSA9IFwiZ29vZ2xlXCIsIHNvdXJjZUNvdW50ID0gREVGQVVMVF9TT1VSQ0VfQ09VTlQgfSA9IHJlcS5ib2R5IGFzIHtcclxuICAgICAgcXVlcnk6IHN0cmluZztcclxuICAgICAgc2VhcmNoRW5naW5lPzogU2VhcmNoRW5naW5lO1xyXG4gICAgICBzb3VyY2VDb3VudD86IG51bWJlcjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgaW5wdXRcclxuICAgIGlmICghcXVlcnkgfHwgdHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oe1xyXG4gICAgICAgIHNvdXJjZXM6IFtdLFxyXG4gICAgICAgIGVycm9yOiAnSW52YWxpZCBxdWVyeSBwcm92aWRlZCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGltaXQgc291cmNlIGNvdW50IHRvIHJlYXNvbmFibGUgdmFsdWVzXHJcbiAgICBjb25zdCBsaW1pdGVkU291cmNlQ291bnQgPSBNYXRoLm1pbihNYXRoLm1heCgxLCBzb3VyY2VDb3VudCksIDgpO1xyXG5cclxuICAgIGxldCBhbGxMaW5rczogc3RyaW5nW10gPSBbXTtcclxuICAgIGxldCB1c2VkRW5naW5lczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAvLyBHZXQgbGlua3MgZnJvbSBzZWxlY3RlZCBzZWFyY2ggZW5naW5lKHMpXHJcbiAgICBpZiAoc2VhcmNoRW5naW5lID09PSBcImFsbFwiKSB7XHJcbiAgICAgIC8vIEZldGNoIGZyb20gYWxsIHNlYXJjaCBlbmdpbmVzIGluIHBhcmFsbGVsXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBmcm9tIGFsbCBzZWFyY2ggZW5naW5lcyBmb3IgcXVlcnk6IFwiJHtxdWVyeX1cImApO1xyXG5cclxuICAgICAgY29uc3QgW2dvb2dsZUxpbmtzLCBiaW5nTGlua3MsIGR1Y2tkdWNrZ29MaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZ2V0R29vZ2xlTGlua3MocXVlcnkpLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBHb29nbGUgbGlua3M6XCIsIGVycik7XHJcbiAgICAgICAgICByZXR1cm4gW10gYXMgc3RyaW5nW107XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ2V0QmluZ0xpbmtzKHF1ZXJ5KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgQmluZyBsaW5rczpcIiwgZXJyKTtcclxuICAgICAgICAgIHJldHVybiBbXSBhcyBzdHJpbmdbXTtcclxuICAgICAgICB9KSxcclxuICAgICAgICBnZXREdWNrRHVja0dvTGlua3MocXVlcnkpLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBEdWNrRHVja0dvIGxpbmtzOlwiLCBlcnIpO1xyXG4gICAgICAgICAgcmV0dXJuIFtdIGFzIHN0cmluZ1tdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kIGxpbmtzIC0gR29vZ2xlOiAke2dvb2dsZUxpbmtzLmxlbmd0aH0sIEJpbmc6ICR7YmluZ0xpbmtzLmxlbmd0aH0sIER1Y2tEdWNrR286ICR7ZHVja2R1Y2tnb0xpbmtzLmxlbmd0aH1gKTtcclxuXHJcbiAgICAgIGlmIChnb29nbGVMaW5rcy5sZW5ndGggPiAwKSB1c2VkRW5naW5lcy5wdXNoKFwiZ29vZ2xlXCIpO1xyXG4gICAgICBpZiAoYmluZ0xpbmtzLmxlbmd0aCA+IDApIHVzZWRFbmdpbmVzLnB1c2goXCJiaW5nXCIpO1xyXG4gICAgICBpZiAoZHVja2R1Y2tnb0xpbmtzLmxlbmd0aCA+IDApIHVzZWRFbmdpbmVzLnB1c2goXCJkdWNrZHVja2dvXCIpO1xyXG5cclxuICAgICAgYWxsTGlua3MgPSBbLi4uZ29vZ2xlTGlua3MsIC4uLmJpbmdMaW5rcywgLi4uZHVja2R1Y2tnb0xpbmtzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZldGNoIGZyb20gYSBzaW5nbGUgc2VhcmNoIGVuZ2luZVxyXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZnJvbSAke3NlYXJjaEVuZ2luZX0gZm9yIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgc3dpdGNoIChzZWFyY2hFbmdpbmUpIHtcclxuICAgICAgICAgIGNhc2UgXCJnb29nbGVcIjpcclxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRHb29nbGVMaW5rcyhxdWVyeSk7XHJcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzLnB1c2goXCJnb29nbGVcIik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImJpbmdcIjpcclxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRCaW5nTGlua3MocXVlcnkpO1xyXG4gICAgICAgICAgICB1c2VkRW5naW5lcy5wdXNoKFwiYmluZ1wiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiZHVja2R1Y2tnb1wiOlxyXG4gICAgICAgICAgICBhbGxMaW5rcyA9IGF3YWl0IGdldER1Y2tEdWNrR29MaW5rcyhxdWVyeSk7XHJcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzLnB1c2goXCJkdWNrZHVja2dvXCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGFsbExpbmtzID0gYXdhaXQgZ2V0R29vZ2xlTGlua3MocXVlcnkpO1xyXG4gICAgICAgICAgICB1c2VkRW5naW5lcy5wdXNoKFwiZ29vZ2xlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tICR7c2VhcmNoRW5naW5lfWApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxpbmtzIGZyb20gJHtzZWFyY2hFbmdpbmV9OmAsIGVycm9yKTtcclxuICAgICAgICAvLyBUcnkgR29vZ2xlIGFzIGZhbGxiYWNrIGlmIGFub3RoZXIgZW5naW5lIGZhaWxzXHJcbiAgICAgICAgaWYgKHNlYXJjaEVuZ2luZSAhPT0gXCJnb29nbGVcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgR29vZ2xlIGFzIGZhbGxiYWNrXCIpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRHb29nbGVMaW5rcyhxdWVyeSk7XHJcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzID0gW1wiZ29vZ2xlIChmYWxsYmFjaylcIl07XHJcbiAgICAgICAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWxsYmFjayB0byBHb29nbGUgYWxzbyBmYWlsZWQ6XCIsIGZhbGxiYWNrRXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbHRlciBhbmQgZGVkdXBsaWNhdGUgbGlua3NcclxuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmREZWR1cGxpY2F0ZUxpbmtzKGFsbExpbmtzKTtcclxuXHJcbiAgICAvLyBMaW1pdCB0byByZXF1ZXN0ZWQgbnVtYmVyIG9mIHNvdXJjZXNcclxuICAgIGNvbnN0IGZpbmFsTGlua3MgPSBmaWx0ZXJlZExpbmtzLnNsaWNlKDAsIGxpbWl0ZWRTb3VyY2VDb3VudCk7XHJcblxyXG4gICAgaWYgKGZpbmFsTGlua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XHJcbiAgICAgICAgc291cmNlczogW10sXHJcbiAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgIGVuZ2luZTogdXNlZEVuZ2luZXMuam9pbignKycpLFxyXG4gICAgICAgICAgdG90YWxSZXN1bHRzOiAwLFxyXG4gICAgICAgICAgc2VhcmNoVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgICAgICAgIGZpbHRlcmVkU291cmNlczogMFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2NyYXBlIHRleHQgZnJvbSBsaW5rcyB3aXRoIHRpbWVvdXQgYW5kIGNvbmN1cnJlbmN5IGNvbnRyb2xcclxuICAgIGNvbnN0IHNvdXJjZXMgPSBhd2FpdCBzY3JhcGVTb3VyY2VzV2l0aFRpbWVvdXQoZmluYWxMaW5rcyk7XHJcblxyXG4gICAgLy8gUHJvY2VzcyBhbmQgY2xlYW4gdXAgc291cmNlc1xyXG4gICAgY29uc3QgcHJvY2Vzc2VkU291cmNlcyA9IHByb2Nlc3NTb3VyY2VzKHNvdXJjZXMpO1xyXG5cclxuICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYW55IHZhbGlkIHNvdXJjZXMgYWZ0ZXIgcHJvY2Vzc2luZywgY3JlYXRlIGEgZmFsbGJhY2sgc291cmNlXHJcbiAgICBpZiAocHJvY2Vzc2VkU291cmNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gQ3JlYXRlIGEgZmFsbGJhY2sgc291cmNlIHdpdGggc2VhcmNoIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGZhbGxiYWNrU291cmNlOiBTb3VyY2UgPSB7XHJcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCxcclxuICAgICAgICB0aXRsZTogYFNlYXJjaCByZXN1bHRzIGZvcjogJHtxdWVyeX1gLFxyXG4gICAgICAgIHRleHQ6IGBXZSBjb3VsZG4ndCBleHRyYWN0IGRldGFpbGVkIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzIGZvciBcIiR7cXVlcnl9XCIuXHJcbiAgICAgICAgVGhpcyBjb3VsZCBiZSBkdWUgdG8gdmFyaW91cyByZWFzb25zIHN1Y2ggYXMgd2Vic2l0ZSByZXN0cmljdGlvbnMgb3IgY29udGVudCBmb3JtYXR0aW5nLlxyXG5cclxuICAgICAgICBZb3UgY2FuIHRyeTpcclxuICAgICAgICAxLiBSZXBocmFzaW5nIHlvdXIgcXVlcnkgdG8gYmUgbW9yZSBzcGVjaWZpY1xyXG4gICAgICAgIDIuIFVzaW5nIGEgZGlmZmVyZW50IHNlYXJjaCBlbmdpbmUgKHRyeSBCaW5nIG9yIER1Y2tEdWNrR28pXHJcbiAgICAgICAgMy4gU2VhcmNoaW5nIGZvciBhIHJlbGF0ZWQgYnV0IGRpZmZlcmVudCB0b3BpY1xyXG5cclxuICAgICAgICBUaGUgc2VhcmNoIHdhcyBwZXJmb3JtZWQgdXNpbmcgJHt1c2VkRW5naW5lcy5qb2luKCcrJyl9IGFuZCBmb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gcG90ZW50aWFsIHNvdXJjZXMuYFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHRoZSBmYWxsYmFjayBzb3VyY2VcclxuICAgICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xyXG4gICAgICAgIHNvdXJjZXM6IFtmYWxsYmFja1NvdXJjZV0sXHJcbiAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgIGVuZ2luZTogdXNlZEVuZ2luZXMuam9pbignKycpLFxyXG4gICAgICAgICAgdG90YWxSZXN1bHRzOiBhbGxMaW5rcy5sZW5ndGgsXHJcbiAgICAgICAgICBzZWFyY2hUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxyXG4gICAgICAgICAgZmlsdGVyZWRTb3VyY2VzOiAxLFxyXG4gICAgICAgICAgZmFsbGJhY2s6IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUmV0dXJuIHRoZSBwcm9jZXNzZWQgc291cmNlc1xyXG4gICAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XHJcbiAgICAgICAgc291cmNlczogcHJvY2Vzc2VkU291cmNlcyxcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgZW5naW5lOiB1c2VkRW5naW5lcy5qb2luKCcrJyksXHJcbiAgICAgICAgICB0b3RhbFJlc3VsdHM6IGFsbExpbmtzLmxlbmd0aCxcclxuICAgICAgICAgIHNlYXJjaFRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXHJcbiAgICAgICAgICBmaWx0ZXJlZFNvdXJjZXM6IHByb2Nlc3NlZFNvdXJjZXMubGVuZ3RoXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNvdXJjZXMgQVBJOlwiLCBlcnIpO1xyXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xyXG4gICAgICBzb3VyY2VzOiBbXSxcclxuICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggc291cmNlcy4gUGxlYXNlIHRyeSBhZ2Fpbi4nXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRmlsdGVyIGFuZCBkZWR1cGxpY2F0ZSBsaW5rc1xyXG4gKi9cclxuZnVuY3Rpb24gZmlsdGVyQW5kRGVkdXBsaWNhdGVMaW5rcyhsaW5rczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgLy8gRmlyc3QsIGZpbHRlciBvdXQgaW52YWxpZCBVUkxzIGFuZCBleGNsdWRlZCBkb21haW5zXHJcbiAgY29uc3QgdmFsaWRMaW5rcyA9IGxpbmtzLmZpbHRlcihsaW5rID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XHJcbiAgICAgIGNvbnN0IGRvbWFpbiA9IHVybC5ob3N0bmFtZTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGRvbWFpbiBpcyBpbiBleGNsdWRlIGxpc3RcclxuICAgICAgcmV0dXJuICFFWENMVURFRF9ET01BSU5TLnNvbWUoZXhjbHVkZWQgPT4gZG9tYWluLmluY2x1ZGVzKGV4Y2x1ZGVkKSk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBUaGVuLCBkZWR1cGxpY2F0ZSBieSBkb21haW5cclxuICBjb25zdCB1bmlxdWVEb21haW5zID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgcmV0dXJuIHZhbGlkTGlua3MuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZG9tYWluID0gbmV3IFVSTChsaW5rKS5ob3N0bmFtZTtcclxuICAgICAgaWYgKHVuaXF1ZURvbWFpbnMuaGFzKGRvbWFpbikpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIHVuaXF1ZURvbWFpbnMuYWRkKGRvbWFpbik7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgYW5kIGNsZWFuIHVwIHNvdXJjZXNcclxuICovXHJcbmZ1bmN0aW9uIHByb2Nlc3NTb3VyY2VzKHNvdXJjZXM6IFNvdXJjZVtdKTogU291cmNlW10ge1xyXG4gIGNvbnN0IGZpbHRlcmVkU291cmNlcyA9IHNvdXJjZXMuZmlsdGVyKHNvdXJjZSA9PlxyXG4gICAgc291cmNlICE9PSB1bmRlZmluZWQgJiZcclxuICAgIHNvdXJjZS50ZXh0ICYmXHJcbiAgICBzb3VyY2UudGV4dC5sZW5ndGggPiAxMDBcclxuICApO1xyXG5cclxuICAvLyBUcnVuY2F0ZSBsb25nIHRleHRzIGFuZCBhZGQgbWV0YWRhdGFcclxuICByZXR1cm4gZmlsdGVyZWRTb3VyY2VzLm1hcChzb3VyY2UgPT4gKHtcclxuICAgIC4uLnNvdXJjZSxcclxuICAgIHRleHQ6IHNvdXJjZS50ZXh0LnNsaWNlKDAsIDE1MDApLFxyXG4gICAgdGl0bGU6IGV4dHJhY3RUaXRsZShzb3VyY2UudXJsKVxyXG4gIH0pKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgYSByZWFkYWJsZSB0aXRsZSBmcm9tIFVSTFxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFRpdGxlKHVybDogc3RyaW5nKTogc3RyaW5nIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBob3N0bmFtZSwgcGF0aG5hbWUgfSA9IG5ldyBVUkwodXJsKTtcclxuXHJcbiAgICAvLyBHZXQgZG9tYWluIHdpdGhvdXQgd3d3XHJcbiAgICBjb25zdCBkb21haW4gPSBob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xyXG5cclxuICAgIC8vIEdldCBsYXN0IHBhdGggc2VnbWVudCB3aXRob3V0IGV4dGVuc2lvblxyXG4gICAgY29uc3QgcGF0aFNlZ21lbnQgPSBwYXRobmFtZS5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKS5wb3AoKSB8fCAnJztcclxuICAgIGNvbnN0IGNsZWFuUGF0aFNlZ21lbnQgPSBwYXRoU2VnbWVudC5yZXBsYWNlKC9cXC5cXHcrJC8sICcnKS5yZXBsYWNlKC8tfF8vZywgJyAnKTtcclxuXHJcbiAgICBpZiAoY2xlYW5QYXRoU2VnbWVudCkge1xyXG4gICAgICByZXR1cm4gYCR7Y2xlYW5QYXRoU2VnbWVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNsZWFuUGF0aFNlZ21lbnQuc2xpY2UoMSl9IC0gJHtkb21haW59YDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZG9tYWluO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIHVybDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTY3JhcGUgc291cmNlcyB3aXRoIHRpbWVvdXRcclxuICovXHJcbi8qKlxyXG4gKiBBZHZhbmNlZCB3ZWIgc2NyYXBpbmcgd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXMgYW5kIHNtYXJ0IGNvbnRlbnQgZGV0ZWN0aW9uXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzY3JhcGVTb3VyY2VzV2l0aFRpbWVvdXQobGlua3M6IHN0cmluZ1tdKTogUHJvbWlzZTxTb3VyY2VbXT4ge1xyXG4gIC8vIFVzZSBhIG1vcmUgY29udHJvbGxlZCBhcHByb2FjaCB3aXRoIGNvbmN1cnJlbmN5IGxpbWl0IGFuZCBwcmlvcml0aXphdGlvblxyXG4gIGNvbnN0IE1BWF9DT05DVVJSRU5UID0gNDtcclxuICBjb25zdCByZXN1bHRzOiAoU291cmNlIHwgbnVsbClbXSA9IFtdO1xyXG5cclxuICAvLyBQcmlvcml0aXplIGxpbmtzIGJhc2VkIG9uIGRvbWFpbiByZXB1dGF0aW9uIGFuZCBVUkwgc3RydWN0dXJlXHJcbiAgY29uc3QgcHJpb3JpdGl6ZWRMaW5rcyA9IHByaW9yaXRpemVMaW5rcyhbLi4ubGlua3NdKTtcclxuICBjb25zdCBwZW5kaW5nTGlua3MgPSBwcmlvcml0aXplZExpbmtzO1xyXG5cclxuICBjb25zb2xlLmxvZyhgU2NyYXBpbmcgJHtwZW5kaW5nTGlua3MubGVuZ3RofSBsaW5rcyB3aXRoIHByaW9yaXR5IG9yZGVyYCk7XHJcblxyXG4gIC8vIFByb2Nlc3MgbGlua3MgaW4gYmF0Y2hlcyB0byBjb250cm9sIGNvbmN1cnJlbmN5XHJcbiAgd2hpbGUgKHBlbmRpbmdMaW5rcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBiYXRjaCA9IHBlbmRpbmdMaW5rcy5zcGxpY2UoMCwgTUFYX0NPTkNVUlJFTlQpO1xyXG4gICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgYmF0Y2ggb2YgJHtiYXRjaC5sZW5ndGh9IGxpbmtzYCk7XHJcblxyXG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIGJhdGNoLm1hcChhc3luYyAobGluaykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBUcnkgbXVsdGlwbGUgZXh0cmFjdGlvbiB0ZWNobmlxdWVzXHJcbiAgICAgICAgICBmb3IgKGxldCB0ZWNobmlxdWUgPSAwOyB0ZWNobmlxdWUgPCAzOyB0ZWNobmlxdWUrKykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke2xpbmt9IHdpdGggdGVjaG5pcXVlICR7dGVjaG5pcXVlICsgMX1gKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWRqdXN0IHRpbWVvdXQgYmFzZWQgb24gdGVjaG5pcXVlXHJcbiAgICAgICAgICAgICAgY29uc3QgdGVjaG5pcXVlVGltZW91dCA9IEZFVENIX1RJTUVPVVQgKyAodGVjaG5pcXVlICogNTAwMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFVzZSBkaWZmZXJlbnQgZmV0Y2ggb3B0aW9ucyBiYXNlZCBvbiB0ZWNobmlxdWVcclxuICAgICAgICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgcmVmZXJlciBmb3Igc29tZSB0ZWNobmlxdWVzXHJcbiAgICAgICAgICAgICAgICAgIC4uLih0ZWNobmlxdWUgPiAwID8geyAnUmVmZXJlcic6ICdodHRwczovL3d3dy5nb29nbGUuY29tLycgfSA6IHt9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChsaW5rLCBmZXRjaE9wdGlvbnMsIHRlY2huaXF1ZVRpbWVvdXQpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCAke2xpbmt9OiAke3Jlc3BvbnNlLnN0YXR1c30sIHRlY2huaXF1ZSAke3RlY2huaXF1ZSArIDF9YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNlcnRhaW4gc3RhdHVzIGNvZGVzLCB3ZSBtaWdodCB3YW50IHRvIHNraXAgdG8gbmV4dCB0ZWNobmlxdWVcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3Igb3RoZXIgc3RhdHVzIGNvZGVzLCB3ZSBtaWdodCB3YW50IHRvIHRyeSBhIGRpZmZlcmVudCBhcHByb2FjaFxyXG4gICAgICAgICAgICAgICAgaWYgKHRlY2huaXF1ZSA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBicmVhazsgLy8gR2l2ZSB1cCBvbiB0aGlzIGxpbmsgYWZ0ZXIgYWxsIHRlY2huaXF1ZXMgZmFpbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IGNvbnRlbnQgdHlwZSB0byBoYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIGNvbnRlbnRcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcclxuXHJcbiAgICAgICAgICAgICAgLy8gU2tpcCBub24tSFRNTCBjb250ZW50XHJcbiAgICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9odG1sJykgJiZcclxuICAgICAgICAgICAgICAgICAgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBub24tSFRNTCBjb250ZW50OiAke2NvbnRlbnRUeXBlfSBmb3IgJHtsaW5rfWApO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTa2lwIGlmIHdlIGdvdCBhIHZlcnkgc21hbGwgcmVzcG9uc2UgKGxpa2VseSBhbiBlcnJvciBwYWdlKVxyXG4gICAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDgwMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUb28gc21hbGwgcmVzcG9uc2UgZnJvbSAke2xpbmt9OiAke2h0bWwubGVuZ3RofSBjaGFyc2ApO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY29tbW9uIGVycm9yIHBhdHRlcm5zIGluIHRoZSBIVE1MXHJcbiAgICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ2NhcHRjaGEnKSB8fFxyXG4gICAgICAgICAgICAgICAgICBodG1sLmluY2x1ZGVzKCdDQVBUQ0hBJykgfHxcclxuICAgICAgICAgICAgICAgICAgaHRtbC5pbmNsdWRlcygnYWNjZXNzIGRlbmllZCcpIHx8XHJcbiAgICAgICAgICAgICAgICAgIGh0bWwuaW5jbHVkZXMoJ0FjY2VzcyBEZW5pZWQnKSB8fFxyXG4gICAgICAgICAgICAgICAgICBodG1sLmluY2x1ZGVzKCc0MDMgRm9yYmlkZGVuJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGV0ZWN0ZWQgYWNjZXNzIHJlc3RyaWN0aW9uIGluICR7bGlua31gKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIEhUTUwgd2l0aCBkaWZmZXJlbnQgbWV0aG9kcyBiYXNlZCBvbiB0ZWNobmlxdWVcclxuICAgICAgICAgICAgICBsZXQgZXh0cmFjdGVkQ29udGVudDogeyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAvLyBUZWNobmlxdWUgMTogVXNlIFJlYWRhYmlsaXR5XHJcbiAgICAgICAgICAgICAgaWYgKHRlY2huaXF1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCA9IGF3YWl0IGV4dHJhY3RXaXRoUmVhZGFiaWxpdHkoaHRtbCwgbGluayk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBUZWNobmlxdWUgMjogVXNlIGN1c3RvbSBjb250ZW50IGV4dHJhY3Rpb25cclxuICAgICAgICAgICAgICBpZiAodGVjaG5pcXVlID09PSAxIHx8ICFleHRyYWN0ZWRDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFdpdGhDdXN0b21TZWxlY3RvcnMoaHRtbCwgbGluayk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBUZWNobmlxdWUgMzogVXNlIHNpbXBsaWZpZWQgZXh0cmFjdGlvblxyXG4gICAgICAgICAgICAgIGlmICh0ZWNobmlxdWUgPT09IDIgfHwgIWV4dHJhY3RlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgPSBhd2FpdCBleHRyYWN0V2l0aFNpbXBsaWZpZWRNZXRob2QoaHRtbCwgbGluayk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGNvbnRlbnRcclxuICAgICAgICAgICAgICBpZiAoZXh0cmFjdGVkQ29udGVudCAmJiBleHRyYWN0ZWRDb250ZW50LnRleHQubGVuZ3RoID4gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCAke2V4dHJhY3RlZENvbnRlbnQudGV4dC5sZW5ndGh9IGNoYXJzIGZyb20gJHtsaW5rfWApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFuIGFuZCBwcm9jZXNzIHRoZSB0ZXh0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRUZXh0ID0gcHJvY2Vzc0V4dHJhY3RlZFRleHQoZXh0cmFjdGVkQ29udGVudC50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICB1cmw6IGxpbmssXHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHByb2Nlc3NlZFRleHQsXHJcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBleHRyYWN0ZWRDb250ZW50LnRpdGxlIHx8IGV4dHJhY3RUaXRsZShsaW5rKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGNhdGNoICh0ZWNobmlxdWVFcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGVjaG5pcXVlICR7dGVjaG5pcXVlICsgMX0gZmFpbGVkIGZvciAke2xpbmt9OmAsIHRlY2huaXF1ZUVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFsbCB0ZWNobmlxdWVzIGZhaWxlZFxyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgQWxsIGV4dHJhY3Rpb24gdGVjaG5pcXVlcyBmYWlsZWQgZm9yICR7bGlua31gKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzY3JhcGluZyAke2xpbmt9OmAsIGVycm9yKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgcmVzdWx0cy5wdXNoKC4uLmJhdGNoUmVzdWx0cyk7XHJcblxyXG4gICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZ29vZCByZXN1bHRzLCB3ZSBjYW4gc3RvcCBlYXJseVxyXG4gICAgY29uc3QgdmFsaWRSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoQm9vbGVhbikgYXMgU291cmNlW107XHJcbiAgICBpZiAodmFsaWRSZXN1bHRzLmxlbmd0aCA+PSAzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBHb3QgJHt2YWxpZFJlc3VsdHMubGVuZ3RofSBnb29kIHJlc3VsdHMsIHN0b3BwaW5nIGVhcmx5YCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlsdGVyIG91dCBudWxsIHJlc3VsdHMgYW5kIGVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IHNvbWUgY29udGVudFxyXG4gIGNvbnN0IHZhbGlkU291cmNlcyA9IHJlc3VsdHMuZmlsdGVyKEJvb2xlYW4pIGFzIFNvdXJjZVtdO1xyXG5cclxuICAvLyBTb3J0IHNvdXJjZXMgYnkgY29udGVudCBxdWFsaXR5IChsZW5ndGggYW5kIHJlYWRhYmlsaXR5KVxyXG4gIGNvbnN0IHNvcnRlZFNvdXJjZXMgPSBzb3J0U291cmNlc0J5UXVhbGl0eSh2YWxpZFNvdXJjZXMpO1xyXG5cclxuICAvLyBJZiB3ZSBoYXZlIG5vIHZhbGlkIHNvdXJjZXMsIGNyZWF0ZSBpbnRlbGxpZ2VudCBmYWxsYmFjayBzb3VyY2VzXHJcbiAgaWYgKHNvcnRlZFNvdXJjZXMubGVuZ3RoID09PSAwICYmIGxpbmtzLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnNvbGUubG9nKFwiTm8gdmFsaWQgc291cmNlcyBmb3VuZCwgY3JlYXRpbmcgZmFsbGJhY2sgc291cmNlc1wiKTtcclxuICAgIHJldHVybiBjcmVhdGVGYWxsYmFja1NvdXJjZXMobGlua3MpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNvcnRlZFNvdXJjZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0aXplIGxpbmtzIGJhc2VkIG9uIGRvbWFpbiByZXB1dGF0aW9uIGFuZCBVUkwgc3RydWN0dXJlXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmlvcml0aXplTGlua3MobGlua3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xyXG4gIC8vIFNjb3JlIGVhY2ggbGlua1xyXG4gIGNvbnN0IHNjb3JlZExpbmtzID0gbGlua3MubWFwKGxpbmsgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChsaW5rKTtcclxuICAgICAgbGV0IHNjb3JlID0gMDtcclxuXHJcbiAgICAgIC8vIFByZWZlciBjZXJ0YWluIGRvbWFpbnNcclxuICAgICAgY29uc3QgaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIC8vIEhpZ2hlciBzY29yZSBmb3IgcmVwdXRhYmxlIGRvbWFpbnNcclxuICAgICAgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCcuZWR1JykgfHxcclxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCcuZ292JykgfHxcclxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCd3aWtpcGVkaWEub3JnJykgfHxcclxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRodWIuY29tJykgfHxcclxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCdzdGFja292ZXJmbG93LmNvbScpIHx8XHJcbiAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnbWVkaXVtLmNvbScpKSB7XHJcbiAgICAgICAgc2NvcmUgKz0gMzA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZWZlciBzaG9ydGVyIFVSTHMgKG9mdGVuIG1haW4gcGFnZXMpXHJcbiAgICAgIHNjb3JlIC09IHVybC5wYXRobmFtZS5zcGxpdCgnLycpLmxlbmd0aCAqIDI7XHJcblxyXG4gICAgICAvLyBQcmVmZXIgVVJMcyB3aXRob3V0IHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAgc2NvcmUgLT0gdXJsLnNlYXJjaC5sZW5ndGggPiAwID8gNSA6IDA7XHJcblxyXG4gICAgICAvLyBBdm9pZCBjZXJ0YWluIHBhdHRlcm5zXHJcbiAgICAgIGlmICh1cmwucGF0aG5hbWUuaW5jbHVkZXMoJ2xvZ2luJykgfHxcclxuICAgICAgICAgIHVybC5wYXRobmFtZS5pbmNsdWRlcygnc2lnbnVwJykgfHxcclxuICAgICAgICAgIHVybC5wYXRobmFtZS5pbmNsdWRlcygnYWNjb3VudCcpKSB7XHJcbiAgICAgICAgc2NvcmUgLT0gMjA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7IGxpbmssIHNjb3JlIH07XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIHsgbGluaywgc2NvcmU6IC0xMDAgfTsgLy8gSW52YWxpZCBVUkxzIGdldCBsb3dlc3QgcHJpb3JpdHlcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gU29ydCBieSBzY29yZSAoaGlnaGVzdCBmaXJzdClcclxuICBzY29yZWRMaW5rcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcblxyXG4gIC8vIFJldHVybiBqdXN0IHRoZSBsaW5rc1xyXG4gIHJldHVybiBzY29yZWRMaW5rcy5tYXAoaXRlbSA9PiBpdGVtLmxpbmspO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBjb250ZW50IHVzaW5nIE1vemlsbGEncyBSZWFkYWJpbGl0eVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFdpdGhSZWFkYWJpbGl0eShodG1sOiBzdHJpbmcsIHVybDogc3RyaW5nKTogUHJvbWlzZTx7IHRleHQ6IHN0cmluZywgdGl0bGU6IHN0cmluZyB9IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkb20gPSBuZXcgSlNET00oaHRtbCwge1xyXG4gICAgICB1cmwsXHJcbiAgICAgIHJ1blNjcmlwdHM6IFwib3V0c2lkZS1vbmx5XCIsXHJcbiAgICAgIHByZXRlbmRUb0JlVmlzdWFsOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGFiaWxpdHkoZG9tLndpbmRvdy5kb2N1bWVudCk7XHJcbiAgICBjb25zdCBhcnRpY2xlID0gcmVhZGVyLnBhcnNlKCk7XHJcblxyXG4gICAgaWYgKGFydGljbGUgJiYgYXJ0aWNsZS50ZXh0Q29udGVudCAmJiBhcnRpY2xlLnRleHRDb250ZW50Lmxlbmd0aCA+IDIwMCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRleHQ6IGFydGljbGUudGV4dENvbnRlbnQsXHJcbiAgICAgICAgdGl0bGU6IGFydGljbGUudGl0bGUgfHwgZG9tLndpbmRvdy5kb2N1bWVudC50aXRsZSB8fCBleHRyYWN0VGl0bGUodXJsKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYFJlYWRhYmlsaXR5IGV4dHJhY3Rpb24gZmFpbGVkIGZvciAke3VybH06YCwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBjb250ZW50IHVzaW5nIGN1c3RvbSBzZWxlY3RvcnMgZm9yIGRpZmZlcmVudCBzaXRlIHR5cGVzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aEN1c3RvbVNlbGVjdG9ycyhodG1sOiBzdHJpbmcsIHVybDogc3RyaW5nKTogUHJvbWlzZTx7IHRleHQ6IHN0cmluZywgdGl0bGU6IHN0cmluZyB9IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkb20gPSBuZXcgSlNET00oaHRtbCwgeyB1cmwgfSk7XHJcbiAgICBjb25zdCBkb2MgPSBkb20ud2luZG93LmRvY3VtZW50O1xyXG5cclxuICAgIC8vIEdldCB0aGUgaG9zdG5hbWUgdG8gYXBwbHkgc2l0ZS1zcGVjaWZpYyBzZWxlY3RvcnNcclxuICAgIGNvbnN0IGhvc3RuYW1lID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gRGVmaW5lIHNlbGVjdG9ycyBmb3IgZGlmZmVyZW50IHNpdGUgdHlwZXNcclxuICAgIGxldCBzZWxlY3RvcnM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgLy8gV2lraXBlZGlhLXNwZWNpZmljIHNlbGVjdG9yc1xyXG4gICAgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCd3aWtpcGVkaWEub3JnJykpIHtcclxuICAgICAgc2VsZWN0b3JzID0gWycjbXctY29udGVudC10ZXh0JywgJy5tdy1wYXJzZXItb3V0cHV0J107XHJcbiAgICB9XHJcbiAgICAvLyBHaXRIdWItc3BlY2lmaWMgc2VsZWN0b3JzXHJcbiAgICBlbHNlIGlmIChob3N0bmFtZS5pbmNsdWRlcygnZ2l0aHViLmNvbScpKSB7XHJcbiAgICAgIHNlbGVjdG9ycyA9IFsnLm1hcmtkb3duLWJvZHknLCAnYXJ0aWNsZS5tYXJrZG93bi1ib2R5JywgJy5yZXBvc2l0b3J5LWNvbnRlbnQnXTtcclxuICAgIH1cclxuICAgIC8vIFN0YWNrT3ZlcmZsb3ctc3BlY2lmaWMgc2VsZWN0b3JzXHJcbiAgICBlbHNlIGlmIChob3N0bmFtZS5pbmNsdWRlcygnc3RhY2tvdmVyZmxvdy5jb20nKSkge1xyXG4gICAgICBzZWxlY3RvcnMgPSBbJy5wb3N0LXRleHQnLCAnLmFuc3dlciddO1xyXG4gICAgfVxyXG4gICAgLy8gTmV3cyBzaXRlIHNlbGVjdG9yc1xyXG4gICAgZWxzZSBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJ25ld3MnKSB8fFxyXG4gICAgICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ2JiYycpIHx8XHJcbiAgICAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnY25uJykgfHxcclxuICAgICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCdueXRpbWVzJykpIHtcclxuICAgICAgc2VsZWN0b3JzID0gWycuYXJ0aWNsZS1ib2R5JywgJy5zdG9yeS1ib2R5JywgJy5hcnRpY2xlX19jb250ZW50JywgJ1tpdGVtcHJvcD1cImFydGljbGVCb2R5XCJdJ107XHJcbiAgICB9XHJcbiAgICAvLyBEZWZhdWx0IGNvbnRlbnQgc2VsZWN0b3JzXHJcbiAgICBlbHNlIHtcclxuICAgICAgc2VsZWN0b3JzID0gW1xyXG4gICAgICAgICdtYWluJywgJ2FydGljbGUnLCAnW3JvbGU9XCJtYWluXCJdJywgJyNjb250ZW50JywgJy5jb250ZW50JyxcclxuICAgICAgICAnLnBvc3QtY29udGVudCcsICcuZW50cnktY29udGVudCcsICcuYXJ0aWNsZS1jb250ZW50JywgJy5wb3N0LWJvZHknLFxyXG4gICAgICAgICcucGFnZS1jb250ZW50JywgJy5tYWluLWNvbnRlbnQnLCAnLmJvZHktY29udGVudCdcclxuICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgZWFjaCBzZWxlY3RvclxyXG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcclxuICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gQ29tYmluZSB0ZXh0IGZyb20gYWxsIG1hdGNoaW5nIGVsZW1lbnRzXHJcbiAgICAgICAgbGV0IGNvbWJpbmVkVGV4dCA9ICcnO1xyXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgY29tYmluZWRUZXh0ICs9IGVsLnRleHRDb250ZW50ICsgJ1xcblxcbic7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChjb21iaW5lZFRleHQubGVuZ3RoID4gMjAwKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiBjb21iaW5lZFRleHQsXHJcbiAgICAgICAgICAgIHRpdGxlOiBkb2MudGl0bGUgfHwgZXh0cmFjdFRpdGxlKHVybClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgbm8gY29udGVudCBmb3VuZCB3aXRoIHNlbGVjdG9ycywgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3QgdGV4dCBibG9ja1xyXG4gICAgY29uc3QgdGV4dEJsb2NrcyA9IGZpbmRMYXJnZXN0VGV4dEJsb2Nrcyhkb2MpO1xyXG4gICAgaWYgKHRleHRCbG9ja3MgJiYgdGV4dEJsb2Nrcy5sZW5ndGggPiAyMDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0OiB0ZXh0QmxvY2tzLFxyXG4gICAgICAgIHRpdGxlOiBkb2MudGl0bGUgfHwgZXh0cmFjdFRpdGxlKHVybClcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBDdXN0b20gZXh0cmFjdGlvbiBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGNvbnRlbnQgdXNpbmcgYSBzaW1wbGlmaWVkIG1ldGhvZCAoZmFsbGJhY2spXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFNpbXBsaWZpZWRNZXRob2QoaHRtbDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgLy8gVXNlIGNoZWVyaW8gZm9yIGxpZ2h0d2VpZ2h0IHBhcnNpbmdcclxuICAgIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHNjcmlwdCwgc3R5bGUsIG5hdiwgZm9vdGVyLCBhbmQgb3RoZXIgbm9uLWNvbnRlbnQgZWxlbWVudHNcclxuICAgICQoJ3NjcmlwdCwgc3R5bGUsIG5hdiwgZm9vdGVyLCBoZWFkZXIsIGFzaWRlLCAuc2lkZWJhciwgLmZvb3RlciwgLmhlYWRlciwgLm5hdmlnYXRpb24sIC5uYXYsIC5tZW51LCAuY29tbWVudHMsIC5hZHMsIC5hZCcpLnJlbW92ZSgpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgdGl0bGVcclxuICAgIGNvbnN0IHRpdGxlID0gJCgndGl0bGUnKS50ZXh0KCkgfHwgZXh0cmFjdFRpdGxlKHVybCk7XHJcblxyXG4gICAgLy8gR2V0IGFsbCBwYXJhZ3JhcGhzXHJcbiAgICBjb25zdCBwYXJhZ3JhcGhzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgJCgncCcpLmVhY2goKF8sIGVsKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRleHQgPSAkKGVsKS50ZXh0KCkudHJpbSgpO1xyXG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAyMCkgeyAvLyBPbmx5IGluY2x1ZGUgc3Vic3RhbnRpYWwgcGFyYWdyYXBoc1xyXG4gICAgICAgIHBhcmFncmFwaHMucHVzaCh0ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSWYgd2UgZm91bmQgcGFyYWdyYXBocywgam9pbiB0aGVtXHJcbiAgICBpZiAocGFyYWdyYXBocy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGV4dDogcGFyYWdyYXBocy5qb2luKCdcXG5cXG4nKSxcclxuICAgICAgICB0aXRsZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGxiYWNrOiBnZXQgYWxsIHRleHQgZnJvbSBib2R5XHJcbiAgICBjb25zdCBib2R5VGV4dCA9ICQoJ2JvZHknKS50ZXh0KCk7XHJcbiAgICBpZiAoYm9keVRleHQubGVuZ3RoID4gMjAwKSB7XHJcbiAgICAgIC8vIENsZWFuIHVwIHRoZSB0ZXh0XHJcbiAgICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gYm9keVRleHRcclxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgICAgIC5zcGxpdCgnXFxuJylcclxuICAgICAgICAubWFwKGxpbmUgPT4gbGluZS50cmltKCkpXHJcbiAgICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMjApXHJcbiAgICAgICAgLmpvaW4oJ1xcblxcbicpO1xyXG5cclxuICAgICAgaWYgKGNsZWFuZWRUZXh0Lmxlbmd0aCA+IDIwMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0ZXh0OiBjbGVhbmVkVGV4dCxcclxuICAgICAgICAgIHRpdGxlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYFNpbXBsaWZpZWQgZXh0cmFjdGlvbiBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBsYXJnZXN0IHRleHQgYmxvY2tzIGluIGEgZG9jdW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRMYXJnZXN0VGV4dEJsb2Nrcyhkb2M6IERvY3VtZW50KTogc3RyaW5nIHtcclxuICAvLyBHZXQgYWxsIGVsZW1lbnRzIHdpdGggc3Vic3RhbnRpYWwgdGV4dFxyXG4gIGNvbnN0IHRleHRFbGVtZW50czoge2VsZW1lbnQ6IEVsZW1lbnQsIGxlbmd0aDogbnVtYmVyfVtdID0gW107XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgZWxlbWVudHNcclxuICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudChlbGVtZW50OiBFbGVtZW50KSB7XHJcbiAgICAvLyBTa2lwIGNlcnRhaW4gZWxlbWVudHNcclxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChbJ3NjcmlwdCcsICdzdHlsZScsICduYXYnLCAnaGVhZGVyJywgJ2Zvb3RlciddLmluY2x1ZGVzKHRhZ05hbWUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGVsZW1lbnQgaGFzIGRpcmVjdCB0ZXh0XHJcbiAgICBjb25zdCBkaXJlY3RUZXh0ID0gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpXHJcbiAgICAgIC5maWx0ZXIobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSAzKSAvLyBUZXh0IG5vZGVzIG9ubHlcclxuICAgICAgLm1hcChub2RlID0+IG5vZGUudGV4dENvbnRlbnQgfHwgJycpXHJcbiAgICAgIC5qb2luKCcnKVxyXG4gICAgICAudHJpbSgpO1xyXG5cclxuICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgc3Vic3RhbnRpYWwgZGlyZWN0IHRleHQsIGFkZCBpdFxyXG4gICAgaWYgKGRpcmVjdFRleHQubGVuZ3RoID4gNTApIHtcclxuICAgICAgdGV4dEVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGxlbmd0aDogZGlyZWN0VGV4dC5sZW5ndGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZXNzIGNoaWxkcmVuXHJcbiAgICBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2gocHJvY2Vzc0VsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RhcnQgcHJvY2Vzc2luZyBmcm9tIGJvZHlcclxuICBwcm9jZXNzRWxlbWVudChkb2MuYm9keSk7XHJcblxyXG4gIC8vIFNvcnQgYnkgdGV4dCBsZW5ndGggKGxhcmdlc3QgZmlyc3QpXHJcbiAgdGV4dEVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xyXG5cclxuICAvLyBUYWtlIHRoZSB0b3AgZWxlbWVudHMgdGhhdCBsaWtlbHkgY29udGFpbiBtYWluIGNvbnRlbnRcclxuICBjb25zdCBtYWluQ29udGVudEVsZW1lbnRzID0gdGV4dEVsZW1lbnRzLnNsaWNlKDAsIDEwKTtcclxuXHJcbiAgLy8gRXh0cmFjdCBhbmQgam9pbiB0aGVpciB0ZXh0XHJcbiAgcmV0dXJuIG1haW5Db250ZW50RWxlbWVudHNcclxuICAgIC5tYXAoaXRlbSA9PiBpdGVtLmVsZW1lbnQudGV4dENvbnRlbnQgfHwgJycpXHJcbiAgICAuam9pbignXFxuXFxuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzIGFuZCBjbGVhbiBleHRyYWN0ZWQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvY2Vzc0V4dHJhY3RlZFRleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHdoaXRlc3BhY2VcclxuICBsZXQgcHJvY2Vzc2VkID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJyk7XHJcblxyXG4gIC8vIFNwbGl0IGludG8gbGluZXMgYW5kIGNsZWFuIGVhY2ggbGluZVxyXG4gIHByb2Nlc3NlZCA9IHByb2Nlc3NlZFxyXG4gICAgLnNwbGl0KCdcXG4nKVxyXG4gICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKVxyXG4gICAgLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMClcclxuICAgIC5qb2luKCdcXG4nKTtcclxuXHJcbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBwYXJhZ3JhcGhzXHJcbiAgY29uc3QgcGFyYWdyYXBocyA9IHByb2Nlc3NlZC5zcGxpdCgnXFxuXFxuJyk7XHJcbiAgY29uc3QgdW5pcXVlUGFyYWdyYXBocyA9IEFycmF5LmZyb20obmV3IFNldChwYXJhZ3JhcGhzKSk7XHJcbiAgcHJvY2Vzc2VkID0gdW5pcXVlUGFyYWdyYXBocy5qb2luKCdcXG5cXG4nKTtcclxuXHJcbiAgLy8gTGltaXQgbGVuZ3RoIHRvIGF2b2lkIGV4dHJlbWVseSBsb25nIHRleHRzXHJcbiAgaWYgKHByb2Nlc3NlZC5sZW5ndGggPiA4MDAwKSB7XHJcbiAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQuc3Vic3RyaW5nKDAsIDgwMDApICsgJy4uLic7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHJvY2Vzc2VkO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydCBzb3VyY2VzIGJ5IHF1YWxpdHlcclxuICovXHJcbmZ1bmN0aW9uIHNvcnRTb3VyY2VzQnlRdWFsaXR5KHNvdXJjZXM6IFNvdXJjZVtdKTogU291cmNlW10ge1xyXG4gIHJldHVybiBbLi4uc291cmNlc10uc29ydCgoYSwgYikgPT4ge1xyXG4gICAgLy8gQ2FsY3VsYXRlIHF1YWxpdHkgc2NvcmUgYmFzZWQgb24gdGV4dCBsZW5ndGggYW5kIG90aGVyIGZhY3RvcnNcclxuICAgIGNvbnN0IHNjb3JlQSA9IGNhbGN1bGF0ZUNvbnRlbnRRdWFsaXR5U2NvcmUoYSk7XHJcbiAgICBjb25zdCBzY29yZUIgPSBjYWxjdWxhdGVDb250ZW50UXVhbGl0eVNjb3JlKGIpO1xyXG5cclxuICAgIHJldHVybiBzY29yZUIgLSBzY29yZUE7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgY29udGVudCBxdWFsaXR5IHNjb3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250ZW50UXVhbGl0eVNjb3JlKHNvdXJjZTogU291cmNlKTogbnVtYmVyIHtcclxuICBsZXQgc2NvcmUgPSAwO1xyXG5cclxuICAvLyBMZW5ndGggaXMgYSBwcmltYXJ5IGZhY3RvclxyXG4gIHNjb3JlICs9IE1hdGgubWluKHNvdXJjZS50ZXh0Lmxlbmd0aCAvIDEwMCwgNTApO1xyXG5cclxuICAvLyBQcmVmZXIgc291cmNlcyB3aXRoIHRpdGxlc1xyXG4gIHNjb3JlICs9IHNvdXJjZS50aXRsZSA/IDEwIDogMDtcclxuXHJcbiAgLy8gUHJlZmVyIHNvdXJjZXMgZnJvbSByZXB1dGFibGUgZG9tYWluc1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBob3N0bmFtZSA9IG5ldyBVUkwoc291cmNlLnVybCkuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChob3N0bmFtZS5pbmNsdWRlcygnLmVkdScpIHx8XHJcbiAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJy5nb3YnKSB8fFxyXG4gICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCd3aWtpcGVkaWEub3JnJykpIHtcclxuICAgICAgc2NvcmUgKz0gMjA7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBJbnZhbGlkIFVSTFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNjb3JlO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGZhbGxiYWNrIHNvdXJjZXMgd2hlbiBleHRyYWN0aW9uIGZhaWxzXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1NvdXJjZXMobGlua3M6IHN0cmluZ1tdKTogU291cmNlW10ge1xyXG4gIC8vIENyZWF0ZSBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgc291cmNlXHJcbiAgY29uc3QgZmFsbGJhY2tTb3VyY2VzOiBTb3VyY2VbXSA9IFtdO1xyXG5cclxuICAvLyBUcnkgdG8gY3JlYXRlIHNvdXJjZXMgZnJvbSB0aGUgdG9wIDMgbGlua3NcclxuICBjb25zdCB0b3BMaW5rcyA9IGxpbmtzLnNsaWNlKDAsIDMpO1xyXG5cclxuICBmb3IgKGNvbnN0IGxpbmsgb2YgdG9wTGlua3MpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRvbWFpbiA9IG5ldyBVUkwobGluaykuaG9zdG5hbWUucmVwbGFjZSgnd3d3LicsICcnKTtcclxuXHJcbiAgICAgIGZhbGxiYWNrU291cmNlcy5wdXNoKHtcclxuICAgICAgICB1cmw6IGxpbmssXHJcbiAgICAgICAgdGV4dDogYFRoaXMgaW5mb3JtYXRpb24gaXMgZnJvbSAke2RvbWFpbn0uIFRoZSBjb250ZW50IGNvdWxkIG5vdCBiZSBmdWxseSBleHRyYWN0ZWQgZHVlIHRvIHdlYnNpdGUgcmVzdHJpY3Rpb25zLiBQbGVhc2UgdmlzaXQgdGhlIHdlYnNpdGUgZGlyZWN0bHkgZm9yIGNvbXBsZXRlIGluZm9ybWF0aW9uLmAsXHJcbiAgICAgICAgdGl0bGU6IGBJbmZvcm1hdGlvbiBmcm9tICR7ZG9tYWlufWBcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHdlIGNvdWxkbid0IGNyZWF0ZSBhbnkgZmFsbGJhY2sgc291cmNlcywgY3JlYXRlIGEgZ2VuZXJpYyBvbmVcclxuICBpZiAoZmFsbGJhY2tTb3VyY2VzLmxlbmd0aCA9PT0gMCAmJiBsaW5rcy5sZW5ndGggPiAwKSB7XHJcbiAgICBmYWxsYmFja1NvdXJjZXMucHVzaCh7XHJcbiAgICAgIHVybDogbGlua3NbMF0sXHJcbiAgICAgIHRleHQ6IGBJbmZvcm1hdGlvbiBjb3VsZCBub3QgYmUgcmV0cmlldmVkIGZyb20gdGhlIHNvdXJjZXMuIFRoaXMgbWlnaHQgYmUgZHVlIHRvIHdlYnNpdGUgcmVzdHJpY3Rpb25zIG9yIHRlY2huaWNhbCBsaW1pdGF0aW9ucy4gVHJ5IHJlZmluaW5nIHlvdXIgc2VhcmNoIHF1ZXJ5IG9yIHZpc2l0aW5nIHRoZSB3ZWJzaXRlcyBkaXJlY3RseS5gLFxyXG4gICAgICB0aXRsZTogYFNlYXJjaCBSZXN1bHRzYFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsbGJhY2tTb3VyY2VzO1xyXG59XHJcblxyXG4vKipcclxuICogQWR2YW5jZWQgR29vZ2xlIHNlYXJjaCB3aXRoIG11bHRpcGxlIGV4dHJhY3Rpb24gdGVjaG5pcXVlcyBhbmQgZmFsbGJhY2tzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRHb29nbGVMaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIEdvb2dsZSBzZWFyY2ggcmVxdWVzdCBmb3I6IFwiJHtxdWVyeX1cImApO1xyXG5cclxuICAgIC8vIFRyeSBtdWx0aXBsZSBzZWFyY2ggdmFyaWF0aW9ucyB0byBpbXByb3ZlIHJlc3VsdHNcclxuICAgIGNvbnN0IHNlYXJjaFZhcmlhdGlvbnMgPSBbXHJcbiAgICAgIC8vIFN0YW5kYXJkIHNlYXJjaFxyXG4gICAgICBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9Jm51bT0zMGAsXHJcbiAgICAgIC8vIFNlYXJjaCB3aXRoIHZlcmJhdGltIG9wdGlvbiB0byBnZXQgZXhhY3QgbWF0Y2hlc1xyXG4gICAgICBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9Jm51bT0yMCZ0YnM9bGk6MWAsXHJcbiAgICAgIC8vIFNlYXJjaCB3aXRoIHJlY2VudCByZXN1bHRzXHJcbiAgICAgIGBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mbnVtPTIwJnRicz1xZHI6eWBcclxuICAgIF07XHJcblxyXG4gICAgbGV0IGFsbExpbmtzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIC8vIFRyeSBlYWNoIHNlYXJjaCB2YXJpYXRpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoVmFyaWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoYWxsTGlua3MubGVuZ3RoID49IDE1KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEFscmVhZHkgZm91bmQgJHthbGxMaW5rcy5sZW5ndGh9IGxpbmtzLCBza2lwcGluZyByZW1haW5pbmcgdmFyaWF0aW9uc2ApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IHNlYXJjaFZhcmlhdGlvbnNbaV07XHJcbiAgICAgICAgY29uc29sZS5sb2coYFRyeWluZyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OiAke3NlYXJjaFVybH1gKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgaGVhZGVycyB0byBtaW1pYyBhIHJlYWwgYnJvd3NlclxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChcclxuICAgICAgICAgIHNlYXJjaFVybCxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXHJcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCcsXHJcbiAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuNScsXHJcbiAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8nLFxyXG4gICAgICAgICAgICAgICdETlQnOiAnMScsXHJcbiAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXHJcbiAgICAgICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXHJcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZT0wJyxcclxuICAgICAgICAgICAgICAnc2VjLWNoLXVhJzogJ1wiR29vZ2xlIENocm9tZVwiO3Y9XCIxMDVcIiwgXCJOb3QpQTtCcmFuZFwiO3Y9XCI4XCIsIFwiQ2hyb21pdW1cIjt2PVwiMTA1XCInLFxyXG4gICAgICAgICAgICAgICdzZWMtY2gtdWEtbW9iaWxlJzogJz8wJyxcclxuICAgICAgICAgICAgICAnc2VjLWNoLXVhLXBsYXRmb3JtJzogJ1wiV2luZG93c1wiJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb29nbGUgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgYSB2YWxpZCByZXNwb25zZVxyXG4gICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDEwMDApIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gR29vZ2xlIHZhcmlhdGlvbiAke2kgKyAxfTogJHtodG1sLmxlbmd0aH0gY2hhcnNgKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoXCJ1bnVzdWFsIHRyYWZmaWNcIikgfHxcclxuICAgICAgICAgICAgaHRtbC5pbmNsdWRlcyhcIkNBUFRDSEFcIikgfHxcclxuICAgICAgICAgICAgaHRtbC5pbmNsdWRlcyhcImRldGVjdGVkIHVudXN1YWwgdHJhZmZpY1wiKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb29nbGUgdmFyaWF0aW9uICR7aSArIDF9IGJsb2NrZWQgb3IgcmV0dXJuZWQgYSBDQVBUQ0hBYCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgbGlua3MgdXNpbmcgbXVsdGlwbGUgbWV0aG9kc1xyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzID0gZXh0cmFjdEdvb2dsZUxpbmtzKGh0bWwpO1xyXG5cclxuICAgICAgICBpZiAoZXh0cmFjdGVkTGlua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIEdvb2dsZSB2YXJpYXRpb24gJHtpICsgMX1gKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbmV3IHVuaXF1ZSBsaW5rc1xyXG4gICAgICAgICAgZXh0cmFjdGVkTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgaWYgKCFhbGxMaW5rcy5pbmNsdWRlcyhsaW5rKSkge1xyXG4gICAgICAgICAgICAgIGFsbExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAodmFyaWF0aW9uRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aXRoIEdvb2dsZSBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OmAsIHZhcmlhdGlvbkVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbHRlciBhbmQgY2xlYW4gdGhlIGxpbmtzXHJcbiAgICBjb25zdCBmaWx0ZXJlZExpbmtzID0gZmlsdGVyQW5kQ2xlYW5MaW5rcyhhbGxMaW5rcyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZmlsdGVyZWRMaW5rcy5sZW5ndGh9IHVuaXF1ZSB2YWxpZCBsaW5rcyBmcm9tIEdvb2dsZWApO1xyXG4gICAgcmV0dXJuIGZpbHRlcmVkTGlua3M7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBHb29nbGUgbGlua3M6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGxpbmtzIGZyb20gR29vZ2xlIHNlYXJjaCByZXN1bHRzIEhUTUwgdXNpbmcgbXVsdGlwbGUgbWV0aG9kc1xyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEdvb2dsZUxpbmtzKGh0bWw6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xyXG4gIGxldCBsaW5rczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgLy8gTWV0aG9kIDE6IFN0YW5kYXJkIEdvb2dsZSBzZWFyY2ggcmVzdWx0cyAtIGxvb2sgZm9yIHJlZGlyZWN0c1xyXG4gICQoXCJhXCIpLmVhY2goKF8sIGxpbmspID0+IHtcclxuICAgIGNvbnN0IGhyZWYgPSAkKGxpbmspLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgaWYgKGhyZWYgJiYgaHJlZi5zdGFydHNXaXRoKFwiL3VybD9xPVwiKSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNsZWFuZWRIcmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KGhyZWYucmVwbGFjZShcIi91cmw/cT1cIiwgXCJcIikuc3BsaXQoXCImXCIpWzBdKTtcclxuICAgICAgICBpZiAoaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xyXG4gICAgICAgICAgbGlua3MucHVzaChjbGVhbmVkSHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBNZXRob2QgMjogTG9vayBmb3IgcmVzdWx0IGNvbnRhaW5lcnMgYW5kIGV4dHJhY3QgbGlua3NcclxuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xyXG4gICAgY29uc29sZS5sb2coXCJVc2luZyBHb29nbGUgZXh0cmFjdGlvbiBtZXRob2QgMlwiKTtcclxuXHJcbiAgICAvLyBNb2Rlcm4gR29vZ2xlIHNlbGVjdG9yc1xyXG4gICAgJChcIi5nIC55dVJVYmYgPiBhLCAuZyAucmMgPiBhLCAuZyBoMy5yID4gYSwgLnRGMkN4YyA+IGRpdi55dVJVYmYgPiBhLCAuaGxjdzBjIC55dVJVYmYgPiBhXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcclxuICAgICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XHJcbiAgICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XHJcbiAgICAgICAgbGlua3MucHVzaChocmVmKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBNZXRob2QgMzogRXh0cmFjdCBmcm9tIGNpdGUgZWxlbWVudHNcclxuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xyXG4gICAgY29uc29sZS5sb2coXCJVc2luZyBHb29nbGUgZXh0cmFjdGlvbiBtZXRob2QgM1wiKTtcclxuXHJcbiAgICAkKFwiLmlVaDMwLCAudGp2Y3gsIC5xekVvVWVcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xyXG4gICAgICBjb25zdCBwYXJlbnRMaW5rID0gJChlbGVtZW50KS5jbG9zZXN0KFwiYVwiKS5hdHRyKFwiaHJlZlwiKTtcclxuICAgICAgaWYgKHBhcmVudExpbmsgJiYgcGFyZW50TGluay5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMocGFyZW50TGluaykpIHtcclxuICAgICAgICBsaW5rcy5wdXNoKHBhcmVudExpbmspO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgVVJMIGZyb20gY2l0ZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgY2l0ZVRleHQgPSAkKGVsZW1lbnQpLnRleHQoKS50cmltKCk7XHJcbiAgICAgICAgaWYgKGNpdGVUZXh0ICYmICFjaXRlVGV4dC5pbmNsdWRlcyhcIi4uLlwiKSAmJiBjaXRlVGV4dC5pbmNsdWRlcyhcIi5cIikpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCB1cmwgPSBjaXRlVGV4dDtcclxuICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcclxuICAgICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vXCIgKyB1cmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVmFsaWRVcmwodXJsKSAmJiAhbGlua3MuaW5jbHVkZXModXJsKSkge1xyXG4gICAgICAgICAgICAgIGxpbmtzLnB1c2godXJsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBNZXRob2QgNDogTGFzdCByZXNvcnQgLSBmaW5kIGFueSBleHRlcm5hbCBsaW5rc1xyXG4gIGlmIChsaW5rcy5sZW5ndGggPCAzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlVzaW5nIEdvb2dsZSBleHRyYWN0aW9uIG1ldGhvZCA0IChsYXN0IHJlc29ydClcIik7XHJcblxyXG4gICAgJChcImFbaHJlZl49J2h0dHAnXVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgICBpZiAoaHJlZiAmJlxyXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJnb29nbGUuY29tXCIpICYmXHJcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcImFjY291bnRzLlwiKSAmJlxyXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJzdXBwb3J0LlwiKSAmJlxyXG4gICAgICAgICAgaXNWYWxpZFVybChocmVmKSAmJlxyXG4gICAgICAgICAgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XHJcbiAgICAgICAgbGlua3MucHVzaChocmVmKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGlua3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgYW5kIGNsZWFuIGEgbGlzdCBvZiBVUkxzXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJBbmRDbGVhbkxpbmtzKGxpbmtzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gIGxldCB1bmlxdWVMaW5rcyA9IEFycmF5LmZyb20obmV3IFNldChsaW5rcykpO1xyXG5cclxuICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgYW5kIHVud2FudGVkIFVSTHNcclxuICB1bmlxdWVMaW5rcyA9IHVuaXF1ZUxpbmtzLmZpbHRlcihsaW5rID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XHJcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gdXJsLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAvLyBGaWx0ZXIgb3V0IGNvbW1vbiBub24tY29udGVudCBkb21haW5zXHJcbiAgICAgIGNvbnN0IGludmFsaWREb21haW5zID0gW1xyXG4gICAgICAgICdnb29nbGUuY29tJywgJ3lvdXR1YmUuY29tJywgJ2ZhY2Vib29rLmNvbScsICd0d2l0dGVyLmNvbScsICdpbnN0YWdyYW0uY29tJyxcclxuICAgICAgICAnbGlua2VkaW4uY29tJywgJ3BpbnRlcmVzdC5jb20nLCAnYW1hem9uLmNvbScsICdlYmF5LmNvbScsICduZXRmbGl4LmNvbScsXHJcbiAgICAgICAgJ2FwcGxlLmNvbScsICdtaWNyb3NvZnQuY29tJywgJ3BsYXkuZ29vZ2xlLmNvbScsICdhY2NvdW50cy5nb29nbGUuY29tJyxcclxuICAgICAgICAnc3VwcG9ydC5nb29nbGUuY29tJywgJ21hcHMuZ29vZ2xlLmNvbScsICdwb2xpY2llcy5nb29nbGUuY29tJyxcclxuICAgICAgICAndHJhbnNsYXRlLmdvb2dsZS5jb20nLCAnY2hyb21lLmdvb2dsZS5jb20nLCAnZG9jcy5nb29nbGUuY29tJyxcclxuICAgICAgICAnZHJpdmUuZ29vZ2xlLmNvbScsICdtYWlsLmdvb2dsZS5jb20nLCAnY2FsZW5kYXIuZ29vZ2xlLmNvbSdcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGlmIChpbnZhbGlkRG9tYWlucy5zb21lKGRvbWFpbiA9PiBob3N0bmFtZS5pbmNsdWRlcyhkb21haW4pKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmlsdGVyIG91dCBVUkxzIHdpdGggY2VydGFpbiBwYXR0ZXJuc1xyXG4gICAgICBjb25zdCBpbnZhbGlkUGF0dGVybnMgPSBbXHJcbiAgICAgICAgJy9zZWFyY2g/JywgJy9sb2dpbicsICcvc2lnbmluJywgJy9zaWdudXAnLCAnL3JlZ2lzdGVyJyxcclxuICAgICAgICAnL2FjY291bnQnLCAnL2NhcnQnLCAnL2NoZWNrb3V0JywgJy9wcml2YWN5JywgJy90ZXJtcycsXHJcbiAgICAgICAgJy9jb250YWN0JywgJy9hYm91dCcsICcvaGVscCcsICcvc3VwcG9ydCcsICcvZmFxJyxcclxuICAgICAgICAnL2Rvd25sb2FkJywgJy9zdWJzY3JpYmUnLCAnL21lbWJlcnNoaXAnLCAnL3ByaWNpbmcnXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBpZiAoaW52YWxpZFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiB1cmwucGF0aG5hbWUuaW5jbHVkZXMocGF0dGVybikpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIExpbWl0IHRvIGEgcmVhc29uYWJsZSBudW1iZXJcclxuICByZXR1cm4gdW5pcXVlTGlua3Muc2xpY2UoMCwgMjApO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBVUkwgYW5kIG1lZXRzIGNvbnRlbnQgY3JpdGVyaWFcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgbmV3IFVSTCh1cmwpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5oYW5jZWQgQmluZyBzZWFyY2ggd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEJpbmdMaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIEJpbmcgc2VhcmNoIHJlcXVlc3QgZm9yOiBcIiR7cXVlcnl9XCJgKTtcclxuXHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgc2VhcmNoIHZhcmlhdGlvbnNcclxuICAgIGNvbnN0IHNlYXJjaFZhcmlhdGlvbnMgPSBbXHJcbiAgICAgIC8vIFN0YW5kYXJkIHNlYXJjaFxyXG4gICAgICBgaHR0cHM6Ly93d3cuYmluZy5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZjb3VudD0zMGAsXHJcbiAgICAgIC8vIFNlYXJjaCB3aXRoIG5ld3NcclxuICAgICAgYGh0dHBzOi8vd3d3LmJpbmcuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mZmlsdGVycz1uZXdzYCxcclxuICAgICAgLy8gU2VhcmNoIHdpdGggZnJlc2huZXNzIGZpbHRlclxyXG4gICAgICBgaHR0cHM6Ly93d3cuYmluZy5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZmaWx0ZXJzPWV4MSUzYVwiZXo1XCJgXHJcbiAgICBdO1xyXG5cclxuICAgIGxldCBhbGxMaW5rczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAvLyBUcnkgZWFjaCBzZWFyY2ggdmFyaWF0aW9uXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaFZhcmlhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGFsbExpbmtzLmxlbmd0aCA+PSAxNSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBBbHJlYWR5IGZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIEJpbmcsIHNraXBwaW5nIHJlbWFpbmluZyB2YXJpYXRpb25zYCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoVXJsID0gc2VhcmNoVmFyaWF0aW9uc1tpXTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgVHJ5aW5nIEJpbmcgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTogJHtzZWFyY2hVcmx9YCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBoZWFkZXJzIHRvIG1pbWljIGEgcmVhbCBicm93c2VyXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxyXG4gICAgICAgICAgc2VhcmNoVXJsLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcclxuICAgICAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsKi8qO3E9MC44JyxcclxuICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC41JyxcclxuICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5iaW5nLmNvbS8nLFxyXG4gICAgICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxyXG4gICAgICAgICAgICAgICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJzogJzEnLFxyXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ21heC1hZ2U9MCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgQmluZyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCBhIHZhbGlkIHJlc3BvbnNlXHJcbiAgICAgICAgaWYgKGh0bWwubGVuZ3RoIDwgMTAwMCkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBUb28gc21hbGwgcmVzcG9uc2UgZnJvbSBCaW5nIHZhcmlhdGlvbiAke2kgKyAxfTogJHtodG1sLmxlbmd0aH0gY2hhcnNgKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyB1c2luZyBtdWx0aXBsZSBtZXRob2RzXHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3MgPSBleHRyYWN0QmluZ0xpbmtzKGh0bWwpO1xyXG5cclxuICAgICAgICBpZiAoZXh0cmFjdGVkTGlua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIEJpbmcgdmFyaWF0aW9uICR7aSArIDF9YCk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIG5ldyB1bmlxdWUgbGlua3NcclxuICAgICAgICAgIGV4dHJhY3RlZExpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGlmICghYWxsTGlua3MuaW5jbHVkZXMobGluaykpIHtcclxuICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHZhcmlhdGlvbkVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2l0aCBCaW5nIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX06YCwgdmFyaWF0aW9uRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIGFuZCBjbGVhbiB0aGUgbGlua3NcclxuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmRDbGVhbkxpbmtzKGFsbExpbmtzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZExpbmtzLmxlbmd0aH0gdW5pcXVlIHZhbGlkIGxpbmtzIGZyb20gQmluZ2ApO1xyXG4gICAgcmV0dXJuIGZpbHRlcmVkTGlua3M7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBCaW5nIGxpbmtzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBsaW5rcyBmcm9tIEJpbmcgc2VhcmNoIHJlc3VsdHMgSFRNTFxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEJpbmdMaW5rcyhodG1sOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgY29uc3QgJCA9IGNoZWVyaW8ubG9hZChodG1sKTtcclxuICBsZXQgbGlua3M6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIC8vIE1ldGhvZCAxOiBFeHRyYWN0IGZyb20gbWFpbiBzZWFyY2ggcmVzdWx0c1xyXG4gICQoXCIuYl9hbGdvIGgyIGFcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xyXG4gICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XHJcbiAgICBpZiAoaHJlZiAmJiBocmVmLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmICFsaW5rcy5pbmNsdWRlcyhocmVmKSkge1xyXG4gICAgICBsaW5rcy5wdXNoKGhyZWYpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBNZXRob2QgMjogRXh0cmFjdCBmcm9tIGNpdGUgZWxlbWVudHNcclxuICAkKFwiLmJfY2FwdGlvbiBjaXRlXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IHBhcmVudExpbmsgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoXCIuYl9hbGdvXCIpLmZpbmQoXCJoMiBhXCIpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgaWYgKHBhcmVudExpbmsgJiYgcGFyZW50TGluay5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMocGFyZW50TGluaykpIHtcclxuICAgICAgbGlua3MucHVzaChwYXJlbnRMaW5rKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gTWV0aG9kIDM6IEV4dHJhY3QgZnJvbSBkZWVwIGxpbmtzXHJcbiAgJChcIi5iX2RlZXBsaW5rcyBhXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgaWYgKGhyZWYgJiYgaHJlZi5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMoaHJlZikpIHtcclxuICAgICAgbGlua3MucHVzaChocmVmKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gTWV0aG9kIDQ6IExhc3QgcmVzb3J0IC0gZmluZCBhbnkgZXh0ZXJuYWwgbGlua3NcclxuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xyXG4gICAgJChcImFbaHJlZl49J2h0dHAnXVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgICBpZiAoaHJlZiAmJlxyXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJiaW5nLmNvbVwiKSAmJlxyXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJtaWNyb3NvZnQuY29tXCIpICYmXHJcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcIm1zbi5jb21cIikgJiZcclxuICAgICAgICAgIGlzVmFsaWRVcmwoaHJlZikgJiZcclxuICAgICAgICAgICFsaW5rcy5pbmNsdWRlcyhocmVmKSkge1xyXG4gICAgICAgIGxpbmtzLnB1c2goaHJlZik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxpbmtzO1xyXG59XHJcblxyXG4vKipcclxuICogRW5oYW5jZWQgRHVja0R1Y2tHbyBzZWFyY2ggd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldER1Y2tEdWNrR29MaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIER1Y2tEdWNrR28gc2VhcmNoIHJlcXVlc3QgZm9yOiBcIiR7cXVlcnl9XCJgKTtcclxuXHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgc2VhcmNoIHZhcmlhdGlvbnNcclxuICAgIGNvbnN0IHNlYXJjaFZhcmlhdGlvbnMgPSBbXHJcbiAgICAgIC8vIFN0YW5kYXJkIEhUTUwgc2VhcmNoXHJcbiAgICAgIGBodHRwczovL2h0bWwuZHVja2R1Y2tnby5jb20vaHRtbC8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCxcclxuICAgICAgLy8gV2l0aCByZWdpb24gc2V0IHRvIFVTXHJcbiAgICAgIGBodHRwczovL2h0bWwuZHVja2R1Y2tnby5jb20vaHRtbC8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmtsPXVzLWVuYCxcclxuICAgICAgLy8gV2l0aCB0aW1lIGZpbHRlciBmb3IgcmVjZW50IHJlc3VsdHNcclxuICAgICAgYGh0dHBzOi8vaHRtbC5kdWNrZHVja2dvLmNvbS9odG1sLz9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mZGY9eWBcclxuICAgIF07XHJcblxyXG4gICAgbGV0IGFsbExpbmtzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIC8vIFRyeSBlYWNoIHNlYXJjaCB2YXJpYXRpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoVmFyaWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoYWxsTGlua3MubGVuZ3RoID49IDE1KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEFscmVhZHkgZm91bmQgJHthbGxMaW5rcy5sZW5ndGh9IGxpbmtzIGZyb20gRHVja0R1Y2tHbywgc2tpcHBpbmcgcmVtYWluaW5nIHZhcmlhdGlvbnNgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzZWFyY2hVcmwgPSBzZWFyY2hWYXJpYXRpb25zW2ldO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBUcnlpbmcgRHVja0R1Y2tHbyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OiAke3NlYXJjaFVybH1gKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGhlYWRlcnMgdG8gbWltaWMgYSByZWFsIGJyb3dzZXJcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXHJcbiAgICAgICAgICBzZWFyY2hVcmwsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGdldFJhbmRvbVVzZXJBZ2VudCgpLFxyXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxyXG4gICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjUnLFxyXG4gICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vZHVja2R1Y2tnby5jb20vJyxcclxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcclxuICAgICAgICAgICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcclxuICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICdtYXgtYWdlPTAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYER1Y2tEdWNrR28gc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgYSB2YWxpZCByZXNwb25zZVxyXG4gICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDEwMDApIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gRHVja0R1Y2tHbyB2YXJpYXRpb24gJHtpICsgMX06ICR7aHRtbC5sZW5ndGh9IGNoYXJzYCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgbGlua3MgdXNpbmcgb3VyIGN1c3RvbSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzID0gZXh0cmFjdER1Y2tEdWNrR29MaW5rcyhodG1sKTtcclxuXHJcbiAgICAgICAgaWYgKGV4dHJhY3RlZExpbmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2V4dHJhY3RlZExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBEdWNrRHVja0dvIHZhcmlhdGlvbiAke2kgKyAxfWApO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBuZXcgdW5pcXVlIGxpbmtzXHJcbiAgICAgICAgICBleHRyYWN0ZWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWFsbExpbmtzLmluY2x1ZGVzKGxpbmspKSB7XHJcbiAgICAgICAgICAgICAgYWxsTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoICh2YXJpYXRpb25FcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdpdGggRHVja0R1Y2tHbyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OmAsIHZhcmlhdGlvbkVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIEhUTUwgc2VhcmNoIGZhaWxlZCwgdHJ5IHRoZSBsaXRlIHZlcnNpb24gYXMgZmFsbGJhY2tcclxuICAgIGlmIChhbGxMaW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlRyeWluZyBEdWNrRHVja0dvIExpdGUgYXMgZmFsbGJhY2tcIik7XHJcbiAgICAgICAgY29uc3QgbGl0ZVVybCA9IGBodHRwczovL2xpdGUuZHVja2R1Y2tnby5jb20vbGl0ZS8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YDtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxyXG4gICAgICAgICAgbGl0ZVVybCxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXHJcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XHJcblxyXG4gICAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyBmcm9tIHRoZSBsaXRlIHZlcnNpb25cclxuICAgICAgICAgICQoXCJhW2hyZWZePSdodHRwJ11cIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBocmVmID0gJChlbGVtZW50KS5hdHRyKFwiaHJlZlwiKTtcclxuICAgICAgICAgICAgaWYgKGhyZWYgJiZcclxuICAgICAgICAgICAgICAgICFocmVmLmluY2x1ZGVzKFwiZHVja2R1Y2tnby5jb21cIikgJiZcclxuICAgICAgICAgICAgICAgIGlzVmFsaWRVcmwoaHJlZikgJiZcclxuICAgICAgICAgICAgICAgICFhbGxMaW5rcy5pbmNsdWRlcyhocmVmKSkge1xyXG4gICAgICAgICAgICAgIGFsbExpbmtzLnB1c2goaHJlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBEdWNrRHVja0dvIExpdGUgZmFsbGJhY2tgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGxpdGVFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aXRoIER1Y2tEdWNrR28gTGl0ZSBmYWxsYmFjazpcIiwgbGl0ZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbHRlciBhbmQgY2xlYW4gdGhlIGxpbmtzXHJcbiAgICBjb25zdCBmaWx0ZXJlZExpbmtzID0gZmlsdGVyQW5kQ2xlYW5MaW5rcyhhbGxMaW5rcyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZmlsdGVyZWRMaW5rcy5sZW5ndGh9IHVuaXF1ZSB2YWxpZCBsaW5rcyBmcm9tIER1Y2tEdWNrR29gKTtcclxuICAgIHJldHVybiBmaWx0ZXJlZExpbmtzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgRHVja0R1Y2tHbyBsaW5rczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgbGlua3MgZnJvbSBEdWNrRHVja0dvIHNlYXJjaCByZXN1bHRzIEhUTUxcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3REdWNrRHVja0dvTGlua3MoaHRtbDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XHJcbiAgbGV0IGxpbmtzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAvLyBNZXRob2QgMTogRXh0cmFjdCBmcm9tIG1haW4gcmVzdWx0IGxpbmtzXHJcbiAgJChcIi5yZXN1bHRfX2FcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xyXG4gICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XHJcbiAgICBpZiAoaHJlZikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIER1Y2tEdWNrR28gdXNlcyByZWxhdGl2ZSBVUkxzIHdpdGggcGFyYW1ldGVyc1xyXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZiwgXCJodHRwczovL2R1Y2tkdWNrZ28uY29tXCIpO1xyXG4gICAgICAgIGNvbnN0IGNsZWFuZWRIcmVmID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ1ZGRnXCIpO1xyXG5cclxuICAgICAgICBpZiAoY2xlYW5lZEhyZWYgJiYgaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xyXG4gICAgICAgICAgbGlua3MucHVzaChjbGVhbmVkSHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBNZXRob2QgMjogRXh0cmFjdCBmcm9tIHJlc3VsdCBzbmlwcGV0c1xyXG4gICQoXCIucmVzdWx0X19zbmlwcGV0XCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IHBhcmVudExpbmsgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoXCIucmVzdWx0XCIpLmZpbmQoXCIucmVzdWx0X19hXCIpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgaWYgKHBhcmVudExpbmspIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcmVudExpbmssIFwiaHR0cHM6Ly9kdWNrZHVja2dvLmNvbVwiKTtcclxuICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidWRkZ1wiKTtcclxuXHJcbiAgICAgICAgaWYgKGNsZWFuZWRIcmVmICYmIGlzVmFsaWRVcmwoY2xlYW5lZEhyZWYpICYmICFsaW5rcy5pbmNsdWRlcyhjbGVhbmVkSHJlZikpIHtcclxuICAgICAgICAgIGxpbmtzLnB1c2goY2xlYW5lZEhyZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFNraXAgaW52YWxpZCBVUkxzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gTWV0aG9kIDM6IExhc3QgcmVzb3J0IC0gZmluZCBhbnkgZXh0ZXJuYWwgbGlua3NcclxuICBpZiAobGlua3MubGVuZ3RoIDwgMykge1xyXG4gICAgJChcImFbaHJlZl49Jy8nXVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgICBpZiAoaHJlZiAmJiBocmVmLmluY2x1ZGVzKFwidWRkZz1cIikpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmLCBcImh0dHBzOi8vZHVja2R1Y2tnby5jb21cIik7XHJcbiAgICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidWRkZ1wiKTtcclxuXHJcbiAgICAgICAgICBpZiAoY2xlYW5lZEhyZWYgJiYgaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xyXG4gICAgICAgICAgICBsaW5rcy5wdXNoKGNsZWFuZWRIcmVmKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGlua3M7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNlYXJjaEhhbmRsZXI7XHJcbiJdLCJuYW1lcyI6WyJSZWFkYWJpbGl0eSIsImNoZWVyaW8iLCJKU0RPTSIsIkZFVENIX1RJTUVPVVQiLCJVU0VSX0FHRU5UUyIsImdldFJhbmRvbVVzZXJBZ2VudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsIk1BWF9SRVRSSUVTIiwiUkVUUllfREVMQVkiLCJERUZBVUxUX1NPVVJDRV9DT1VOVCIsIkVYQ0xVREVEX0RPTUFJTlMiLCJmZXRjaFdpdGhUaW1lb3V0IiwidXJsIiwib3B0aW9ucyIsInRpbWVvdXQiLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRNcyIsImlkIiwic2V0VGltZW91dCIsImFib3J0IiwiaGVhZGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwicG93IiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJzaWduYWwiLCJyZWRpcmVjdCIsImNsZWFyVGltZW91dCIsIm9rIiwic3RhdHVzIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiZXJyb3IiLCJuYW1lIiwibWVzc2FnZSIsImluY2x1ZGVzIiwic2VhcmNoSGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsImpzb24iLCJzb3VyY2VzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInF1ZXJ5Iiwic2VhcmNoRW5naW5lIiwic291cmNlQ291bnQiLCJib2R5IiwibGltaXRlZFNvdXJjZUNvdW50IiwibWluIiwibWF4IiwiYWxsTGlua3MiLCJ1c2VkRW5naW5lcyIsImdvb2dsZUxpbmtzIiwiYmluZ0xpbmtzIiwiZHVja2R1Y2tnb0xpbmtzIiwiYWxsIiwiZ2V0R29vZ2xlTGlua3MiLCJjYXRjaCIsImVyciIsImdldEJpbmdMaW5rcyIsImdldER1Y2tEdWNrR29MaW5rcyIsInB1c2giLCJmYWxsYmFja0Vycm9yIiwiZmlsdGVyZWRMaW5rcyIsImZpbHRlckFuZERlZHVwbGljYXRlTGlua3MiLCJmaW5hbExpbmtzIiwic2xpY2UiLCJtZXRhZGF0YSIsImVuZ2luZSIsImpvaW4iLCJ0b3RhbFJlc3VsdHMiLCJzZWFyY2hUaW1lIiwiZmlsdGVyZWRTb3VyY2VzIiwic2NyYXBlU291cmNlc1dpdGhUaW1lb3V0IiwicHJvY2Vzc2VkU291cmNlcyIsInByb2Nlc3NTb3VyY2VzIiwiZmFsbGJhY2tTb3VyY2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0aXRsZSIsInRleHQiLCJmYWxsYmFjayIsImxpbmtzIiwidmFsaWRMaW5rcyIsImZpbHRlciIsImxpbmsiLCJVUkwiLCJkb21haW4iLCJob3N0bmFtZSIsInNvbWUiLCJleGNsdWRlZCIsInVuaXF1ZURvbWFpbnMiLCJTZXQiLCJoYXMiLCJhZGQiLCJzb3VyY2UiLCJ1bmRlZmluZWQiLCJtYXAiLCJleHRyYWN0VGl0bGUiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJwYXRoU2VnbWVudCIsInNwbGl0IiwiQm9vbGVhbiIsInBvcCIsImNsZWFuUGF0aFNlZ21lbnQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIk1BWF9DT05DVVJSRU5UIiwicmVzdWx0cyIsInByaW9yaXRpemVkTGlua3MiLCJwcmlvcml0aXplTGlua3MiLCJwZW5kaW5nTGlua3MiLCJiYXRjaCIsInNwbGljZSIsImJhdGNoUmVzdWx0cyIsInRlY2huaXF1ZSIsInRlY2huaXF1ZVRpbWVvdXQiLCJmZXRjaE9wdGlvbnMiLCJ3YXJuIiwiY29udGVudFR5cGUiLCJnZXQiLCJodG1sIiwiZXh0cmFjdGVkQ29udGVudCIsImV4dHJhY3RXaXRoUmVhZGFiaWxpdHkiLCJleHRyYWN0V2l0aEN1c3RvbVNlbGVjdG9ycyIsImV4dHJhY3RXaXRoU2ltcGxpZmllZE1ldGhvZCIsInByb2Nlc3NlZFRleHQiLCJwcm9jZXNzRXh0cmFjdGVkVGV4dCIsInRlY2huaXF1ZUVycm9yIiwidmFsaWRSZXN1bHRzIiwidmFsaWRTb3VyY2VzIiwic29ydGVkU291cmNlcyIsInNvcnRTb3VyY2VzQnlRdWFsaXR5IiwiY3JlYXRlRmFsbGJhY2tTb3VyY2VzIiwic2NvcmVkTGlua3MiLCJzY29yZSIsInRvTG93ZXJDYXNlIiwic2VhcmNoIiwic29ydCIsImEiLCJiIiwiaXRlbSIsImRvbSIsInJ1blNjcmlwdHMiLCJwcmV0ZW5kVG9CZVZpc3VhbCIsInJlYWRlciIsIndpbmRvdyIsImRvY3VtZW50IiwiYXJ0aWNsZSIsInBhcnNlIiwidGV4dENvbnRlbnQiLCJkb2MiLCJzZWxlY3RvcnMiLCJzZWxlY3RvciIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImNvbWJpbmVkVGV4dCIsImZvckVhY2giLCJlbCIsInRleHRCbG9ja3MiLCJmaW5kTGFyZ2VzdFRleHRCbG9ja3MiLCIkIiwibG9hZCIsInJlbW92ZSIsInBhcmFncmFwaHMiLCJlYWNoIiwiXyIsInRyaW0iLCJib2R5VGV4dCIsImNsZWFuZWRUZXh0IiwibGluZSIsInRleHRFbGVtZW50cyIsInByb2Nlc3NFbGVtZW50IiwiZWxlbWVudCIsInRhZ05hbWUiLCJkaXJlY3RUZXh0IiwiQXJyYXkiLCJmcm9tIiwiY2hpbGROb2RlcyIsIm5vZGUiLCJub2RlVHlwZSIsImNoaWxkcmVuIiwibWFpbkNvbnRlbnRFbGVtZW50cyIsInByb2Nlc3NlZCIsInVuaXF1ZVBhcmFncmFwaHMiLCJzdWJzdHJpbmciLCJzY29yZUEiLCJjYWxjdWxhdGVDb250ZW50UXVhbGl0eVNjb3JlIiwic2NvcmVCIiwiZmFsbGJhY2tTb3VyY2VzIiwidG9wTGlua3MiLCJzZWFyY2hWYXJpYXRpb25zIiwiaSIsInNlYXJjaFVybCIsImV4dHJhY3RlZExpbmtzIiwiZXh0cmFjdEdvb2dsZUxpbmtzIiwidmFyaWF0aW9uRXJyb3IiLCJmaWx0ZXJBbmRDbGVhbkxpbmtzIiwiaHJlZiIsImF0dHIiLCJzdGFydHNXaXRoIiwiY2xlYW5lZEhyZWYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpc1ZhbGlkVXJsIiwiZSIsInBhcmVudExpbmsiLCJjbG9zZXN0IiwiY2l0ZVRleHQiLCJ1bmlxdWVMaW5rcyIsImludmFsaWREb21haW5zIiwiaW52YWxpZFBhdHRlcm5zIiwicGF0dGVybiIsImV4dHJhY3RCaW5nTGlua3MiLCJmaW5kIiwiZXh0cmFjdER1Y2tEdWNrR29MaW5rcyIsImxpdGVVcmwiLCJsaXRlRXJyb3IiLCJzZWFyY2hQYXJhbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/sources.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/sources.ts"));
module.exports = __webpack_exports__;

})();