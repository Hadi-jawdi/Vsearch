"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/sources";
exports.ids = ["pages/api/sources"];
exports.modules = {

/***/ "@mozilla/readability":
/*!***************************************!*\
  !*** external "@mozilla/readability" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("@mozilla/readability");

/***/ }),

/***/ "jsdom":
/*!************************!*\
  !*** external "jsdom" ***!
  \************************/
/***/ ((module) => {

module.exports = require("jsdom");

/***/ }),

/***/ "cheerio":
/*!**************************!*\
  !*** external "cheerio" ***!
  \**************************/
/***/ ((module) => {

module.exports = import("cheerio");;

/***/ }),

/***/ "(api)/./pages/api/sources.ts":
/*!******************************!*\
  !*** ./pages/api/sources.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mozilla/readability */ \"@mozilla/readability\");\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mozilla_readability__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheerio */ \"cheerio\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsdom */ \"jsdom\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsdom__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([cheerio__WEBPACK_IMPORTED_MODULE_1__]);\ncheerio__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Timeout for fetch requests (15 seconds)\nconst FETCH_TIMEOUT = 15000;\n// User agent rotation for requests\nconst USER_AGENTS = [\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36\",\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0\",\n    \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/96.0.4664.53 Mobile/15E148 Safari/604.1\"\n];\n// Get a random user agent\nconst getRandomUserAgent = ()=>USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];\n// Maximum number of retries for fetch requests\nconst MAX_RETRIES = 3;\n// Delay between retries (in ms)\nconst RETRY_DELAY = 1000;\n// Number of sources to return\nconst DEFAULT_SOURCE_COUNT = 4;\n// List of domains to exclude from results\nconst EXCLUDED_DOMAINS = [\n    \"google\",\n    \"facebook\",\n    \"twitter\",\n    \"instagram\",\n    \"youtube\",\n    \"tiktok\",\n    \"bing\",\n    \"duckduckgo\",\n    \"pinterest\",\n    \"linkedin\",\n    \"reddit\",\n    \"quora\"\n];\n/**\n * Enhanced fetch with timeout, retries, and exponential backoff\n */ async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT) {\n    let lastError = null;\n    // Try multiple times with exponential backoff\n    for(let attempt = 0; attempt < MAX_RETRIES; attempt++){\n        const controller = new AbortController();\n        const timeoutMs = timeout * (attempt + 1); // Increase timeout with each retry\n        const id = setTimeout(()=>controller.abort(), timeoutMs);\n        // Add default headers including a random user agent\n        const headers = {\n            \"User-Agent\": getRandomUserAgent(),\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"Cache-Control\": \"no-cache\",\n            \"Pragma\": \"no-cache\",\n            ...options.headers\n        };\n        try {\n            // Add a small delay between retries with exponential backoff\n            if (attempt > 0) {\n                await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * Math.pow(2, attempt - 1)));\n                console.log(`Retry attempt ${attempt + 1} for ${url}`);\n            }\n            const response = await fetch(url, {\n                ...options,\n                headers,\n                signal: controller.signal,\n                redirect: \"follow\"\n            });\n            clearTimeout(id);\n            // Check if we got a successful response\n            if (response.ok) {\n                return response;\n            } else {\n                // For certain status codes, we might want to retry\n                if (response.status === 429 || response.status >= 500) {\n                    lastError = new Error(`HTTP error ${response.status}: ${response.statusText}`);\n                    continue; // Retry\n                }\n                return response; // Return the response even if it's not ok\n            }\n        } catch (error) {\n            clearTimeout(id);\n            lastError = error;\n            // Don't retry if it's a CORS error or if the request was aborted\n            if (error.name === \"AbortError\" || error.message.includes(\"CORS\")) {\n                throw error;\n            }\n        // Continue to next retry attempt\n        }\n    }\n    // If we've exhausted all retries, throw the last error\n    throw lastError || new Error(`Failed to fetch ${url} after ${MAX_RETRIES} attempts`);\n}\n/**\n * Main handler for the sources API\n */ const searchHandler = async (req, res)=>{\n    // Only allow POST requests\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            sources: [],\n            error: \"Method not allowed\"\n        });\n    }\n    const startTime = Date.now();\n    try {\n        const { query , searchEngine =\"google\" , sourceCount =DEFAULT_SOURCE_COUNT  } = req.body;\n        // Validate input\n        if (!query || typeof query !== \"string\") {\n            return res.status(400).json({\n                sources: [],\n                error: \"Invalid query provided\"\n            });\n        }\n        // Limit source count to reasonable values\n        const limitedSourceCount = Math.min(Math.max(1, sourceCount), 8);\n        let allLinks = [];\n        let usedEngines = [];\n        // Get links from selected search engine(s)\n        if (searchEngine === \"all\") {\n            // Fetch from all search engines in parallel\n            console.log(`Fetching from all search engines for query: \"${query}\"`);\n            const [googleLinks, bingLinks, duckduckgoLinks] = await Promise.all([\n                getGoogleLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Google links:\", err);\n                    return [];\n                }),\n                getBingLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Bing links:\", err);\n                    return [];\n                }),\n                getDuckDuckGoLinks(query).catch((err)=>{\n                    console.error(\"Error fetching DuckDuckGo links:\", err);\n                    return [];\n                })\n            ]);\n            console.log(`Found links - Google: ${googleLinks.length}, Bing: ${bingLinks.length}, DuckDuckGo: ${duckduckgoLinks.length}`);\n            if (googleLinks.length > 0) usedEngines.push(\"google\");\n            if (bingLinks.length > 0) usedEngines.push(\"bing\");\n            if (duckduckgoLinks.length > 0) usedEngines.push(\"duckduckgo\");\n            allLinks = [\n                ...googleLinks,\n                ...bingLinks,\n                ...duckduckgoLinks\n            ];\n        } else {\n            // Fetch from a single search engine\n            console.log(`Fetching from ${searchEngine} for query: \"${query}\"`);\n            try {\n                switch(searchEngine){\n                    case \"google\":\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                        break;\n                    case \"bing\":\n                        allLinks = await getBingLinks(query);\n                        usedEngines.push(\"bing\");\n                        break;\n                    case \"duckduckgo\":\n                        allLinks = await getDuckDuckGoLinks(query);\n                        usedEngines.push(\"duckduckgo\");\n                        break;\n                    default:\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                }\n                console.log(`Found ${allLinks.length} links from ${searchEngine}`);\n            } catch (error) {\n                console.error(`Error fetching links from ${searchEngine}:`, error);\n                // Try Google as fallback if another engine fails\n                if (searchEngine !== \"google\") {\n                    console.log(\"Trying Google as fallback\");\n                    try {\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines = [\n                            \"google (fallback)\"\n                        ];\n                    } catch (fallbackError) {\n                        console.error(\"Fallback to Google also failed:\", fallbackError);\n                    }\n                }\n            }\n        }\n        // Filter and deduplicate links\n        const filteredLinks = filterAndDeduplicateLinks(allLinks);\n        // Limit to requested number of sources\n        const finalLinks = filteredLinks.slice(0, limitedSourceCount);\n        if (finalLinks.length === 0) {\n            return res.status(200).json({\n                sources: [],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: 0,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 0\n                }\n            });\n        }\n        // Scrape text from links with timeout and concurrency control\n        const sources = await scrapeSourcesWithTimeout(finalLinks);\n        // Process and clean up sources\n        const processedSources = processSources(sources);\n        // If we still don't have any valid sources after processing, create a fallback source\n        if (processedSources.length === 0) {\n            // Create a fallback source with search information\n            const fallbackSource = {\n                url: `https://www.google.com/search?q=${encodeURIComponent(query)}`,\n                title: `Search results for: ${query}`,\n                text: `We couldn't extract detailed information from the search results for \"${query}\".\n        This could be due to various reasons such as website restrictions or content formatting.\n\n        You can try:\n        1. Rephrasing your query to be more specific\n        2. Using a different search engine (try Bing or DuckDuckGo)\n        3. Searching for a related but different topic\n\n        The search was performed using ${usedEngines.join(\"+\")} and found ${allLinks.length} potential sources.`\n            };\n            // Return the fallback source\n            res.status(200).json({\n                sources: [\n                    fallbackSource\n                ],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 1,\n                    fallback: true\n                }\n            });\n        } else {\n            // Return the processed sources\n            res.status(200).json({\n                sources: processedSources,\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: processedSources.length\n                }\n            });\n        }\n    } catch (err) {\n        console.error(\"Error in sources API:\", err);\n        res.status(500).json({\n            sources: [],\n            error: \"Failed to fetch sources. Please try again.\"\n        });\n    }\n};\n/**\n * Filter and deduplicate links\n */ function filterAndDeduplicateLinks(links) {\n    // First, filter out invalid URLs and excluded domains\n    const validLinks = links.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const domain = url.hostname;\n            // Check if domain is in exclude list\n            return !EXCLUDED_DOMAINS.some((excluded)=>domain.includes(excluded));\n        } catch  {\n            return false;\n        }\n    });\n    // Then, deduplicate by domain\n    const uniqueDomains = new Set();\n    return validLinks.filter((link)=>{\n        try {\n            const domain = new URL(link).hostname;\n            if (uniqueDomains.has(domain)) return false;\n            uniqueDomains.add(domain);\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n}\n/**\n * Process and clean up sources\n */ function processSources(sources) {\n    const filteredSources = sources.filter((source)=>source !== undefined && source.text && source.text.length > 100);\n    // Truncate long texts and add metadata\n    return filteredSources.map((source)=>({\n            ...source,\n            text: source.text.slice(0, 1500),\n            title: extractTitle(source.url)\n        }));\n}\n/**\n * Extract a readable title from URL\n */ function extractTitle(url) {\n    try {\n        const { hostname , pathname  } = new URL(url);\n        // Get domain without www\n        const domain = hostname.replace(/^www\\./, \"\");\n        // Get last path segment without extension\n        const pathSegment = pathname.split(\"/\").filter(Boolean).pop() || \"\";\n        const cleanPathSegment = pathSegment.replace(/\\.\\w+$/, \"\").replace(/-|_/g, \" \");\n        if (cleanPathSegment) {\n            return `${cleanPathSegment.charAt(0).toUpperCase() + cleanPathSegment.slice(1)} - ${domain}`;\n        }\n        return domain;\n    } catch  {\n        return url;\n    }\n}\n/**\n * Scrape sources with timeout\n */ /**\n * Advanced web scraping with multiple extraction techniques and smart content detection\n */ async function scrapeSourcesWithTimeout(links) {\n    // Use a more controlled approach with concurrency limit and prioritization\n    const MAX_CONCURRENT = 4;\n    const results = [];\n    // Prioritize links based on domain reputation and URL structure\n    const prioritizedLinks = prioritizeLinks([\n        ...links\n    ]);\n    const pendingLinks = prioritizedLinks;\n    console.log(`Scraping ${pendingLinks.length} links with priority order`);\n    // Process links in batches to control concurrency\n    while(pendingLinks.length > 0){\n        const batch = pendingLinks.splice(0, MAX_CONCURRENT);\n        console.log(`Processing batch of ${batch.length} links`);\n        const batchResults = await Promise.all(batch.map(async (link)=>{\n            try {\n                // Try multiple extraction techniques\n                for(let technique = 0; technique < 3; technique++){\n                    try {\n                        console.log(`Fetching ${link} with technique ${technique + 1}`);\n                        // Adjust timeout based on technique\n                        const techniqueTimeout = FETCH_TIMEOUT + technique * 5000;\n                        // Use different fetch options based on technique\n                        const fetchOptions = {\n                            headers: {\n                                // Add referer for some techniques\n                                ...technique > 0 ? {\n                                    \"Referer\": \"https://www.google.com/\"\n                                } : {}\n                            }\n                        };\n                        const response = await fetchWithTimeout(link, fetchOptions, techniqueTimeout);\n                        if (!response.ok) {\n                            console.warn(`Failed to fetch ${link}: ${response.status}, technique ${technique + 1}`);\n                            // For certain status codes, we might want to skip to next technique\n                            if (response.status === 403 || response.status === 429) {\n                                continue;\n                            }\n                            // For other status codes, we might want to try a different approach\n                            if (technique < 2) {\n                                continue;\n                            } else {\n                                break; // Give up on this link after all techniques fail\n                            }\n                        }\n                        // Get content type to handle different types of content\n                        const contentType = response.headers.get(\"content-type\") || \"\";\n                        // Skip non-HTML content\n                        if (!contentType.includes(\"text/html\") && !contentType.includes(\"application/xhtml+xml\") && !contentType.includes(\"text/plain\")) {\n                            console.warn(`Skipping non-HTML content: ${contentType} for ${link}`);\n                            continue;\n                        }\n                        const html = await response.text();\n                        // Skip if we got a very small response (likely an error page)\n                        if (html.length < 800) {\n                            console.warn(`Too small response from ${link}: ${html.length} chars`);\n                            continue;\n                        }\n                        // Check for common error patterns in the HTML\n                        if (html.includes(\"captcha\") || html.includes(\"CAPTCHA\") || html.includes(\"access denied\") || html.includes(\"Access Denied\") || html.includes(\"403 Forbidden\")) {\n                            console.warn(`Detected access restriction in ${link}`);\n                            continue;\n                        }\n                        // Parse the HTML with different methods based on technique\n                        let extractedContent = null;\n                        // Technique 1: Use Readability\n                        if (technique === 0) {\n                            extractedContent = await extractWithReadability(html, link);\n                        }\n                        // Technique 2: Use custom content extraction\n                        if (technique === 1 || !extractedContent) {\n                            extractedContent = await extractWithCustomSelectors(html, link);\n                        }\n                        // Technique 3: Use simplified extraction\n                        if (technique === 2 || !extractedContent) {\n                            extractedContent = await extractWithSimplifiedMethod(html, link);\n                        }\n                        // If we successfully extracted content\n                        if (extractedContent && extractedContent.text.length > 200) {\n                            console.log(`Successfully extracted ${extractedContent.text.length} chars from ${link}`);\n                            // Clean and process the text\n                            const processedText = processExtractedText(extractedContent.text);\n                            return {\n                                url: link,\n                                text: processedText,\n                                title: extractedContent.title || extractTitle(link)\n                            };\n                        }\n                    } catch (techniqueError) {\n                        console.warn(`Technique ${technique + 1} failed for ${link}:`, techniqueError);\n                    }\n                }\n                // All techniques failed\n                console.error(`All extraction techniques failed for ${link}`);\n                return null;\n            } catch (error) {\n                console.error(`Error scraping ${link}:`, error);\n                return null;\n            }\n        }));\n        results.push(...batchResults);\n        // If we have enough good results, we can stop early\n        const validResults = results.filter(Boolean);\n        if (validResults.length >= 3) {\n            console.log(`Got ${validResults.length} good results, stopping early`);\n            break;\n        }\n    }\n    // Filter out null results and ensure we have at least some content\n    const validSources = results.filter(Boolean);\n    // Sort sources by content quality (length and readability)\n    const sortedSources = sortSourcesByQuality(validSources);\n    // If we have no valid sources, create intelligent fallback sources\n    if (sortedSources.length === 0 && links.length > 0) {\n        console.log(\"No valid sources found, creating fallback sources\");\n        return createFallbackSources(links);\n    }\n    return sortedSources;\n}\n/**\n * Prioritize links based on domain reputation and URL structure\n */ function prioritizeLinks(links) {\n    // Score each link\n    const scoredLinks = links.map((link)=>{\n        try {\n            const url = new URL(link);\n            let score = 0;\n            // Prefer certain domains\n            const hostname = url.hostname.toLowerCase();\n            // Higher score for reputable domains\n            if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\") || hostname.includes(\"github.com\") || hostname.includes(\"stackoverflow.com\") || hostname.includes(\"medium.com\")) {\n                score += 30;\n            }\n            // Prefer shorter URLs (often main pages)\n            score -= url.pathname.split(\"/\").length * 2;\n            // Prefer URLs without query parameters\n            score -= url.search.length > 0 ? 5 : 0;\n            // Avoid certain patterns\n            if (url.pathname.includes(\"login\") || url.pathname.includes(\"signup\") || url.pathname.includes(\"account\")) {\n                score -= 20;\n            }\n            return {\n                link,\n                score\n            };\n        } catch  {\n            return {\n                link,\n                score: -100\n            }; // Invalid URLs get lowest priority\n        }\n    });\n    // Sort by score (highest first)\n    scoredLinks.sort((a, b)=>b.score - a.score);\n    // Return just the links\n    return scoredLinks.map((item)=>item.link);\n}\n/**\n * Extract content using Mozilla's Readability\n */ async function extractWithReadability(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url,\n            runScripts: \"outside-only\",\n            pretendToBeVisual: true\n        });\n        const reader = new _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__.Readability(dom.window.document);\n        const article = reader.parse();\n        if (article && article.textContent && article.textContent.length > 200) {\n            return {\n                text: article.textContent,\n                title: article.title || dom.window.document.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Readability extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Extract content using custom selectors for different site types\n */ async function extractWithCustomSelectors(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url\n        });\n        const doc = dom.window.document;\n        // Get the hostname to apply site-specific selectors\n        const hostname = new URL(url).hostname.toLowerCase();\n        // Define selectors for different site types\n        let selectors = [];\n        // Wikipedia-specific selectors\n        if (hostname.includes(\"wikipedia.org\")) {\n            selectors = [\n                \"#mw-content-text\",\n                \".mw-parser-output\"\n            ];\n        } else if (hostname.includes(\"github.com\")) {\n            selectors = [\n                \".markdown-body\",\n                \"article.markdown-body\",\n                \".repository-content\"\n            ];\n        } else if (hostname.includes(\"stackoverflow.com\")) {\n            selectors = [\n                \".post-text\",\n                \".answer\"\n            ];\n        } else if (hostname.includes(\"news\") || hostname.includes(\"bbc\") || hostname.includes(\"cnn\") || hostname.includes(\"nytimes\")) {\n            selectors = [\n                \".article-body\",\n                \".story-body\",\n                \".article__content\",\n                '[itemprop=\"articleBody\"]'\n            ];\n        } else {\n            selectors = [\n                \"main\",\n                \"article\",\n                '[role=\"main\"]',\n                \"#content\",\n                \".content\",\n                \".post-content\",\n                \".entry-content\",\n                \".article-content\",\n                \".post-body\",\n                \".page-content\",\n                \".main-content\",\n                \".body-content\"\n            ];\n        }\n        // Try each selector\n        for (const selector of selectors){\n            const elements = doc.querySelectorAll(selector);\n            if (elements.length > 0) {\n                // Combine text from all matching elements\n                let combinedText = \"\";\n                elements.forEach((el)=>{\n                    combinedText += el.textContent + \"\\n\\n\";\n                });\n                if (combinedText.length > 200) {\n                    return {\n                        text: combinedText,\n                        title: doc.title || extractTitle(url)\n                    };\n                }\n            }\n        }\n        // If no content found with selectors, try to find the largest text block\n        const textBlocks = findLargestTextBlocks(doc);\n        if (textBlocks && textBlocks.length > 200) {\n            return {\n                text: textBlocks,\n                title: doc.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Custom extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Extract content using a simplified method (fallback)\n */ async function extractWithSimplifiedMethod(html, url) {\n    try {\n        // Use cheerio for lightweight parsing\n        const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n        // Remove script, style, nav, footer, and other non-content elements\n        $(\"script, style, nav, footer, header, aside, .sidebar, .footer, .header, .navigation, .nav, .menu, .comments, .ads, .ad\").remove();\n        // Get the title\n        const title = $(\"title\").text() || extractTitle(url);\n        // Get all paragraphs\n        const paragraphs = [];\n        $(\"p\").each((_, el)=>{\n            const text = $(el).text().trim();\n            if (text.length > 20) {\n                paragraphs.push(text);\n            }\n        });\n        // If we found paragraphs, join them\n        if (paragraphs.length > 0) {\n            return {\n                text: paragraphs.join(\"\\n\\n\"),\n                title\n            };\n        }\n        // Fallback: get all text from body\n        const bodyText = $(\"body\").text();\n        if (bodyText.length > 200) {\n            // Clean up the text\n            const cleanedText = bodyText.replace(/\\s+/g, \" \").trim().split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 20).join(\"\\n\\n\");\n            if (cleanedText.length > 200) {\n                return {\n                    text: cleanedText,\n                    title\n                };\n            }\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Simplified extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Find the largest text blocks in a document\n */ function findLargestTextBlocks(doc) {\n    // Get all elements with substantial text\n    const textElements = [];\n    // Function to recursively process elements\n    function processElement(element) {\n        // Skip certain elements\n        const tagName = element.tagName.toLowerCase();\n        if ([\n            \"script\",\n            \"style\",\n            \"nav\",\n            \"header\",\n            \"footer\"\n        ].includes(tagName)) {\n            return;\n        }\n        // Check if this element has direct text\n        const directText = Array.from(element.childNodes).filter((node)=>node.nodeType === 3) // Text nodes only\n        .map((node)=>node.textContent || \"\").join(\"\").trim();\n        // If this element has substantial direct text, add it\n        if (directText.length > 50) {\n            textElements.push({\n                element,\n                length: directText.length\n            });\n        }\n        // Process children\n        Array.from(element.children).forEach(processElement);\n    }\n    // Start processing from body\n    processElement(doc.body);\n    // Sort by text length (largest first)\n    textElements.sort((a, b)=>b.length - a.length);\n    // Take the top elements that likely contain main content\n    const mainContentElements = textElements.slice(0, 10);\n    // Extract and join their text\n    return mainContentElements.map((item)=>item.element.textContent || \"\").join(\"\\n\\n\");\n}\n/**\n * Process and clean extracted text\n */ function processExtractedText(text) {\n    // Remove excessive whitespace\n    let processed = text.replace(/\\s+/g, \" \");\n    // Split into lines and clean each line\n    processed = processed.split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 0).join(\"\\n\");\n    // Remove duplicate paragraphs\n    const paragraphs = processed.split(\"\\n\\n\");\n    const uniqueParagraphs = Array.from(new Set(paragraphs));\n    processed = uniqueParagraphs.join(\"\\n\\n\");\n    // Limit length to avoid extremely long texts\n    if (processed.length > 8000) {\n        processed = processed.substring(0, 8000) + \"...\";\n    }\n    return processed;\n}\n/**\n * Sort sources by quality\n */ function sortSourcesByQuality(sources) {\n    return [\n        ...sources\n    ].sort((a, b)=>{\n        // Calculate quality score based on text length and other factors\n        const scoreA = calculateContentQualityScore(a);\n        const scoreB = calculateContentQualityScore(b);\n        return scoreB - scoreA;\n    });\n}\n/**\n * Calculate content quality score\n */ function calculateContentQualityScore(source) {\n    let score = 0;\n    // Length is a primary factor\n    score += Math.min(source.text.length / 100, 50);\n    // Prefer sources with titles\n    score += source.title ? 10 : 0;\n    // Prefer sources from reputable domains\n    try {\n        const hostname = new URL(source.url).hostname.toLowerCase();\n        if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\")) {\n            score += 20;\n        }\n    } catch  {\n    // Invalid URL\n    }\n    return score;\n}\n/**\n * Create fallback sources when extraction fails\n */ function createFallbackSources(links) {\n    // Create at least one fallback source\n    const fallbackSources = [];\n    // Try to create sources from the top 3 links\n    const topLinks = links.slice(0, 3);\n    for (const link of topLinks){\n        try {\n            const domain = new URL(link).hostname.replace(\"www.\", \"\");\n            fallbackSources.push({\n                url: link,\n                text: `This information is from ${domain}. The content could not be fully extracted due to website restrictions. Please visit the website directly for complete information.`,\n                title: `Information from ${domain}`\n            });\n        } catch  {\n        // Skip invalid URLs\n        }\n    }\n    // If we couldn't create any fallback sources, create a generic one\n    if (fallbackSources.length === 0 && links.length > 0) {\n        fallbackSources.push({\n            url: links[0],\n            text: `Information could not be retrieved from the sources. This might be due to website restrictions or technical limitations. Try refining your search query or visiting the websites directly.`,\n            title: `Search Results`\n        });\n    }\n    return fallbackSources;\n}\n/**\n * Advanced Google search with multiple extraction techniques and fallbacks\n */ async function getGoogleLinks(query) {\n    try {\n        console.log(`Making Google search request for: \"${query}\"`);\n        // Try multiple search variations to improve results\n        const searchVariations = [\n            // Standard search\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=30`,\n            // Search with verbatim option to get exact matches\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=li:1`,\n            // Search with recent results\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=qdr:y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying search variation ${i + 1}: ${searchUrl}`);\n                // Add additional headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.google.com/\",\n                        \"DNT\": \"1\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\",\n                        \"sec-ch-ua\": '\"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"',\n                        \"sec-ch-ua-mobile\": \"?0\",\n                        \"sec-ch-ua-platform\": '\"Windows\"'\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Google search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Google variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                if (html.includes(\"unusual traffic\") || html.includes(\"CAPTCHA\") || html.includes(\"detected unusual traffic\")) {\n                    console.warn(`Google variation ${i + 1} blocked or returned a CAPTCHA`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractGoogleLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Google variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Google search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Google`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Google links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from Google search results HTML using multiple methods\n */ function extractGoogleLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Standard Google search results - look for redirects\n    $(\"a\").each((_, link)=>{\n        const href = $(link).attr(\"href\");\n        if (href && href.startsWith(\"/url?q=\")) {\n            try {\n                const cleanedHref = decodeURIComponent(href.replace(\"/url?q=\", \"\").split(\"&\")[0]);\n                if (isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Look for result containers and extract links\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 2\");\n        // Modern Google selectors\n        $(\".g .yuRUbf > a, .g .rc > a, .g h3.r > a, .tF2Cxc > div.yuRUbf > a, .hlcw0c .yuRUbf > a\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.startsWith(\"http\") && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    // Method 3: Extract from cite elements\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 3\");\n        $(\".iUh30, .tjvcx, .qzEoUe\").each((_, element)=>{\n            const parentLink = $(element).closest(\"a\").attr(\"href\");\n            if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n                links.push(parentLink);\n            } else {\n                // Try to construct URL from cite text\n                const citeText = $(element).text().trim();\n                if (citeText && !citeText.includes(\"...\") && citeText.includes(\".\")) {\n                    try {\n                        let url = citeText;\n                        if (!url.startsWith(\"http\")) {\n                            url = \"https://\" + url;\n                        }\n                        if (isValidUrl(url) && !links.includes(url)) {\n                            links.push(url);\n                        }\n                    } catch (e) {\n                    // Skip invalid URLs\n                    }\n                }\n            }\n        });\n    }\n    // Method 4: Last resort - find any external links\n    if (links.length < 3) {\n        console.log(\"Using Google extraction method 4 (last resort)\");\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"google.com\") && !href.includes(\"accounts.\") && !href.includes(\"support.\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\n * Filter and clean a list of URLs\n */ function filterAndCleanLinks(links) {\n    // Remove duplicates\n    let uniqueLinks = Array.from(new Set(links));\n    // Filter out invalid and unwanted URLs\n    uniqueLinks = uniqueLinks.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const hostname = url.hostname.toLowerCase();\n            // Filter out common non-content domains\n            const invalidDomains = [\n                \"google.com\",\n                \"youtube.com\",\n                \"facebook.com\",\n                \"twitter.com\",\n                \"instagram.com\",\n                \"linkedin.com\",\n                \"pinterest.com\",\n                \"amazon.com\",\n                \"ebay.com\",\n                \"netflix.com\",\n                \"apple.com\",\n                \"microsoft.com\",\n                \"play.google.com\",\n                \"accounts.google.com\",\n                \"support.google.com\",\n                \"maps.google.com\",\n                \"policies.google.com\",\n                \"translate.google.com\",\n                \"chrome.google.com\",\n                \"docs.google.com\",\n                \"drive.google.com\",\n                \"mail.google.com\",\n                \"calendar.google.com\"\n            ];\n            if (invalidDomains.some((domain)=>hostname.includes(domain))) {\n                return false;\n            }\n            // Filter out URLs with certain patterns\n            const invalidPatterns = [\n                \"/search?\",\n                \"/login\",\n                \"/signin\",\n                \"/signup\",\n                \"/register\",\n                \"/account\",\n                \"/cart\",\n                \"/checkout\",\n                \"/privacy\",\n                \"/terms\",\n                \"/contact\",\n                \"/about\",\n                \"/help\",\n                \"/support\",\n                \"/faq\",\n                \"/download\",\n                \"/subscribe\",\n                \"/membership\",\n                \"/pricing\"\n            ];\n            if (invalidPatterns.some((pattern)=>url.pathname.includes(pattern))) {\n                return false;\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n    // Limit to a reasonable number\n    return uniqueLinks.slice(0, 20);\n}\n/**\n * Validate if a string is a valid URL and meets content criteria\n */ function isValidUrl(url) {\n    try {\n        new URL(url);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Enhanced Bing search with multiple extraction techniques\n */ async function getBingLinks(query) {\n    try {\n        console.log(`Making Bing search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard search\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&count=30`,\n            // Search with news\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=news`,\n            // Search with freshness filter\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=ex1%3a\"ez5\"`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from Bing, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying Bing search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.bing.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Bing search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Bing variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractBingLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Bing variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Bing search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Bing`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Bing links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from Bing search results HTML\n */ function extractBingLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main search results\n    $(\".b_algo h2 a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 2: Extract from cite elements\n    $(\".b_caption cite\").each((_, element)=>{\n        const parentLink = $(element).closest(\".b_algo\").find(\"h2 a\").attr(\"href\");\n        if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n            links.push(parentLink);\n        }\n    });\n    // Method 3: Extract from deep links\n    $(\".b_deeplinks a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 4: Last resort - find any external links\n    if (links.length < 5) {\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"bing.com\") && !href.includes(\"microsoft.com\") && !href.includes(\"msn.com\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\n * Enhanced DuckDuckGo search with multiple extraction techniques\n */ async function getDuckDuckGoLinks(query) {\n    try {\n        console.log(`Making DuckDuckGo search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard HTML search\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`,\n            // With region set to US\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&kl=us-en`,\n            // With time filter for recent results\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&df=y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from DuckDuckGo, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying DuckDuckGo search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://duckduckgo.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`DuckDuckGo search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from DuckDuckGo variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using our custom function\n                const extractedLinks = extractDuckDuckGoLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from DuckDuckGo variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with DuckDuckGo search variation ${i + 1}:`, variationError);\n            }\n        }\n        // If HTML search failed, try the lite version as fallback\n        if (allLinks.length === 0) {\n            try {\n                console.log(\"Trying DuckDuckGo Lite as fallback\");\n                const liteUrl = `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(query)}`;\n                const response = await fetchWithTimeout(liteUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\"\n                    }\n                });\n                if (response.ok) {\n                    const html = await response.text();\n                    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n                    // Extract links from the lite version\n                    $(\"a[href^='http']\").each((_, element)=>{\n                        const href = $(element).attr(\"href\");\n                        if (href && !href.includes(\"duckduckgo.com\") && isValidUrl(href) && !allLinks.includes(href)) {\n                            allLinks.push(href);\n                        }\n                    });\n                    console.log(`Found ${allLinks.length} links from DuckDuckGo Lite fallback`);\n                }\n            } catch (liteError) {\n                console.error(\"Error with DuckDuckGo Lite fallback:\", liteError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from DuckDuckGo`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching DuckDuckGo links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from DuckDuckGo search results HTML\n */ function extractDuckDuckGoLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main result links\n    $(\".result__a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href) {\n            try {\n                // DuckDuckGo uses relative URLs with parameters\n                const url = new URL(href, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Extract from result snippets\n    $(\".result__snippet\").each((_, element)=>{\n        const parentLink = $(element).closest(\".result\").find(\".result__a\").attr(\"href\");\n        if (parentLink) {\n            try {\n                const url = new URL(parentLink, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 3: Last resort - find any external links\n    if (links.length < 3) {\n        $(\"a[href^='/']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.includes(\"uddg=\")) {\n                try {\n                    const url = new URL(href, \"https://duckduckgo.com\");\n                    const cleanedHref = url.searchParams.get(\"uddg\");\n                    if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                        links.push(cleanedHref);\n                    }\n                } catch (e) {\n                // Skip invalid URLs\n                }\n            }\n        });\n    }\n    return links;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (searchHandler);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1lBQ1Ysb0JBQW9CO1lBQ3RCO1FBQ0YsQ0FBQztJQUNIO0lBRUEsa0RBQWtEO0lBQ2xELElBQUkzSCxNQUFNbkYsTUFBTSxHQUFHLEdBQUc7UUFDcEJtSyxFQUFFLGdCQUFnQkksSUFBSSxDQUFDLENBQUNDLEdBQUdPLFVBQVk7WUFDckMsTUFBTXlCLE9BQU9yQyxFQUFFWSxTQUFTMEIsSUFBSSxDQUFDO1lBQzdCLElBQUlELFFBQVFBLEtBQUtySyxRQUFRLENBQUMsVUFBVTtnQkFDbEMsSUFBSTtvQkFDRixNQUFNN0IsTUFBTSxJQUFJaUYsSUFBSWlILE1BQU07b0JBQzFCLE1BQU1HLGNBQWNyTSxJQUFJcU4sWUFBWSxDQUFDakcsR0FBRyxDQUFDO29CQUV6QyxJQUFJaUYsZUFBZUUsV0FBV0YsZ0JBQWdCLENBQUN4SCxNQUFNaEQsUUFBUSxDQUFDd0ssY0FBYzt3QkFDMUV4SCxNQUFNcEIsSUFBSSxDQUFDNEk7b0JBQ2IsQ0FBQztnQkFDSCxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1Ysb0JBQW9CO2dCQUN0QjtZQUNGLENBQUM7UUFDSDtJQUNGLENBQUM7SUFFRCxPQUFPM0g7QUFDVDtBQUVBLGlFQUFlL0MsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vcGFnZXMvYXBpL3NvdXJjZXMudHM/ZTllMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb3VyY2UgfSBmcm9tIFwiQC90eXBlc1wiO1xuaW1wb3J0IHsgUmVhZGFiaWxpdHkgfSBmcm9tIFwiQG1vemlsbGEvcmVhZGFiaWxpdHlcIjtcbmltcG9ydCAqIGFzIGNoZWVyaW8gZnJvbSBcImNoZWVyaW9cIjtcbmltcG9ydCB7IEpTRE9NIH0gZnJvbSBcImpzZG9tXCI7XG5pbXBvcnQgdHlwZSB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tIFwibmV4dFwiO1xuXG4vLyBEZWZpbmUgcmVzcG9uc2UgdHlwZVxudHlwZSBTb3VyY2VzUmVzcG9uc2UgPSB7XG4gIHNvdXJjZXM6IFNvdXJjZVtdO1xuICBtZXRhZGF0YT86IHtcbiAgICBlbmdpbmU6IHN0cmluZztcbiAgICB0b3RhbFJlc3VsdHM/OiBudW1iZXI7XG4gICAgc2VhcmNoVGltZT86IG51bWJlcjtcbiAgICBmaWx0ZXJlZFNvdXJjZXM/OiBudW1iZXI7XG4gIH07XG4gIGVycm9yPzogc3RyaW5nO1xufTtcblxuLy8gRGVmaW5lIHNlYXJjaCBlbmdpbmUgdHlwZVxuZXhwb3J0IHR5cGUgU2VhcmNoRW5naW5lID0gXCJnb29nbGVcIiB8IFwiYmluZ1wiIHwgXCJkdWNrZHVja2dvXCIgfCBcImFsbFwiO1xuXG4vLyBUaW1lb3V0IGZvciBmZXRjaCByZXF1ZXN0cyAoMTUgc2Vjb25kcylcbmNvbnN0IEZFVENIX1RJTUVPVVQgPSAxNTAwMDtcblxuLy8gVXNlciBhZ2VudCByb3RhdGlvbiBmb3IgcmVxdWVzdHNcbmNvbnN0IFVTRVJfQUdFTlRTID0gW1xuICBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85Ni4wLjQ2NjQuMTEwIFNhZmFyaS81MzcuMzZcIixcbiAgXCJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNV83KSBBcHBsZVdlYktpdC82MDUuMS4xNSAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTUuMCBTYWZhcmkvNjA1LjEuMTVcIixcbiAgXCJNb3ppbGxhLzUuMCAoWDExOyBMaW51eCB4ODZfNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85Ni4wLjQ2NjQuNDUgU2FmYXJpLzUzNy4zNlwiLFxuICBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQ7IHJ2Ojk0LjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvOTQuMFwiLFxuICBcIk1vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTVfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDUuMS4xNSAoS0hUTUwsIGxpa2UgR2Vja28pIENyaU9TLzk2LjAuNDY2NC41MyBNb2JpbGUvMTVFMTQ4IFNhZmFyaS82MDQuMVwiXG5dO1xuXG4vLyBHZXQgYSByYW5kb20gdXNlciBhZ2VudFxuY29uc3QgZ2V0UmFuZG9tVXNlckFnZW50ID0gKCkgPT4gVVNFUl9BR0VOVFNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogVVNFUl9BR0VOVFMubGVuZ3RoKV07XG5cbi8vIE1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgZm9yIGZldGNoIHJlcXVlc3RzXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5cbi8vIERlbGF5IGJldHdlZW4gcmV0cmllcyAoaW4gbXMpXG5jb25zdCBSRVRSWV9ERUxBWSA9IDEwMDA7XG5cbi8vIE51bWJlciBvZiBzb3VyY2VzIHRvIHJldHVyblxuY29uc3QgREVGQVVMVF9TT1VSQ0VfQ09VTlQgPSA0O1xuXG4vLyBMaXN0IG9mIGRvbWFpbnMgdG8gZXhjbHVkZSBmcm9tIHJlc3VsdHNcbmNvbnN0IEVYQ0xVREVEX0RPTUFJTlMgPSBbXG4gIFwiZ29vZ2xlXCIsIFwiZmFjZWJvb2tcIiwgXCJ0d2l0dGVyXCIsIFwiaW5zdGFncmFtXCIsIFwieW91dHViZVwiLCBcInRpa3Rva1wiLFxuICBcImJpbmdcIiwgXCJkdWNrZHVja2dvXCIsIFwicGludGVyZXN0XCIsIFwibGlua2VkaW5cIiwgXCJyZWRkaXRcIiwgXCJxdW9yYVwiXG5dO1xuXG4vKipcbiAqIEVuaGFuY2VkIGZldGNoIHdpdGggdGltZW91dCwgcmV0cmllcywgYW5kIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoVGltZW91dCh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSwgdGltZW91dCA9IEZFVENIX1RJTUVPVVQpOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gVHJ5IG11bHRpcGxlIHRpbWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IE1BWF9SRVRSSUVTOyBhdHRlbXB0KyspIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRNcyA9IHRpbWVvdXQgKiAoYXR0ZW1wdCArIDEpOyAvLyBJbmNyZWFzZSB0aW1lb3V0IHdpdGggZWFjaCByZXRyeVxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXRNcyk7XG5cbiAgICAvLyBBZGQgZGVmYXVsdCBoZWFkZXJzIGluY2x1ZGluZyBhIHJhbmRvbSB1c2VyIGFnZW50XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXG4gICAgICAnQWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsKi8qO3E9MC44JyxcbiAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjUnLFxuICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXG4gICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcbiAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSBiZXR3ZWVuIHJldHJpZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIFJFVFJZX0RFTEFZICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBSZXRyeSBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZvciAke3VybH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnXG4gICAgICB9KTtcblxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgZ290IGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBjZXJ0YWluIHN0YXR1cyBjb2Rlcywgd2UgbWlnaHQgd2FudCB0byByZXRyeVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgIGxhc3RFcnJvciA9IG5ldyBFcnJvcihgSFRUUCBlcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICBjb250aW51ZTsgLy8gUmV0cnlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7IC8vIFJldHVybiB0aGUgcmVzcG9uc2UgZXZlbiBpZiBpdCdzIG5vdCBva1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcblxuICAgICAgLy8gRG9uJ3QgcmV0cnkgaWYgaXQncyBhIENPUlMgZXJyb3Igb3IgaWYgdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQ09SUycpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBDb250aW51ZSB0byBuZXh0IHJldHJ5IGF0dGVtcHRcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHJldHJpZXMsIHRocm93IHRoZSBsYXN0IGVycm9yXG4gIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3VybH0gYWZ0ZXIgJHtNQVhfUkVUUklFU30gYXR0ZW1wdHNgKTtcbn1cblxuLyoqXG4gKiBNYWluIGhhbmRsZXIgZm9yIHRoZSBzb3VyY2VzIEFQSVxuICovXG5jb25zdCBzZWFyY2hIYW5kbGVyID0gYXN5bmMgKHJlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlPFNvdXJjZXNSZXNwb25zZT4pID0+IHtcbiAgLy8gT25seSBhbGxvdyBQT1NUIHJlcXVlc3RzXG4gIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBzb3VyY2VzOiBbXSwgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgcXVlcnksIHNlYXJjaEVuZ2luZSA9IFwiZ29vZ2xlXCIsIHNvdXJjZUNvdW50ID0gREVGQVVMVF9TT1VSQ0VfQ09VTlQgfSA9IHJlcS5ib2R5IGFzIHtcbiAgICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgICBzZWFyY2hFbmdpbmU/OiBTZWFyY2hFbmdpbmU7XG4gICAgICBzb3VyY2VDb3VudD86IG51bWJlcjtcbiAgICB9O1xuXG4gICAgLy8gVmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIXF1ZXJ5IHx8IHR5cGVvZiBxdWVyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XG4gICAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgcXVlcnkgcHJvdmlkZWQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBMaW1pdCBzb3VyY2UgY291bnQgdG8gcmVhc29uYWJsZSB2YWx1ZXNcbiAgICBjb25zdCBsaW1pdGVkU291cmNlQ291bnQgPSBNYXRoLm1pbihNYXRoLm1heCgxLCBzb3VyY2VDb3VudCksIDgpO1xuXG4gICAgbGV0IGFsbExpbmtzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCB1c2VkRW5naW5lczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIEdldCBsaW5rcyBmcm9tIHNlbGVjdGVkIHNlYXJjaCBlbmdpbmUocylcbiAgICBpZiAoc2VhcmNoRW5naW5lID09PSBcImFsbFwiKSB7XG4gICAgICAvLyBGZXRjaCBmcm9tIGFsbCBzZWFyY2ggZW5naW5lcyBpbiBwYXJhbGxlbFxuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGZyb20gYWxsIHNlYXJjaCBlbmdpbmVzIGZvciBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG5cbiAgICAgIGNvbnN0IFtnb29nbGVMaW5rcywgYmluZ0xpbmtzLCBkdWNrZHVja2dvTGlua3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRHb29nbGVMaW5rcyhxdWVyeSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBHb29nbGUgbGlua3M6XCIsIGVycik7XG4gICAgICAgICAgcmV0dXJuIFtdIGFzIHN0cmluZ1tdO1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0QmluZ0xpbmtzKHF1ZXJ5KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIEJpbmcgbGlua3M6XCIsIGVycik7XG4gICAgICAgICAgcmV0dXJuIFtdIGFzIHN0cmluZ1tdO1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0RHVja0R1Y2tHb0xpbmtzKHF1ZXJ5KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIER1Y2tEdWNrR28gbGlua3M6XCIsIGVycik7XG4gICAgICAgICAgcmV0dXJuIFtdIGFzIHN0cmluZ1tdO1xuICAgICAgICB9KVxuICAgICAgXSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBsaW5rcyAtIEdvb2dsZTogJHtnb29nbGVMaW5rcy5sZW5ndGh9LCBCaW5nOiAke2JpbmdMaW5rcy5sZW5ndGh9LCBEdWNrRHVja0dvOiAke2R1Y2tkdWNrZ29MaW5rcy5sZW5ndGh9YCk7XG5cbiAgICAgIGlmIChnb29nbGVMaW5rcy5sZW5ndGggPiAwKSB1c2VkRW5naW5lcy5wdXNoKFwiZ29vZ2xlXCIpO1xuICAgICAgaWYgKGJpbmdMaW5rcy5sZW5ndGggPiAwKSB1c2VkRW5naW5lcy5wdXNoKFwiYmluZ1wiKTtcbiAgICAgIGlmIChkdWNrZHVja2dvTGlua3MubGVuZ3RoID4gMCkgdXNlZEVuZ2luZXMucHVzaChcImR1Y2tkdWNrZ29cIik7XG5cbiAgICAgIGFsbExpbmtzID0gWy4uLmdvb2dsZUxpbmtzLCAuLi5iaW5nTGlua3MsIC4uLmR1Y2tkdWNrZ29MaW5rc107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZldGNoIGZyb20gYSBzaW5nbGUgc2VhcmNoIGVuZ2luZVxuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGZyb20gJHtzZWFyY2hFbmdpbmV9IGZvciBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAoc2VhcmNoRW5naW5lKSB7XG4gICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRHb29nbGVMaW5rcyhxdWVyeSk7XG4gICAgICAgICAgICB1c2VkRW5naW5lcy5wdXNoKFwiZ29vZ2xlXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJpbmdcIjpcbiAgICAgICAgICAgIGFsbExpbmtzID0gYXdhaXQgZ2V0QmluZ0xpbmtzKHF1ZXJ5KTtcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzLnB1c2goXCJiaW5nXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImR1Y2tkdWNrZ29cIjpcbiAgICAgICAgICAgIGFsbExpbmtzID0gYXdhaXQgZ2V0RHVja0R1Y2tHb0xpbmtzKHF1ZXJ5KTtcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzLnB1c2goXCJkdWNrZHVja2dvXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFsbExpbmtzID0gYXdhaXQgZ2V0R29vZ2xlTGlua3MocXVlcnkpO1xuICAgICAgICAgICAgdXNlZEVuZ2luZXMucHVzaChcImdvb2dsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSAke3NlYXJjaEVuZ2luZX1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxpbmtzIGZyb20gJHtzZWFyY2hFbmdpbmV9OmAsIGVycm9yKTtcbiAgICAgICAgLy8gVHJ5IEdvb2dsZSBhcyBmYWxsYmFjayBpZiBhbm90aGVyIGVuZ2luZSBmYWlsc1xuICAgICAgICBpZiAoc2VhcmNoRW5naW5lICE9PSBcImdvb2dsZVwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgR29vZ2xlIGFzIGZhbGxiYWNrXCIpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhbGxMaW5rcyA9IGF3YWl0IGdldEdvb2dsZUxpbmtzKHF1ZXJ5KTtcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzID0gW1wiZ29vZ2xlIChmYWxsYmFjaylcIl07XG4gICAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhbGxiYWNrIHRvIEdvb2dsZSBhbHNvIGZhaWxlZDpcIiwgZmFsbGJhY2tFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGFuZCBkZWR1cGxpY2F0ZSBsaW5rc1xuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmREZWR1cGxpY2F0ZUxpbmtzKGFsbExpbmtzKTtcblxuICAgIC8vIExpbWl0IHRvIHJlcXVlc3RlZCBudW1iZXIgb2Ygc291cmNlc1xuICAgIGNvbnN0IGZpbmFsTGlua3MgPSBmaWx0ZXJlZExpbmtzLnNsaWNlKDAsIGxpbWl0ZWRTb3VyY2VDb3VudCk7XG5cbiAgICBpZiAoZmluYWxMaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGVuZ2luZTogdXNlZEVuZ2luZXMuam9pbignKycpLFxuICAgICAgICAgIHRvdGFsUmVzdWx0czogMCxcbiAgICAgICAgICBzZWFyY2hUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIGZpbHRlcmVkU291cmNlczogMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTY3JhcGUgdGV4dCBmcm9tIGxpbmtzIHdpdGggdGltZW91dCBhbmQgY29uY3VycmVuY3kgY29udHJvbFxuICAgIGNvbnN0IHNvdXJjZXMgPSBhd2FpdCBzY3JhcGVTb3VyY2VzV2l0aFRpbWVvdXQoZmluYWxMaW5rcyk7XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjbGVhbiB1cCBzb3VyY2VzXG4gICAgY29uc3QgcHJvY2Vzc2VkU291cmNlcyA9IHByb2Nlc3NTb3VyY2VzKHNvdXJjZXMpO1xuXG4gICAgLy8gSWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhbnkgdmFsaWQgc291cmNlcyBhZnRlciBwcm9jZXNzaW5nLCBjcmVhdGUgYSBmYWxsYmFjayBzb3VyY2VcbiAgICBpZiAocHJvY2Vzc2VkU291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIENyZWF0ZSBhIGZhbGxiYWNrIHNvdXJjZSB3aXRoIHNlYXJjaCBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgZmFsbGJhY2tTb3VyY2U6IFNvdXJjZSA9IHtcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCxcbiAgICAgICAgdGl0bGU6IGBTZWFyY2ggcmVzdWx0cyBmb3I6ICR7cXVlcnl9YCxcbiAgICAgICAgdGV4dDogYFdlIGNvdWxkbid0IGV4dHJhY3QgZGV0YWlsZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VhcmNoIHJlc3VsdHMgZm9yIFwiJHtxdWVyeX1cIi5cbiAgICAgICAgVGhpcyBjb3VsZCBiZSBkdWUgdG8gdmFyaW91cyByZWFzb25zIHN1Y2ggYXMgd2Vic2l0ZSByZXN0cmljdGlvbnMgb3IgY29udGVudCBmb3JtYXR0aW5nLlxuXG4gICAgICAgIFlvdSBjYW4gdHJ5OlxuICAgICAgICAxLiBSZXBocmFzaW5nIHlvdXIgcXVlcnkgdG8gYmUgbW9yZSBzcGVjaWZpY1xuICAgICAgICAyLiBVc2luZyBhIGRpZmZlcmVudCBzZWFyY2ggZW5naW5lICh0cnkgQmluZyBvciBEdWNrRHVja0dvKVxuICAgICAgICAzLiBTZWFyY2hpbmcgZm9yIGEgcmVsYXRlZCBidXQgZGlmZmVyZW50IHRvcGljXG5cbiAgICAgICAgVGhlIHNlYXJjaCB3YXMgcGVyZm9ybWVkIHVzaW5nICR7dXNlZEVuZ2luZXMuam9pbignKycpfSBhbmQgZm91bmQgJHthbGxMaW5rcy5sZW5ndGh9IHBvdGVudGlhbCBzb3VyY2VzLmBcbiAgICAgIH07XG5cbiAgICAgIC8vIFJldHVybiB0aGUgZmFsbGJhY2sgc291cmNlXG4gICAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgIHNvdXJjZXM6IFtmYWxsYmFja1NvdXJjZV0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZW5naW5lOiB1c2VkRW5naW5lcy5qb2luKCcrJyksXG4gICAgICAgICAgdG90YWxSZXN1bHRzOiBhbGxMaW5rcy5sZW5ndGgsXG4gICAgICAgICAgc2VhcmNoVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICBmaWx0ZXJlZFNvdXJjZXM6IDEsXG4gICAgICAgICAgZmFsbGJhY2s6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcHJvY2Vzc2VkIHNvdXJjZXNcbiAgICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgICAgc291cmNlczogcHJvY2Vzc2VkU291cmNlcyxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBlbmdpbmU6IHVzZWRFbmdpbmVzLmpvaW4oJysnKSxcbiAgICAgICAgICB0b3RhbFJlc3VsdHM6IGFsbExpbmtzLmxlbmd0aCxcbiAgICAgICAgICBzZWFyY2hUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIGZpbHRlcmVkU291cmNlczogcHJvY2Vzc2VkU291cmNlcy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBzb3VyY2VzIEFQSTpcIiwgZXJyKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzb3VyY2VzOiBbXSxcbiAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIHNvdXJjZXMuIFBsZWFzZSB0cnkgYWdhaW4uJ1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlciBhbmQgZGVkdXBsaWNhdGUgbGlua3NcbiAqL1xuZnVuY3Rpb24gZmlsdGVyQW5kRGVkdXBsaWNhdGVMaW5rcyhsaW5rczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIC8vIEZpcnN0LCBmaWx0ZXIgb3V0IGludmFsaWQgVVJMcyBhbmQgZXhjbHVkZWQgZG9tYWluc1xuICBjb25zdCB2YWxpZExpbmtzID0gbGlua3MuZmlsdGVyKGxpbmsgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGxpbmspO1xuICAgICAgY29uc3QgZG9tYWluID0gdXJsLmhvc3RuYW1lO1xuXG4gICAgICAvLyBDaGVjayBpZiBkb21haW4gaXMgaW4gZXhjbHVkZSBsaXN0XG4gICAgICByZXR1cm4gIUVYQ0xVREVEX0RPTUFJTlMuc29tZShleGNsdWRlZCA9PiBkb21haW4uaW5jbHVkZXMoZXhjbHVkZWQpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4sIGRlZHVwbGljYXRlIGJ5IGRvbWFpblxuICBjb25zdCB1bmlxdWVEb21haW5zID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHJldHVybiB2YWxpZExpbmtzLmZpbHRlcihsaW5rID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZG9tYWluID0gbmV3IFVSTChsaW5rKS5ob3N0bmFtZTtcbiAgICAgIGlmICh1bmlxdWVEb21haW5zLmhhcyhkb21haW4pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHVuaXF1ZURvbWFpbnMuYWRkKGRvbWFpbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW5kIGNsZWFuIHVwIHNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1NvdXJjZXMoc291cmNlczogU291cmNlW10pOiBTb3VyY2VbXSB7XG4gIGNvbnN0IGZpbHRlcmVkU291cmNlcyA9IHNvdXJjZXMuZmlsdGVyKHNvdXJjZSA9PlxuICAgIHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgc291cmNlLnRleHQgJiZcbiAgICBzb3VyY2UudGV4dC5sZW5ndGggPiAxMDBcbiAgKTtcblxuICAvLyBUcnVuY2F0ZSBsb25nIHRleHRzIGFuZCBhZGQgbWV0YWRhdGFcbiAgcmV0dXJuIGZpbHRlcmVkU291cmNlcy5tYXAoc291cmNlID0+ICh7XG4gICAgLi4uc291cmNlLFxuICAgIHRleHQ6IHNvdXJjZS50ZXh0LnNsaWNlKDAsIDE1MDApLFxuICAgIHRpdGxlOiBleHRyYWN0VGl0bGUoc291cmNlLnVybClcbiAgfSkpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYSByZWFkYWJsZSB0aXRsZSBmcm9tIFVSTFxuICovXG5mdW5jdGlvbiBleHRyYWN0VGl0bGUodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIGNvbnN0IHsgaG9zdG5hbWUsIHBhdGhuYW1lIH0gPSBuZXcgVVJMKHVybCk7XG5cbiAgICAvLyBHZXQgZG9tYWluIHdpdGhvdXQgd3d3XG4gICAgY29uc3QgZG9tYWluID0gaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sICcnKTtcblxuICAgIC8vIEdldCBsYXN0IHBhdGggc2VnbWVudCB3aXRob3V0IGV4dGVuc2lvblxuICAgIGNvbnN0IHBhdGhTZWdtZW50ID0gcGF0aG5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbikucG9wKCkgfHwgJyc7XG4gICAgY29uc3QgY2xlYW5QYXRoU2VnbWVudCA9IHBhdGhTZWdtZW50LnJlcGxhY2UoL1xcLlxcdyskLywgJycpLnJlcGxhY2UoLy18Xy9nLCAnICcpO1xuXG4gICAgaWYgKGNsZWFuUGF0aFNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBgJHtjbGVhblBhdGhTZWdtZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2xlYW5QYXRoU2VnbWVudC5zbGljZSgxKX0gLSAke2RvbWFpbn1gO1xuICAgIH1cblxuICAgIHJldHVybiBkb21haW47XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbn1cblxuLyoqXG4gKiBTY3JhcGUgc291cmNlcyB3aXRoIHRpbWVvdXRcbiAqL1xuLyoqXG4gKiBBZHZhbmNlZCB3ZWIgc2NyYXBpbmcgd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXMgYW5kIHNtYXJ0IGNvbnRlbnQgZGV0ZWN0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjcmFwZVNvdXJjZXNXaXRoVGltZW91dChsaW5rczogc3RyaW5nW10pOiBQcm9taXNlPFNvdXJjZVtdPiB7XG4gIC8vIFVzZSBhIG1vcmUgY29udHJvbGxlZCBhcHByb2FjaCB3aXRoIGNvbmN1cnJlbmN5IGxpbWl0IGFuZCBwcmlvcml0aXphdGlvblxuICBjb25zdCBNQVhfQ09OQ1VSUkVOVCA9IDQ7XG4gIGNvbnN0IHJlc3VsdHM6IChTb3VyY2UgfCBudWxsKVtdID0gW107XG5cbiAgLy8gUHJpb3JpdGl6ZSBsaW5rcyBiYXNlZCBvbiBkb21haW4gcmVwdXRhdGlvbiBhbmQgVVJMIHN0cnVjdHVyZVxuICBjb25zdCBwcmlvcml0aXplZExpbmtzID0gcHJpb3JpdGl6ZUxpbmtzKFsuLi5saW5rc10pO1xuICBjb25zdCBwZW5kaW5nTGlua3MgPSBwcmlvcml0aXplZExpbmtzO1xuXG4gIGNvbnNvbGUubG9nKGBTY3JhcGluZyAke3BlbmRpbmdMaW5rcy5sZW5ndGh9IGxpbmtzIHdpdGggcHJpb3JpdHkgb3JkZXJgKTtcblxuICAvLyBQcm9jZXNzIGxpbmtzIGluIGJhdGNoZXMgdG8gY29udHJvbCBjb25jdXJyZW5jeVxuICB3aGlsZSAocGVuZGluZ0xpbmtzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBiYXRjaCA9IHBlbmRpbmdMaW5rcy5zcGxpY2UoMCwgTUFYX0NPTkNVUlJFTlQpO1xuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGJhdGNoIG9mICR7YmF0Y2gubGVuZ3RofSBsaW5rc2ApO1xuXG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBiYXRjaC5tYXAoYXN5bmMgKGxpbmspID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgbXVsdGlwbGUgZXh0cmFjdGlvbiB0ZWNobmlxdWVzXG4gICAgICAgICAgZm9yIChsZXQgdGVjaG5pcXVlID0gMDsgdGVjaG5pcXVlIDwgMzsgdGVjaG5pcXVlKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke2xpbmt9IHdpdGggdGVjaG5pcXVlICR7dGVjaG5pcXVlICsgMX1gKTtcblxuICAgICAgICAgICAgICAvLyBBZGp1c3QgdGltZW91dCBiYXNlZCBvbiB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgY29uc3QgdGVjaG5pcXVlVGltZW91dCA9IEZFVENIX1RJTUVPVVQgKyAodGVjaG5pcXVlICogNTAwMCk7XG5cbiAgICAgICAgICAgICAgLy8gVXNlIGRpZmZlcmVudCBmZXRjaCBvcHRpb25zIGJhc2VkIG9uIHRlY2huaXF1ZVxuICAgICAgICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCByZWZlcmVyIGZvciBzb21lIHRlY2huaXF1ZXNcbiAgICAgICAgICAgICAgICAgIC4uLih0ZWNobmlxdWUgPiAwID8geyAnUmVmZXJlcic6ICdodHRwczovL3d3dy5nb29nbGUuY29tLycgfSA6IHt9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQobGluaywgZmV0Y2hPcHRpb25zLCB0ZWNobmlxdWVUaW1lb3V0KTtcblxuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZmV0Y2ggJHtsaW5rfTogJHtyZXNwb25zZS5zdGF0dXN9LCB0ZWNobmlxdWUgJHt0ZWNobmlxdWUgKyAxfWApO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNlcnRhaW4gc3RhdHVzIGNvZGVzLCB3ZSBtaWdodCB3YW50IHRvIHNraXAgdG8gbmV4dCB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvciBvdGhlciBzdGF0dXMgY29kZXMsIHdlIG1pZ2h0IHdhbnQgdG8gdHJ5IGEgZGlmZmVyZW50IGFwcHJvYWNoXG4gICAgICAgICAgICAgICAgaWYgKHRlY2huaXF1ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVhazsgLy8gR2l2ZSB1cCBvbiB0aGlzIGxpbmsgYWZ0ZXIgYWxsIHRlY2huaXF1ZXMgZmFpbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCBjb250ZW50IHR5cGUgdG8gaGFuZGxlIGRpZmZlcmVudCB0eXBlcyBvZiBjb250ZW50XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuXG4gICAgICAgICAgICAgIC8vIFNraXAgbm9uLUhUTUwgY29udGVudFxuICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCd0ZXh0L2h0bWwnKSAmJlxuICAgICAgICAgICAgICAgICAgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSAmJlxuICAgICAgICAgICAgICAgICAgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCd0ZXh0L3BsYWluJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIG5vbi1IVE1MIGNvbnRlbnQ6ICR7Y29udGVudFR5cGV9IGZvciAke2xpbmt9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgICAgIC8vIFNraXAgaWYgd2UgZ290IGEgdmVyeSBzbWFsbCByZXNwb25zZSAobGlrZWx5IGFuIGVycm9yIHBhZ2UpXG4gICAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDgwMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gJHtsaW5rfTogJHtodG1sLmxlbmd0aH0gY2hhcnNgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb21tb24gZXJyb3IgcGF0dGVybnMgaW4gdGhlIEhUTUxcbiAgICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ2NhcHRjaGEnKSB8fFxuICAgICAgICAgICAgICAgICAgaHRtbC5pbmNsdWRlcygnQ0FQVENIQScpIHx8XG4gICAgICAgICAgICAgICAgICBodG1sLmluY2x1ZGVzKCdhY2Nlc3MgZGVuaWVkJykgfHxcbiAgICAgICAgICAgICAgICAgIGh0bWwuaW5jbHVkZXMoJ0FjY2VzcyBEZW5pZWQnKSB8fFxuICAgICAgICAgICAgICAgICAgaHRtbC5pbmNsdWRlcygnNDAzIEZvcmJpZGRlbicpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXRlY3RlZCBhY2Nlc3MgcmVzdHJpY3Rpb24gaW4gJHtsaW5rfWApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIEhUTUwgd2l0aCBkaWZmZXJlbnQgbWV0aG9kcyBiYXNlZCBvbiB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgbGV0IGV4dHJhY3RlZENvbnRlbnQ6IHsgdGV4dDogc3RyaW5nLCB0aXRsZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICAvLyBUZWNobmlxdWUgMTogVXNlIFJlYWRhYmlsaXR5XG4gICAgICAgICAgICAgIGlmICh0ZWNobmlxdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFdpdGhSZWFkYWJpbGl0eShodG1sLCBsaW5rKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRlY2huaXF1ZSAyOiBVc2UgY3VzdG9tIGNvbnRlbnQgZXh0cmFjdGlvblxuICAgICAgICAgICAgICBpZiAodGVjaG5pcXVlID09PSAxIHx8ICFleHRyYWN0ZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCA9IGF3YWl0IGV4dHJhY3RXaXRoQ3VzdG9tU2VsZWN0b3JzKGh0bWwsIGxpbmspO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVGVjaG5pcXVlIDM6IFVzZSBzaW1wbGlmaWVkIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgaWYgKHRlY2huaXF1ZSA9PT0gMiB8fCAhZXh0cmFjdGVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgPSBhd2FpdCBleHRyYWN0V2l0aFNpbXBsaWZpZWRNZXRob2QoaHRtbCwgbGluayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgaWYgKGV4dHJhY3RlZENvbnRlbnQgJiYgZXh0cmFjdGVkQ29udGVudC50ZXh0Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkICR7ZXh0cmFjdGVkQ29udGVudC50ZXh0Lmxlbmd0aH0gY2hhcnMgZnJvbSAke2xpbmt9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiBhbmQgcHJvY2VzcyB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSBwcm9jZXNzRXh0cmFjdGVkVGV4dChleHRyYWN0ZWRDb250ZW50LnRleHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHVybDogbGluayxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHByb2Nlc3NlZFRleHQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogZXh0cmFjdGVkQ29udGVudC50aXRsZSB8fCBleHRyYWN0VGl0bGUobGluaylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKHRlY2huaXF1ZUVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGVjaG5pcXVlICR7dGVjaG5pcXVlICsgMX0gZmFpbGVkIGZvciAke2xpbmt9OmAsIHRlY2huaXF1ZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBbGwgdGVjaG5pcXVlcyBmYWlsZWRcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbGwgZXh0cmFjdGlvbiB0ZWNobmlxdWVzIGZhaWxlZCBmb3IgJHtsaW5rfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNjcmFwaW5nICR7bGlua306YCwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXN1bHRzLnB1c2goLi4uYmF0Y2hSZXN1bHRzKTtcblxuICAgIC8vIElmIHdlIGhhdmUgZW5vdWdoIGdvb2QgcmVzdWx0cywgd2UgY2FuIHN0b3AgZWFybHlcbiAgICBjb25zdCB2YWxpZFJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihCb29sZWFuKSBhcyBTb3VyY2VbXTtcbiAgICBpZiAodmFsaWRSZXN1bHRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgR290ICR7dmFsaWRSZXN1bHRzLmxlbmd0aH0gZ29vZCByZXN1bHRzLCBzdG9wcGluZyBlYXJseWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlsdGVyIG91dCBudWxsIHJlc3VsdHMgYW5kIGVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IHNvbWUgY29udGVudFxuICBjb25zdCB2YWxpZFNvdXJjZXMgPSByZXN1bHRzLmZpbHRlcihCb29sZWFuKSBhcyBTb3VyY2VbXTtcblxuICAvLyBTb3J0IHNvdXJjZXMgYnkgY29udGVudCBxdWFsaXR5IChsZW5ndGggYW5kIHJlYWRhYmlsaXR5KVxuICBjb25zdCBzb3J0ZWRTb3VyY2VzID0gc29ydFNvdXJjZXNCeVF1YWxpdHkodmFsaWRTb3VyY2VzKTtcblxuICAvLyBJZiB3ZSBoYXZlIG5vIHZhbGlkIHNvdXJjZXMsIGNyZWF0ZSBpbnRlbGxpZ2VudCBmYWxsYmFjayBzb3VyY2VzXG4gIGlmIChzb3J0ZWRTb3VyY2VzLmxlbmd0aCA9PT0gMCAmJiBsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS5sb2coXCJObyB2YWxpZCBzb3VyY2VzIGZvdW5kLCBjcmVhdGluZyBmYWxsYmFjayBzb3VyY2VzXCIpO1xuICAgIHJldHVybiBjcmVhdGVGYWxsYmFja1NvdXJjZXMobGlua3MpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRlZFNvdXJjZXM7XG59XG5cbi8qKlxuICogUHJpb3JpdGl6ZSBsaW5rcyBiYXNlZCBvbiBkb21haW4gcmVwdXRhdGlvbiBhbmQgVVJMIHN0cnVjdHVyZVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplTGlua3MobGlua3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAvLyBTY29yZSBlYWNoIGxpbmtcbiAgY29uc3Qgc2NvcmVkTGlua3MgPSBsaW5rcy5tYXAobGluayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gICAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgICAvLyBQcmVmZXIgY2VydGFpbiBkb21haW5zXG4gICAgICBjb25zdCBob3N0bmFtZSA9IHVybC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAvLyBIaWdoZXIgc2NvcmUgZm9yIHJlcHV0YWJsZSBkb21haW5zXG4gICAgICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJy5lZHUnKSB8fFxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCcuZ292JykgfHxcbiAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnd2lraXBlZGlhLm9yZycpIHx8XG4gICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ2dpdGh1Yi5jb20nKSB8fFxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCdzdGFja292ZXJmbG93LmNvbScpIHx8XG4gICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ21lZGl1bS5jb20nKSkge1xuICAgICAgICBzY29yZSArPSAzMDtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlZmVyIHNob3J0ZXIgVVJMcyAob2Z0ZW4gbWFpbiBwYWdlcylcbiAgICAgIHNjb3JlIC09IHVybC5wYXRobmFtZS5zcGxpdCgnLycpLmxlbmd0aCAqIDI7XG5cbiAgICAgIC8vIFByZWZlciBVUkxzIHdpdGhvdXQgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAgc2NvcmUgLT0gdXJsLnNlYXJjaC5sZW5ndGggPiAwID8gNSA6IDA7XG5cbiAgICAgIC8vIEF2b2lkIGNlcnRhaW4gcGF0dGVybnNcbiAgICAgIGlmICh1cmwucGF0aG5hbWUuaW5jbHVkZXMoJ2xvZ2luJykgfHxcbiAgICAgICAgICB1cmwucGF0aG5hbWUuaW5jbHVkZXMoJ3NpZ251cCcpIHx8XG4gICAgICAgICAgdXJsLnBhdGhuYW1lLmluY2x1ZGVzKCdhY2NvdW50JykpIHtcbiAgICAgICAgc2NvcmUgLT0gMjA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGxpbmssIHNjb3JlIH07XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4geyBsaW5rLCBzY29yZTogLTEwMCB9OyAvLyBJbnZhbGlkIFVSTHMgZ2V0IGxvd2VzdCBwcmlvcml0eVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gU29ydCBieSBzY29yZSAoaGlnaGVzdCBmaXJzdClcbiAgc2NvcmVkTGlua3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuXG4gIC8vIFJldHVybiBqdXN0IHRoZSBsaW5rc1xuICByZXR1cm4gc2NvcmVkTGlua3MubWFwKGl0ZW0gPT4gaXRlbS5saW5rKTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbnRlbnQgdXNpbmcgTW96aWxsYSdzIFJlYWRhYmlsaXR5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RXaXRoUmVhZGFiaWxpdHkoaHRtbDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkb20gPSBuZXcgSlNET00oaHRtbCwge1xuICAgICAgdXJsLFxuICAgICAgcnVuU2NyaXB0czogXCJvdXRzaWRlLW9ubHlcIixcbiAgICAgIHByZXRlbmRUb0JlVmlzdWFsOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGFiaWxpdHkoZG9tLndpbmRvdy5kb2N1bWVudCk7XG4gICAgY29uc3QgYXJ0aWNsZSA9IHJlYWRlci5wYXJzZSgpO1xuXG4gICAgaWYgKGFydGljbGUgJiYgYXJ0aWNsZS50ZXh0Q29udGVudCAmJiBhcnRpY2xlLnRleHRDb250ZW50Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogYXJ0aWNsZS50ZXh0Q29udGVudCxcbiAgICAgICAgdGl0bGU6IGFydGljbGUudGl0bGUgfHwgZG9tLndpbmRvdy5kb2N1bWVudC50aXRsZSB8fCBleHRyYWN0VGl0bGUodXJsKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oYFJlYWRhYmlsaXR5IGV4dHJhY3Rpb24gZmFpbGVkIGZvciAke3VybH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBjb250ZW50IHVzaW5nIGN1c3RvbSBzZWxlY3RvcnMgZm9yIGRpZmZlcmVudCBzaXRlIHR5cGVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RXaXRoQ3VzdG9tU2VsZWN0b3JzKGh0bWw6IHN0cmluZywgdXJsOiBzdHJpbmcpOiBQcm9taXNlPHsgdGV4dDogc3RyaW5nLCB0aXRsZTogc3RyaW5nIH0gfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZG9tID0gbmV3IEpTRE9NKGh0bWwsIHsgdXJsIH0pO1xuICAgIGNvbnN0IGRvYyA9IGRvbS53aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAvLyBHZXQgdGhlIGhvc3RuYW1lIHRvIGFwcGx5IHNpdGUtc3BlY2lmaWMgc2VsZWN0b3JzXG4gICAgY29uc3QgaG9zdG5hbWUgPSBuZXcgVVJMKHVybCkuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIERlZmluZSBzZWxlY3RvcnMgZm9yIGRpZmZlcmVudCBzaXRlIHR5cGVzXG4gICAgbGV0IHNlbGVjdG9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFdpa2lwZWRpYS1zcGVjaWZpYyBzZWxlY3RvcnNcbiAgICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJ3dpa2lwZWRpYS5vcmcnKSkge1xuICAgICAgc2VsZWN0b3JzID0gWycjbXctY29udGVudC10ZXh0JywgJy5tdy1wYXJzZXItb3V0cHV0J107XG4gICAgfVxuICAgIC8vIEdpdEh1Yi1zcGVjaWZpYyBzZWxlY3RvcnNcbiAgICBlbHNlIGlmIChob3N0bmFtZS5pbmNsdWRlcygnZ2l0aHViLmNvbScpKSB7XG4gICAgICBzZWxlY3RvcnMgPSBbJy5tYXJrZG93bi1ib2R5JywgJ2FydGljbGUubWFya2Rvd24tYm9keScsICcucmVwb3NpdG9yeS1jb250ZW50J107XG4gICAgfVxuICAgIC8vIFN0YWNrT3ZlcmZsb3ctc3BlY2lmaWMgc2VsZWN0b3JzXG4gICAgZWxzZSBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJ3N0YWNrb3ZlcmZsb3cuY29tJykpIHtcbiAgICAgIHNlbGVjdG9ycyA9IFsnLnBvc3QtdGV4dCcsICcuYW5zd2VyJ107XG4gICAgfVxuICAgIC8vIE5ld3Mgc2l0ZSBzZWxlY3RvcnNcbiAgICBlbHNlIGlmIChob3N0bmFtZS5pbmNsdWRlcygnbmV3cycpIHx8XG4gICAgICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ2JiYycpIHx8XG4gICAgICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ2NubicpIHx8XG4gICAgICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ255dGltZXMnKSkge1xuICAgICAgc2VsZWN0b3JzID0gWycuYXJ0aWNsZS1ib2R5JywgJy5zdG9yeS1ib2R5JywgJy5hcnRpY2xlX19jb250ZW50JywgJ1tpdGVtcHJvcD1cImFydGljbGVCb2R5XCJdJ107XG4gICAgfVxuICAgIC8vIERlZmF1bHQgY29udGVudCBzZWxlY3RvcnNcbiAgICBlbHNlIHtcbiAgICAgIHNlbGVjdG9ycyA9IFtcbiAgICAgICAgJ21haW4nLCAnYXJ0aWNsZScsICdbcm9sZT1cIm1haW5cIl0nLCAnI2NvbnRlbnQnLCAnLmNvbnRlbnQnLFxuICAgICAgICAnLnBvc3QtY29udGVudCcsICcuZW50cnktY29udGVudCcsICcuYXJ0aWNsZS1jb250ZW50JywgJy5wb3N0LWJvZHknLFxuICAgICAgICAnLnBhZ2UtY29udGVudCcsICcubWFpbi1jb250ZW50JywgJy5ib2R5LWNvbnRlbnQnXG4gICAgICBdO1xuICAgIH1cblxuICAgIC8vIFRyeSBlYWNoIHNlbGVjdG9yXG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29tYmluZSB0ZXh0IGZyb20gYWxsIG1hdGNoaW5nIGVsZW1lbnRzXG4gICAgICAgIGxldCBjb21iaW5lZFRleHQgPSAnJztcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgY29tYmluZWRUZXh0ICs9IGVsLnRleHRDb250ZW50ICsgJ1xcblxcbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb21iaW5lZFRleHQubGVuZ3RoID4gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGNvbWJpbmVkVGV4dCxcbiAgICAgICAgICAgIHRpdGxlOiBkb2MudGl0bGUgfHwgZXh0cmFjdFRpdGxlKHVybClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gY29udGVudCBmb3VuZCB3aXRoIHNlbGVjdG9ycywgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3QgdGV4dCBibG9ja1xuICAgIGNvbnN0IHRleHRCbG9ja3MgPSBmaW5kTGFyZ2VzdFRleHRCbG9ja3MoZG9jKTtcbiAgICBpZiAodGV4dEJsb2NrcyAmJiB0ZXh0QmxvY2tzLmxlbmd0aCA+IDIwMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dEJsb2NrcyxcbiAgICAgICAgdGl0bGU6IGRvYy50aXRsZSB8fCBleHRyYWN0VGl0bGUodXJsKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oYEN1c3RvbSBleHRyYWN0aW9uIGZhaWxlZCBmb3IgJHt1cmx9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgY29udGVudCB1c2luZyBhIHNpbXBsaWZpZWQgbWV0aG9kIChmYWxsYmFjaylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFdpdGhTaW1wbGlmaWVkTWV0aG9kKGh0bWw6IHN0cmluZywgdXJsOiBzdHJpbmcpOiBQcm9taXNlPHsgdGV4dDogc3RyaW5nLCB0aXRsZTogc3RyaW5nIH0gfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGNoZWVyaW8gZm9yIGxpZ2h0d2VpZ2h0IHBhcnNpbmdcbiAgICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xuXG4gICAgLy8gUmVtb3ZlIHNjcmlwdCwgc3R5bGUsIG5hdiwgZm9vdGVyLCBhbmQgb3RoZXIgbm9uLWNvbnRlbnQgZWxlbWVudHNcbiAgICAkKCdzY3JpcHQsIHN0eWxlLCBuYXYsIGZvb3RlciwgaGVhZGVyLCBhc2lkZSwgLnNpZGViYXIsIC5mb290ZXIsIC5oZWFkZXIsIC5uYXZpZ2F0aW9uLCAubmF2LCAubWVudSwgLmNvbW1lbnRzLCAuYWRzLCAuYWQnKS5yZW1vdmUoKTtcblxuICAgIC8vIEdldCB0aGUgdGl0bGVcbiAgICBjb25zdCB0aXRsZSA9ICQoJ3RpdGxlJykudGV4dCgpIHx8IGV4dHJhY3RUaXRsZSh1cmwpO1xuXG4gICAgLy8gR2V0IGFsbCBwYXJhZ3JhcGhzXG4gICAgY29uc3QgcGFyYWdyYXBoczogc3RyaW5nW10gPSBbXTtcbiAgICAkKCdwJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSAkKGVsKS50ZXh0KCkudHJpbSgpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMjApIHsgLy8gT25seSBpbmNsdWRlIHN1YnN0YW50aWFsIHBhcmFncmFwaHNcbiAgICAgICAgcGFyYWdyYXBocy5wdXNoKHRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgd2UgZm91bmQgcGFyYWdyYXBocywgam9pbiB0aGVtXG4gICAgaWYgKHBhcmFncmFwaHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogcGFyYWdyYXBocy5qb2luKCdcXG5cXG4nKSxcbiAgICAgICAgdGl0bGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2s6IGdldCBhbGwgdGV4dCBmcm9tIGJvZHlcbiAgICBjb25zdCBib2R5VGV4dCA9ICQoJ2JvZHknKS50ZXh0KCk7XG4gICAgaWYgKGJvZHlUZXh0Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgLy8gQ2xlYW4gdXAgdGhlIHRleHRcbiAgICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gYm9keVRleHRcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAyMClcbiAgICAgICAgLmpvaW4oJ1xcblxcbicpO1xuXG4gICAgICBpZiAoY2xlYW5lZFRleHQubGVuZ3RoID4gMjAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGV4dDogY2xlYW5lZFRleHQsXG4gICAgICAgICAgdGl0bGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oYFNpbXBsaWZpZWQgZXh0cmFjdGlvbiBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBsYXJnZXN0IHRleHQgYmxvY2tzIGluIGEgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gZmluZExhcmdlc3RUZXh0QmxvY2tzKGRvYzogRG9jdW1lbnQpOiBzdHJpbmcge1xuICAvLyBHZXQgYWxsIGVsZW1lbnRzIHdpdGggc3Vic3RhbnRpYWwgdGV4dFxuICBjb25zdCB0ZXh0RWxlbWVudHM6IHtlbGVtZW50OiBFbGVtZW50LCBsZW5ndGg6IG51bWJlcn1bXSA9IFtdO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgZWxlbWVudHNcbiAgZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudDogRWxlbWVudCkge1xuICAgIC8vIFNraXAgY2VydGFpbiBlbGVtZW50c1xuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoWydzY3JpcHQnLCAnc3R5bGUnLCAnbmF2JywgJ2hlYWRlcicsICdmb290ZXInXS5pbmNsdWRlcyh0YWdOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgZWxlbWVudCBoYXMgZGlyZWN0IHRleHRcbiAgICBjb25zdCBkaXJlY3RUZXh0ID0gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpXG4gICAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMykgLy8gVGV4dCBub2RlcyBvbmx5XG4gICAgICAubWFwKG5vZGUgPT4gbm9kZS50ZXh0Q29udGVudCB8fCAnJylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLnRyaW0oKTtcblxuICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgc3Vic3RhbnRpYWwgZGlyZWN0IHRleHQsIGFkZCBpdFxuICAgIGlmIChkaXJlY3RUZXh0Lmxlbmd0aCA+IDUwKSB7XG4gICAgICB0ZXh0RWxlbWVudHMucHVzaCh7ZWxlbWVudCwgbGVuZ3RoOiBkaXJlY3RUZXh0Lmxlbmd0aH0pO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgY2hpbGRyZW5cbiAgICBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2gocHJvY2Vzc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gU3RhcnQgcHJvY2Vzc2luZyBmcm9tIGJvZHlcbiAgcHJvY2Vzc0VsZW1lbnQoZG9jLmJvZHkpO1xuXG4gIC8vIFNvcnQgYnkgdGV4dCBsZW5ndGggKGxhcmdlc3QgZmlyc3QpXG4gIHRleHRFbGVtZW50cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcblxuICAvLyBUYWtlIHRoZSB0b3AgZWxlbWVudHMgdGhhdCBsaWtlbHkgY29udGFpbiBtYWluIGNvbnRlbnRcbiAgY29uc3QgbWFpbkNvbnRlbnRFbGVtZW50cyA9IHRleHRFbGVtZW50cy5zbGljZSgwLCAxMCk7XG5cbiAgLy8gRXh0cmFjdCBhbmQgam9pbiB0aGVpciB0ZXh0XG4gIHJldHVybiBtYWluQ29udGVudEVsZW1lbnRzXG4gICAgLm1hcChpdGVtID0+IGl0ZW0uZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJylcbiAgICAuam9pbignXFxuXFxuJyk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbmQgY2xlYW4gZXh0cmFjdGVkIHRleHRcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V4dHJhY3RlZFRleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSB3aGl0ZXNwYWNlXG4gIGxldCBwcm9jZXNzZWQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAvLyBTcGxpdCBpbnRvIGxpbmVzIGFuZCBjbGVhbiBlYWNoIGxpbmVcbiAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSlcbiAgICAuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAwKVxuICAgIC5qb2luKCdcXG4nKTtcblxuICAvLyBSZW1vdmUgZHVwbGljYXRlIHBhcmFncmFwaHNcbiAgY29uc3QgcGFyYWdyYXBocyA9IHByb2Nlc3NlZC5zcGxpdCgnXFxuXFxuJyk7XG4gIGNvbnN0IHVuaXF1ZVBhcmFncmFwaHMgPSBBcnJheS5mcm9tKG5ldyBTZXQocGFyYWdyYXBocykpO1xuICBwcm9jZXNzZWQgPSB1bmlxdWVQYXJhZ3JhcGhzLmpvaW4oJ1xcblxcbicpO1xuXG4gIC8vIExpbWl0IGxlbmd0aCB0byBhdm9pZCBleHRyZW1lbHkgbG9uZyB0ZXh0c1xuICBpZiAocHJvY2Vzc2VkLmxlbmd0aCA+IDgwMDApIHtcbiAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQuc3Vic3RyaW5nKDAsIDgwMDApICsgJy4uLic7XG4gIH1cblxuICByZXR1cm4gcHJvY2Vzc2VkO1xufVxuXG4vKipcbiAqIFNvcnQgc291cmNlcyBieSBxdWFsaXR5XG4gKi9cbmZ1bmN0aW9uIHNvcnRTb3VyY2VzQnlRdWFsaXR5KHNvdXJjZXM6IFNvdXJjZVtdKTogU291cmNlW10ge1xuICByZXR1cm4gWy4uLnNvdXJjZXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAvLyBDYWxjdWxhdGUgcXVhbGl0eSBzY29yZSBiYXNlZCBvbiB0ZXh0IGxlbmd0aCBhbmQgb3RoZXIgZmFjdG9yc1xuICAgIGNvbnN0IHNjb3JlQSA9IGNhbGN1bGF0ZUNvbnRlbnRRdWFsaXR5U2NvcmUoYSk7XG4gICAgY29uc3Qgc2NvcmVCID0gY2FsY3VsYXRlQ29udGVudFF1YWxpdHlTY29yZShiKTtcblxuICAgIHJldHVybiBzY29yZUIgLSBzY29yZUE7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjb250ZW50IHF1YWxpdHkgc2NvcmVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29udGVudFF1YWxpdHlTY29yZShzb3VyY2U6IFNvdXJjZSk6IG51bWJlciB7XG4gIGxldCBzY29yZSA9IDA7XG5cbiAgLy8gTGVuZ3RoIGlzIGEgcHJpbWFyeSBmYWN0b3JcbiAgc2NvcmUgKz0gTWF0aC5taW4oc291cmNlLnRleHQubGVuZ3RoIC8gMTAwLCA1MCk7XG5cbiAgLy8gUHJlZmVyIHNvdXJjZXMgd2l0aCB0aXRsZXNcbiAgc2NvcmUgKz0gc291cmNlLnRpdGxlID8gMTAgOiAwO1xuXG4gIC8vIFByZWZlciBzb3VyY2VzIGZyb20gcmVwdXRhYmxlIGRvbWFpbnNcbiAgdHJ5IHtcbiAgICBjb25zdCBob3N0bmFtZSA9IG5ldyBVUkwoc291cmNlLnVybCkuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJy5lZHUnKSB8fFxuICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnLmdvdicpIHx8XG4gICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCd3aWtpcGVkaWEub3JnJykpIHtcbiAgICAgIHNjb3JlICs9IDIwO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gSW52YWxpZCBVUkxcbiAgfVxuXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgZmFsbGJhY2sgc291cmNlcyB3aGVuIGV4dHJhY3Rpb24gZmFpbHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tTb3VyY2VzKGxpbmtzOiBzdHJpbmdbXSk6IFNvdXJjZVtdIHtcbiAgLy8gQ3JlYXRlIGF0IGxlYXN0IG9uZSBmYWxsYmFjayBzb3VyY2VcbiAgY29uc3QgZmFsbGJhY2tTb3VyY2VzOiBTb3VyY2VbXSA9IFtdO1xuXG4gIC8vIFRyeSB0byBjcmVhdGUgc291cmNlcyBmcm9tIHRoZSB0b3AgMyBsaW5rc1xuICBjb25zdCB0b3BMaW5rcyA9IGxpbmtzLnNsaWNlKDAsIDMpO1xuXG4gIGZvciAoY29uc3QgbGluayBvZiB0b3BMaW5rcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkb21haW4gPSBuZXcgVVJMKGxpbmspLmhvc3RuYW1lLnJlcGxhY2UoJ3d3dy4nLCAnJyk7XG5cbiAgICAgIGZhbGxiYWNrU291cmNlcy5wdXNoKHtcbiAgICAgICAgdXJsOiBsaW5rLFxuICAgICAgICB0ZXh0OiBgVGhpcyBpbmZvcm1hdGlvbiBpcyBmcm9tICR7ZG9tYWlufS4gVGhlIGNvbnRlbnQgY291bGQgbm90IGJlIGZ1bGx5IGV4dHJhY3RlZCBkdWUgdG8gd2Vic2l0ZSByZXN0cmljdGlvbnMuIFBsZWFzZSB2aXNpdCB0aGUgd2Vic2l0ZSBkaXJlY3RseSBmb3IgY29tcGxldGUgaW5mb3JtYXRpb24uYCxcbiAgICAgICAgdGl0bGU6IGBJbmZvcm1hdGlvbiBmcm9tICR7ZG9tYWlufWBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBjb3VsZG4ndCBjcmVhdGUgYW55IGZhbGxiYWNrIHNvdXJjZXMsIGNyZWF0ZSBhIGdlbmVyaWMgb25lXG4gIGlmIChmYWxsYmFja1NvdXJjZXMubGVuZ3RoID09PSAwICYmIGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICBmYWxsYmFja1NvdXJjZXMucHVzaCh7XG4gICAgICB1cmw6IGxpbmtzWzBdLFxuICAgICAgdGV4dDogYEluZm9ybWF0aW9uIGNvdWxkIG5vdCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgc291cmNlcy4gVGhpcyBtaWdodCBiZSBkdWUgdG8gd2Vic2l0ZSByZXN0cmljdGlvbnMgb3IgdGVjaG5pY2FsIGxpbWl0YXRpb25zLiBUcnkgcmVmaW5pbmcgeW91ciBzZWFyY2ggcXVlcnkgb3IgdmlzaXRpbmcgdGhlIHdlYnNpdGVzIGRpcmVjdGx5LmAsXG4gICAgICB0aXRsZTogYFNlYXJjaCBSZXN1bHRzYFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrU291cmNlcztcbn1cblxuLyoqXG4gKiBBZHZhbmNlZCBHb29nbGUgc2VhcmNoIHdpdGggbXVsdGlwbGUgZXh0cmFjdGlvbiB0ZWNobmlxdWVzIGFuZCBmYWxsYmFja3NcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0R29vZ2xlTGlua3MocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIEdvb2dsZSBzZWFyY2ggcmVxdWVzdCBmb3I6IFwiJHtxdWVyeX1cImApO1xuXG4gICAgLy8gVHJ5IG11bHRpcGxlIHNlYXJjaCB2YXJpYXRpb25zIHRvIGltcHJvdmUgcmVzdWx0c1xuICAgIGNvbnN0IHNlYXJjaFZhcmlhdGlvbnMgPSBbXG4gICAgICAvLyBTdGFuZGFyZCBzZWFyY2hcbiAgICAgIGBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mbnVtPTMwYCxcbiAgICAgIC8vIFNlYXJjaCB3aXRoIHZlcmJhdGltIG9wdGlvbiB0byBnZXQgZXhhY3QgbWF0Y2hlc1xuICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZudW09MjAmdGJzPWxpOjFgLFxuICAgICAgLy8gU2VhcmNoIHdpdGggcmVjZW50IHJlc3VsdHNcbiAgICAgIGBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mbnVtPTIwJnRicz1xZHI6eWBcbiAgICBdO1xuXG4gICAgbGV0IGFsbExpbmtzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gVHJ5IGVhY2ggc2VhcmNoIHZhcmlhdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoVmFyaWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFsbExpbmtzLmxlbmd0aCA+PSAxNSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWxyZWFkeSBmb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gbGlua3MsIHNraXBwaW5nIHJlbWFpbmluZyB2YXJpYXRpb25zYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWFyY2hVcmwgPSBzZWFyY2hWYXJpYXRpb25zW2ldO1xuICAgICAgICBjb25zb2xlLmxvZyhgVHJ5aW5nIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX06ICR7c2VhcmNoVXJsfWApO1xuXG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gbWltaWMgYSByZWFsIGJyb3dzZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxuICAgICAgICAgIHNlYXJjaFVybCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxuICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC41JyxcbiAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8nLFxuICAgICAgICAgICAgICAnRE5UJzogJzEnLFxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ21heC1hZ2U9MCcsXG4gICAgICAgICAgICAgICdzZWMtY2gtdWEnOiAnXCJHb29nbGUgQ2hyb21lXCI7dj1cIjEwNVwiLCBcIk5vdClBO0JyYW5kXCI7dj1cIjhcIiwgXCJDaHJvbWl1bVwiO3Y9XCIxMDVcIicsXG4gICAgICAgICAgICAgICdzZWMtY2gtdWEtbW9iaWxlJzogJz8wJyxcbiAgICAgICAgICAgICAgJ3NlYy1jaC11YS1wbGF0Zm9ybSc6ICdcIldpbmRvd3NcIidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgR29vZ2xlIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX0gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgZ290IGEgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgaWYgKGh0bWwubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gR29vZ2xlIHZhcmlhdGlvbiAke2kgKyAxfTogJHtodG1sLmxlbmd0aH0gY2hhcnNgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChodG1sLmluY2x1ZGVzKFwidW51c3VhbCB0cmFmZmljXCIpIHx8XG4gICAgICAgICAgICBodG1sLmluY2x1ZGVzKFwiQ0FQVENIQVwiKSB8fFxuICAgICAgICAgICAgaHRtbC5pbmNsdWRlcyhcImRldGVjdGVkIHVudXN1YWwgdHJhZmZpY1wiKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgR29vZ2xlIHZhcmlhdGlvbiAke2kgKyAxfSBibG9ja2VkIG9yIHJldHVybmVkIGEgQ0FQVENIQWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyB1c2luZyBtdWx0aXBsZSBtZXRob2RzXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzID0gZXh0cmFjdEdvb2dsZUxpbmtzKGh0bWwpO1xuXG4gICAgICAgIGlmIChleHRyYWN0ZWRMaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIEdvb2dsZSB2YXJpYXRpb24gJHtpICsgMX1gKTtcblxuICAgICAgICAgIC8vIEFkZCBuZXcgdW5pcXVlIGxpbmtzXG4gICAgICAgICAgZXh0cmFjdGVkTGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgIGlmICghYWxsTGlua3MuaW5jbHVkZXMobGluaykpIHtcbiAgICAgICAgICAgICAgYWxsTGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmFyaWF0aW9uRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2l0aCBHb29nbGUgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTpgLCB2YXJpYXRpb25FcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGFuZCBjbGVhbiB0aGUgbGlua3NcbiAgICBjb25zdCBmaWx0ZXJlZExpbmtzID0gZmlsdGVyQW5kQ2xlYW5MaW5rcyhhbGxMaW5rcyk7XG5cbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZExpbmtzLmxlbmd0aH0gdW5pcXVlIHZhbGlkIGxpbmtzIGZyb20gR29vZ2xlYCk7XG4gICAgcmV0dXJuIGZpbHRlcmVkTGlua3M7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIEdvb2dsZSBsaW5rczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgbGlua3MgZnJvbSBHb29nbGUgc2VhcmNoIHJlc3VsdHMgSFRNTCB1c2luZyBtdWx0aXBsZSBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RHb29nbGVMaW5rcyhodG1sOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XG4gIGxldCBsaW5rczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBNZXRob2QgMTogU3RhbmRhcmQgR29vZ2xlIHNlYXJjaCByZXN1bHRzIC0gbG9vayBmb3IgcmVkaXJlY3RzXG4gICQoXCJhXCIpLmVhY2goKF8sIGxpbmspID0+IHtcbiAgICBjb25zdCBocmVmID0gJChsaW5rKS5hdHRyKFwiaHJlZlwiKTtcbiAgICBpZiAoaHJlZiAmJiBocmVmLnN0YXJ0c1dpdGgoXCIvdXJsP3E9XCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IGRlY29kZVVSSUNvbXBvbmVudChocmVmLnJlcGxhY2UoXCIvdXJsP3E9XCIsIFwiXCIpLnNwbGl0KFwiJlwiKVswXSk7XG4gICAgICAgIGlmIChpc1ZhbGlkVXJsKGNsZWFuZWRIcmVmKSAmJiAhbGlua3MuaW5jbHVkZXMoY2xlYW5lZEhyZWYpKSB7XG4gICAgICAgICAgbGlua3MucHVzaChjbGVhbmVkSHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ldGhvZCAyOiBMb29rIGZvciByZXN1bHQgY29udGFpbmVycyBhbmQgZXh0cmFjdCBsaW5rc1xuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgR29vZ2xlIGV4dHJhY3Rpb24gbWV0aG9kIDJcIik7XG5cbiAgICAvLyBNb2Rlcm4gR29vZ2xlIHNlbGVjdG9yc1xuICAgICQoXCIuZyAueXVSVWJmID4gYSwgLmcgLnJjID4gYSwgLmcgaDMuciA+IGEsIC50RjJDeGMgPiBkaXYueXVSVWJmID4gYSwgLmhsY3cwYyAueXVSVWJmID4gYVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gJChlbGVtZW50KS5hdHRyKFwiaHJlZlwiKTtcbiAgICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XG4gICAgICAgIGxpbmtzLnB1c2goaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBNZXRob2QgMzogRXh0cmFjdCBmcm9tIGNpdGUgZWxlbWVudHNcbiAgaWYgKGxpbmtzLmxlbmd0aCA8IDUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlVzaW5nIEdvb2dsZSBleHRyYWN0aW9uIG1ldGhvZCAzXCIpO1xuXG4gICAgJChcIi5pVWgzMCwgLnRqdmN4LCAucXpFb1VlXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudExpbmsgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoXCJhXCIpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgaWYgKHBhcmVudExpbmsgJiYgcGFyZW50TGluay5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMocGFyZW50TGluaykpIHtcbiAgICAgICAgbGlua3MucHVzaChwYXJlbnRMaW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgVVJMIGZyb20gY2l0ZSB0ZXh0XG4gICAgICAgIGNvbnN0IGNpdGVUZXh0ID0gJChlbGVtZW50KS50ZXh0KCkudHJpbSgpO1xuICAgICAgICBpZiAoY2l0ZVRleHQgJiYgIWNpdGVUZXh0LmluY2x1ZGVzKFwiLi4uXCIpICYmIGNpdGVUZXh0LmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gY2l0ZVRleHQ7XG4gICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vXCIgKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZFVybCh1cmwpICYmICFsaW5rcy5pbmNsdWRlcyh1cmwpKSB7XG4gICAgICAgICAgICAgIGxpbmtzLnB1c2godXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWV0aG9kIDQ6IExhc3QgcmVzb3J0IC0gZmluZCBhbnkgZXh0ZXJuYWwgbGlua3NcbiAgaWYgKGxpbmtzLmxlbmd0aCA8IDMpIHtcbiAgICBjb25zb2xlLmxvZyhcIlVzaW5nIEdvb2dsZSBleHRyYWN0aW9uIG1ldGhvZCA0IChsYXN0IHJlc29ydClcIik7XG5cbiAgICAkKFwiYVtocmVmXj0naHR0cCddXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgaWYgKGhyZWYgJiZcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcImdvb2dsZS5jb21cIikgJiZcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcImFjY291bnRzLlwiKSAmJlxuICAgICAgICAgICFocmVmLmluY2x1ZGVzKFwic3VwcG9ydC5cIikgJiZcbiAgICAgICAgICBpc1ZhbGlkVXJsKGhyZWYpICYmXG4gICAgICAgICAgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XG4gICAgICAgIGxpbmtzLnB1c2goaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGlua3M7XG59XG5cbi8qKlxuICogRmlsdGVyIGFuZCBjbGVhbiBhIGxpc3Qgb2YgVVJMc1xuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmRDbGVhbkxpbmtzKGxpbmtzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgbGV0IHVuaXF1ZUxpbmtzID0gQXJyYXkuZnJvbShuZXcgU2V0KGxpbmtzKSk7XG5cbiAgLy8gRmlsdGVyIG91dCBpbnZhbGlkIGFuZCB1bndhbnRlZCBVUkxzXG4gIHVuaXF1ZUxpbmtzID0gdW5pcXVlTGlua3MuZmlsdGVyKGxpbmsgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGxpbmspO1xuICAgICAgY29uc3QgaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgLy8gRmlsdGVyIG91dCBjb21tb24gbm9uLWNvbnRlbnQgZG9tYWluc1xuICAgICAgY29uc3QgaW52YWxpZERvbWFpbnMgPSBbXG4gICAgICAgICdnb29nbGUuY29tJywgJ3lvdXR1YmUuY29tJywgJ2ZhY2Vib29rLmNvbScsICd0d2l0dGVyLmNvbScsICdpbnN0YWdyYW0uY29tJyxcbiAgICAgICAgJ2xpbmtlZGluLmNvbScsICdwaW50ZXJlc3QuY29tJywgJ2FtYXpvbi5jb20nLCAnZWJheS5jb20nLCAnbmV0ZmxpeC5jb20nLFxuICAgICAgICAnYXBwbGUuY29tJywgJ21pY3Jvc29mdC5jb20nLCAncGxheS5nb29nbGUuY29tJywgJ2FjY291bnRzLmdvb2dsZS5jb20nLFxuICAgICAgICAnc3VwcG9ydC5nb29nbGUuY29tJywgJ21hcHMuZ29vZ2xlLmNvbScsICdwb2xpY2llcy5nb29nbGUuY29tJyxcbiAgICAgICAgJ3RyYW5zbGF0ZS5nb29nbGUuY29tJywgJ2Nocm9tZS5nb29nbGUuY29tJywgJ2RvY3MuZ29vZ2xlLmNvbScsXG4gICAgICAgICdkcml2ZS5nb29nbGUuY29tJywgJ21haWwuZ29vZ2xlLmNvbScsICdjYWxlbmRhci5nb29nbGUuY29tJ1xuICAgICAgXTtcblxuICAgICAgaWYgKGludmFsaWREb21haW5zLnNvbWUoZG9tYWluID0+IGhvc3RuYW1lLmluY2x1ZGVzKGRvbWFpbikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIG91dCBVUkxzIHdpdGggY2VydGFpbiBwYXR0ZXJuc1xuICAgICAgY29uc3QgaW52YWxpZFBhdHRlcm5zID0gW1xuICAgICAgICAnL3NlYXJjaD8nLCAnL2xvZ2luJywgJy9zaWduaW4nLCAnL3NpZ251cCcsICcvcmVnaXN0ZXInLFxuICAgICAgICAnL2FjY291bnQnLCAnL2NhcnQnLCAnL2NoZWNrb3V0JywgJy9wcml2YWN5JywgJy90ZXJtcycsXG4gICAgICAgICcvY29udGFjdCcsICcvYWJvdXQnLCAnL2hlbHAnLCAnL3N1cHBvcnQnLCAnL2ZhcScsXG4gICAgICAgICcvZG93bmxvYWQnLCAnL3N1YnNjcmliZScsICcvbWVtYmVyc2hpcCcsICcvcHJpY2luZydcbiAgICAgIF07XG5cbiAgICAgIGlmIChpbnZhbGlkUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHVybC5wYXRobmFtZS5pbmNsdWRlcyhwYXR0ZXJuKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIExpbWl0IHRvIGEgcmVhc29uYWJsZSBudW1iZXJcbiAgcmV0dXJuIHVuaXF1ZUxpbmtzLnNsaWNlKDAsIDIwKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIFVSTCBhbmQgbWVldHMgY29udGVudCBjcml0ZXJpYVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlZCBCaW5nIHNlYXJjaCB3aXRoIG11bHRpcGxlIGV4dHJhY3Rpb24gdGVjaG5pcXVlc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRCaW5nTGlua3MocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIEJpbmcgc2VhcmNoIHJlcXVlc3QgZm9yOiBcIiR7cXVlcnl9XCJgKTtcblxuICAgIC8vIFRyeSBtdWx0aXBsZSBzZWFyY2ggdmFyaWF0aW9uc1xuICAgIGNvbnN0IHNlYXJjaFZhcmlhdGlvbnMgPSBbXG4gICAgICAvLyBTdGFuZGFyZCBzZWFyY2hcbiAgICAgIGBodHRwczovL3d3dy5iaW5nLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmNvdW50PTMwYCxcbiAgICAgIC8vIFNlYXJjaCB3aXRoIG5ld3NcbiAgICAgIGBodHRwczovL3d3dy5iaW5nLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmZpbHRlcnM9bmV3c2AsXG4gICAgICAvLyBTZWFyY2ggd2l0aCBmcmVzaG5lc3MgZmlsdGVyXG4gICAgICBgaHR0cHM6Ly93d3cuYmluZy5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZmaWx0ZXJzPWV4MSUzYVwiZXo1XCJgXG4gICAgXTtcblxuICAgIGxldCBhbGxMaW5rczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFRyeSBlYWNoIHNlYXJjaCB2YXJpYXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaFZhcmlhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbGxMaW5rcy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFscmVhZHkgZm91bmQgJHthbGxMaW5rcy5sZW5ndGh9IGxpbmtzIGZyb20gQmluZywgc2tpcHBpbmcgcmVtYWluaW5nIHZhcmlhdGlvbnNgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IHNlYXJjaFZhcmlhdGlvbnNbaV07XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcnlpbmcgQmluZyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OiAke3NlYXJjaFVybH1gKTtcblxuICAgICAgICAvLyBBZGQgaGVhZGVycyB0byBtaW1pYyBhIHJlYWwgYnJvd3NlclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICAgICAgc2VhcmNoVXJsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCcsXG4gICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjUnLFxuICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5iaW5nLmNvbS8nLFxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ21heC1hZ2U9MCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQmluZyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCBhIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDEwMDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFRvbyBzbWFsbCByZXNwb25zZSBmcm9tIEJpbmcgdmFyaWF0aW9uICR7aSArIDF9OiAke2h0bWwubGVuZ3RofSBjaGFyc2ApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyB1c2luZyBtdWx0aXBsZSBtZXRob2RzXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzID0gZXh0cmFjdEJpbmdMaW5rcyhodG1sKTtcblxuICAgICAgICBpZiAoZXh0cmFjdGVkTGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2V4dHJhY3RlZExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBCaW5nIHZhcmlhdGlvbiAke2kgKyAxfWApO1xuXG4gICAgICAgICAgLy8gQWRkIG5ldyB1bmlxdWUgbGlua3NcbiAgICAgICAgICBleHRyYWN0ZWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbGxMaW5rcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2YXJpYXRpb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aXRoIEJpbmcgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTpgLCB2YXJpYXRpb25FcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGFuZCBjbGVhbiB0aGUgbGlua3NcbiAgICBjb25zdCBmaWx0ZXJlZExpbmtzID0gZmlsdGVyQW5kQ2xlYW5MaW5rcyhhbGxMaW5rcyk7XG5cbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZExpbmtzLmxlbmd0aH0gdW5pcXVlIHZhbGlkIGxpbmtzIGZyb20gQmluZ2ApO1xuICAgIHJldHVybiBmaWx0ZXJlZExpbmtzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBCaW5nIGxpbmtzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBsaW5rcyBmcm9tIEJpbmcgc2VhcmNoIHJlc3VsdHMgSFRNTFxuICovXG5mdW5jdGlvbiBleHRyYWN0QmluZ0xpbmtzKGh0bWw6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgJCA9IGNoZWVyaW8ubG9hZChodG1sKTtcbiAgbGV0IGxpbmtzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIE1ldGhvZCAxOiBFeHRyYWN0IGZyb20gbWFpbiBzZWFyY2ggcmVzdWx0c1xuICAkKFwiLmJfYWxnbyBoMiBhXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBocmVmID0gJChlbGVtZW50KS5hdHRyKFwiaHJlZlwiKTtcbiAgICBpZiAoaHJlZiAmJiBocmVmLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmICFsaW5rcy5pbmNsdWRlcyhocmVmKSkge1xuICAgICAgbGlua3MucHVzaChocmVmKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ldGhvZCAyOiBFeHRyYWN0IGZyb20gY2l0ZSBlbGVtZW50c1xuICAkKFwiLmJfY2FwdGlvbiBjaXRlXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnRMaW5rID0gJChlbGVtZW50KS5jbG9zZXN0KFwiLmJfYWxnb1wiKS5maW5kKFwiaDIgYVwiKS5hdHRyKFwiaHJlZlwiKTtcbiAgICBpZiAocGFyZW50TGluayAmJiBwYXJlbnRMaW5rLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmICFsaW5rcy5pbmNsdWRlcyhwYXJlbnRMaW5rKSkge1xuICAgICAgbGlua3MucHVzaChwYXJlbnRMaW5rKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ldGhvZCAzOiBFeHRyYWN0IGZyb20gZGVlcCBsaW5rc1xuICAkKFwiLmJfZGVlcGxpbmtzIGFcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XG4gICAgICBsaW5rcy5wdXNoKGhyZWYpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDQ6IExhc3QgcmVzb3J0IC0gZmluZCBhbnkgZXh0ZXJuYWwgbGlua3NcbiAgaWYgKGxpbmtzLmxlbmd0aCA8IDUpIHtcbiAgICAkKFwiYVtocmVmXj0naHR0cCddXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgaWYgKGhyZWYgJiZcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcImJpbmcuY29tXCIpICYmXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJtaWNyb3NvZnQuY29tXCIpICYmXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJtc24uY29tXCIpICYmXG4gICAgICAgICAgaXNWYWxpZFVybChocmVmKSAmJlxuICAgICAgICAgICFsaW5rcy5pbmNsdWRlcyhocmVmKSkge1xuICAgICAgICBsaW5rcy5wdXNoKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxpbmtzO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIER1Y2tEdWNrR28gc2VhcmNoIHdpdGggbXVsdGlwbGUgZXh0cmFjdGlvbiB0ZWNobmlxdWVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldER1Y2tEdWNrR29MaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgRHVja0R1Y2tHbyBzZWFyY2ggcmVxdWVzdCBmb3I6IFwiJHtxdWVyeX1cImApO1xuXG4gICAgLy8gVHJ5IG11bHRpcGxlIHNlYXJjaCB2YXJpYXRpb25zXG4gICAgY29uc3Qgc2VhcmNoVmFyaWF0aW9ucyA9IFtcbiAgICAgIC8vIFN0YW5kYXJkIEhUTUwgc2VhcmNoXG4gICAgICBgaHR0cHM6Ly9odG1sLmR1Y2tkdWNrZ28uY29tL2h0bWwvP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfWAsXG4gICAgICAvLyBXaXRoIHJlZ2lvbiBzZXQgdG8gVVNcbiAgICAgIGBodHRwczovL2h0bWwuZHVja2R1Y2tnby5jb20vaHRtbC8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmtsPXVzLWVuYCxcbiAgICAgIC8vIFdpdGggdGltZSBmaWx0ZXIgZm9yIHJlY2VudCByZXN1bHRzXG4gICAgICBgaHR0cHM6Ly9odG1sLmR1Y2tkdWNrZ28uY29tL2h0bWwvP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZkZj15YFxuICAgIF07XG5cbiAgICBsZXQgYWxsTGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBUcnkgZWFjaCBzZWFyY2ggdmFyaWF0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hWYXJpYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWxsTGlua3MubGVuZ3RoID49IDE1KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBbHJlYWR5IGZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIER1Y2tEdWNrR28sIHNraXBwaW5nIHJlbWFpbmluZyB2YXJpYXRpb25zYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWFyY2hVcmwgPSBzZWFyY2hWYXJpYXRpb25zW2ldO1xuICAgICAgICBjb25zb2xlLmxvZyhgVHJ5aW5nIER1Y2tEdWNrR28gc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTogJHtzZWFyY2hVcmx9YCk7XG5cbiAgICAgICAgLy8gQWRkIGhlYWRlcnMgdG8gbWltaWMgYSByZWFsIGJyb3dzZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxuICAgICAgICAgIHNlYXJjaFVybCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxuICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC41JyxcbiAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9kdWNrZHVja2dvLmNvbS8nLFxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ21heC1hZ2U9MCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRHVja0R1Y2tHbyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCBhIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgIGlmIChodG1sLmxlbmd0aCA8IDEwMDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFRvbyBzbWFsbCByZXNwb25zZSBmcm9tIER1Y2tEdWNrR28gdmFyaWF0aW9uICR7aSArIDF9OiAke2h0bWwubGVuZ3RofSBjaGFyc2ApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyB1c2luZyBvdXIgY3VzdG9tIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzID0gZXh0cmFjdER1Y2tEdWNrR29MaW5rcyhodG1sKTtcblxuICAgICAgICBpZiAoZXh0cmFjdGVkTGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2V4dHJhY3RlZExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBEdWNrRHVja0dvIHZhcmlhdGlvbiAke2kgKyAxfWApO1xuXG4gICAgICAgICAgLy8gQWRkIG5ldyB1bmlxdWUgbGlua3NcbiAgICAgICAgICBleHRyYWN0ZWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbGxMaW5rcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2YXJpYXRpb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aXRoIER1Y2tEdWNrR28gc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTpgLCB2YXJpYXRpb25FcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgSFRNTCBzZWFyY2ggZmFpbGVkLCB0cnkgdGhlIGxpdGUgdmVyc2lvbiBhcyBmYWxsYmFja1xuICAgIGlmIChhbGxMaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJ5aW5nIER1Y2tEdWNrR28gTGl0ZSBhcyBmYWxsYmFja1wiKTtcbiAgICAgICAgY29uc3QgbGl0ZVVybCA9IGBodHRwczovL2xpdGUuZHVja2R1Y2tnby5jb20vbGl0ZS8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YDtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICAgICAgbGl0ZVVybCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdVc2VyLUFnZW50JzogZ2V0UmFuZG9tVXNlckFnZW50KCksXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgY29uc3QgJCA9IGNoZWVyaW8ubG9hZChodG1sKTtcblxuICAgICAgICAgIC8vIEV4dHJhY3QgbGlua3MgZnJvbSB0aGUgbGl0ZSB2ZXJzaW9uXG4gICAgICAgICAgJChcImFbaHJlZl49J2h0dHAnXVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gJChlbGVtZW50KS5hdHRyKFwiaHJlZlwiKTtcbiAgICAgICAgICAgIGlmIChocmVmICYmXG4gICAgICAgICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJkdWNrZHVja2dvLmNvbVwiKSAmJlxuICAgICAgICAgICAgICAgIGlzVmFsaWRVcmwoaHJlZikgJiZcbiAgICAgICAgICAgICAgICAhYWxsTGlua3MuaW5jbHVkZXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgYWxsTGlua3MucHVzaChocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBEdWNrRHVja0dvIExpdGUgZmFsbGJhY2tgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAobGl0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aXRoIER1Y2tEdWNrR28gTGl0ZSBmYWxsYmFjazpcIiwgbGl0ZUVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYW5kIGNsZWFuIHRoZSBsaW5rc1xuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmRDbGVhbkxpbmtzKGFsbExpbmtzKTtcblxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkTGlua3MubGVuZ3RofSB1bmlxdWUgdmFsaWQgbGlua3MgZnJvbSBEdWNrRHVja0dvYCk7XG4gICAgcmV0dXJuIGZpbHRlcmVkTGlua3M7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIER1Y2tEdWNrR28gbGlua3M6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGxpbmtzIGZyb20gRHVja0R1Y2tHbyBzZWFyY2ggcmVzdWx0cyBIVE1MXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REdWNrRHVja0dvTGlua3MoaHRtbDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xuICBsZXQgbGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gTWV0aG9kIDE6IEV4dHJhY3QgZnJvbSBtYWluIHJlc3VsdCBsaW5rc1xuICAkKFwiLnJlc3VsdF9fYVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XG4gICAgaWYgKGhyZWYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIER1Y2tEdWNrR28gdXNlcyByZWxhdGl2ZSBVUkxzIHdpdGggcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYsIFwiaHR0cHM6Ly9kdWNrZHVja2dvLmNvbVwiKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEhyZWYgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInVkZGdcIik7XG5cbiAgICAgICAgaWYgKGNsZWFuZWRIcmVmICYmIGlzVmFsaWRVcmwoY2xlYW5lZEhyZWYpICYmICFsaW5rcy5pbmNsdWRlcyhjbGVhbmVkSHJlZikpIHtcbiAgICAgICAgICBsaW5rcy5wdXNoKGNsZWFuZWRIcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDI6IEV4dHJhY3QgZnJvbSByZXN1bHQgc25pcHBldHNcbiAgJChcIi5yZXN1bHRfX3NuaXBwZXRcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudExpbmsgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoXCIucmVzdWx0XCIpLmZpbmQoXCIucmVzdWx0X19hXCIpLmF0dHIoXCJocmVmXCIpO1xuICAgIGlmIChwYXJlbnRMaW5rKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcmVudExpbmssIFwiaHR0cHM6Ly9kdWNrZHVja2dvLmNvbVwiKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEhyZWYgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInVkZGdcIik7XG5cbiAgICAgICAgaWYgKGNsZWFuZWRIcmVmICYmIGlzVmFsaWRVcmwoY2xlYW5lZEhyZWYpICYmICFsaW5rcy5pbmNsdWRlcyhjbGVhbmVkSHJlZikpIHtcbiAgICAgICAgICBsaW5rcy5wdXNoKGNsZWFuZWRIcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDM6IExhc3QgcmVzb3J0IC0gZmluZCBhbnkgZXh0ZXJuYWwgbGlua3NcbiAgaWYgKGxpbmtzLmxlbmd0aCA8IDMpIHtcbiAgICAkKFwiYVtocmVmXj0nLyddXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgaWYgKGhyZWYgJiYgaHJlZi5pbmNsdWRlcyhcInVkZGc9XCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmLCBcImh0dHBzOi8vZHVja2R1Y2tnby5jb21cIik7XG4gICAgICAgICAgY29uc3QgY2xlYW5lZEhyZWYgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInVkZGdcIik7XG5cbiAgICAgICAgICBpZiAoY2xlYW5lZEhyZWYgJiYgaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xuICAgICAgICAgICAgbGlua3MucHVzaChjbGVhbmVkSHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU2tpcCBpbnZhbGlkIFVSTHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxpbmtzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZWFyY2hIYW5kbGVyO1xuIl0sIm5hbWVzIjpbIlJlYWRhYmlsaXR5IiwiY2hlZXJpbyIsIkpTRE9NIiwiRkVUQ0hfVElNRU9VVCIsIlVTRVJfQUdFTlRTIiwiZ2V0UmFuZG9tVXNlckFnZW50IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwiTUFYX1JFVFJJRVMiLCJSRVRSWV9ERUxBWSIsIkRFRkFVTFRfU09VUkNFX0NPVU5UIiwiRVhDTFVERURfRE9NQUlOUyIsImZldGNoV2l0aFRpbWVvdXQiLCJ1cmwiLCJvcHRpb25zIiwidGltZW91dCIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dE1zIiwiaWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJoZWFkZXJzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwb3ciLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsInJlZGlyZWN0IiwiY2xlYXJUaW1lb3V0Iiwib2siLCJzdGF0dXMiLCJFcnJvciIsInN0YXR1c1RleHQiLCJlcnJvciIsIm5hbWUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJzZWFyY2hIYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwianNvbiIsInNvdXJjZXMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwicXVlcnkiLCJzZWFyY2hFbmdpbmUiLCJzb3VyY2VDb3VudCIsImJvZHkiLCJsaW1pdGVkU291cmNlQ291bnQiLCJtaW4iLCJtYXgiLCJhbGxMaW5rcyIsInVzZWRFbmdpbmVzIiwiZ29vZ2xlTGlua3MiLCJiaW5nTGlua3MiLCJkdWNrZHVja2dvTGlua3MiLCJhbGwiLCJnZXRHb29nbGVMaW5rcyIsImNhdGNoIiwiZXJyIiwiZ2V0QmluZ0xpbmtzIiwiZ2V0RHVja0R1Y2tHb0xpbmtzIiwicHVzaCIsImZhbGxiYWNrRXJyb3IiLCJmaWx0ZXJlZExpbmtzIiwiZmlsdGVyQW5kRGVkdXBsaWNhdGVMaW5rcyIsImZpbmFsTGlua3MiLCJzbGljZSIsIm1ldGFkYXRhIiwiZW5naW5lIiwiam9pbiIsInRvdGFsUmVzdWx0cyIsInNlYXJjaFRpbWUiLCJmaWx0ZXJlZFNvdXJjZXMiLCJzY3JhcGVTb3VyY2VzV2l0aFRpbWVvdXQiLCJwcm9jZXNzZWRTb3VyY2VzIiwicHJvY2Vzc1NvdXJjZXMiLCJmYWxsYmFja1NvdXJjZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInRpdGxlIiwidGV4dCIsImZhbGxiYWNrIiwibGlua3MiLCJ2YWxpZExpbmtzIiwiZmlsdGVyIiwibGluayIsIlVSTCIsImRvbWFpbiIsImhvc3RuYW1lIiwic29tZSIsImV4Y2x1ZGVkIiwidW5pcXVlRG9tYWlucyIsIlNldCIsImhhcyIsImFkZCIsInNvdXJjZSIsInVuZGVmaW5lZCIsIm1hcCIsImV4dHJhY3RUaXRsZSIsInBhdGhuYW1lIiwicmVwbGFjZSIsInBhdGhTZWdtZW50Iiwic3BsaXQiLCJCb29sZWFuIiwicG9wIiwiY2xlYW5QYXRoU2VnbWVudCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiTUFYX0NPTkNVUlJFTlQiLCJyZXN1bHRzIiwicHJpb3JpdGl6ZWRMaW5rcyIsInByaW9yaXRpemVMaW5rcyIsInBlbmRpbmdMaW5rcyIsImJhdGNoIiwic3BsaWNlIiwiYmF0Y2hSZXN1bHRzIiwidGVjaG5pcXVlIiwidGVjaG5pcXVlVGltZW91dCIsImZldGNoT3B0aW9ucyIsIndhcm4iLCJjb250ZW50VHlwZSIsImdldCIsImh0bWwiLCJleHRyYWN0ZWRDb250ZW50IiwiZXh0cmFjdFdpdGhSZWFkYWJpbGl0eSIsImV4dHJhY3RXaXRoQ3VzdG9tU2VsZWN0b3JzIiwiZXh0cmFjdFdpdGhTaW1wbGlmaWVkTWV0aG9kIiwicHJvY2Vzc2VkVGV4dCIsInByb2Nlc3NFeHRyYWN0ZWRUZXh0IiwidGVjaG5pcXVlRXJyb3IiLCJ2YWxpZFJlc3VsdHMiLCJ2YWxpZFNvdXJjZXMiLCJzb3J0ZWRTb3VyY2VzIiwic29ydFNvdXJjZXNCeVF1YWxpdHkiLCJjcmVhdGVGYWxsYmFja1NvdXJjZXMiLCJzY29yZWRMaW5rcyIsInNjb3JlIiwidG9Mb3dlckNhc2UiLCJzZWFyY2giLCJzb3J0IiwiYSIsImIiLCJpdGVtIiwiZG9tIiwicnVuU2NyaXB0cyIsInByZXRlbmRUb0JlVmlzdWFsIiwicmVhZGVyIiwid2luZG93IiwiZG9jdW1lbnQiLCJhcnRpY2xlIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsImRvYyIsInNlbGVjdG9ycyIsInNlbGVjdG9yIiwiZWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29tYmluZWRUZXh0IiwiZm9yRWFjaCIsImVsIiwidGV4dEJsb2NrcyIsImZpbmRMYXJnZXN0VGV4dEJsb2NrcyIsIiQiLCJsb2FkIiwicmVtb3ZlIiwicGFyYWdyYXBocyIsImVhY2giLCJfIiwidHJpbSIsImJvZHlUZXh0IiwiY2xlYW5lZFRleHQiLCJsaW5lIiwidGV4dEVsZW1lbnRzIiwicHJvY2Vzc0VsZW1lbnQiLCJlbGVtZW50IiwidGFnTmFtZSIsImRpcmVjdFRleHQiLCJBcnJheSIsImZyb20iLCJjaGlsZE5vZGVzIiwibm9kZSIsIm5vZGVUeXBlIiwiY2hpbGRyZW4iLCJtYWluQ29udGVudEVsZW1lbnRzIiwicHJvY2Vzc2VkIiwidW5pcXVlUGFyYWdyYXBocyIsInN1YnN0cmluZyIsInNjb3JlQSIsImNhbGN1bGF0ZUNvbnRlbnRRdWFsaXR5U2NvcmUiLCJzY29yZUIiLCJmYWxsYmFja1NvdXJjZXMiLCJ0b3BMaW5rcyIsInNlYXJjaFZhcmlhdGlvbnMiLCJpIiwic2VhcmNoVXJsIiwiZXh0cmFjdGVkTGlua3MiLCJleHRyYWN0R29vZ2xlTGlua3MiLCJ2YXJpYXRpb25FcnJvciIsImZpbHRlckFuZENsZWFuTGlua3MiLCJocmVmIiwiYXR0ciIsInN0YXJ0c1dpdGgiLCJjbGVhbmVkSHJlZiIsImRlY29kZVVSSUNvbXBvbmVudCIsImlzVmFsaWRVcmwiLCJlIiwicGFyZW50TGluayIsImNsb3Nlc3QiLCJjaXRlVGV4dCIsInVuaXF1ZUxpbmtzIiwiaW52YWxpZERvbWFpbnMiLCJpbnZhbGlkUGF0dGVybnMiLCJwYXR0ZXJuIiwiZXh0cmFjdEJpbmdMaW5rcyIsImZpbmQiLCJleHRyYWN0RHVja0R1Y2tHb0xpbmtzIiwibGl0ZVVybCIsImxpdGVFcnJvciIsInNlYXJjaFBhcmFtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/sources.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/sources.ts"));
module.exports = __webpack_exports__;

})();