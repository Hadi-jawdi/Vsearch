"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/sources";
exports.ids = ["pages/api/sources"];
exports.modules = {

/***/ "@mozilla/readability":
/*!***************************************!*\
  !*** external "@mozilla/readability" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("@mozilla/readability");

/***/ }),

/***/ "jsdom":
/*!************************!*\
  !*** external "jsdom" ***!
  \************************/
/***/ ((module) => {

module.exports = require("jsdom");

/***/ }),

/***/ "cheerio":
/*!**************************!*\
  !*** external "cheerio" ***!
  \**************************/
/***/ ((module) => {

module.exports = import("cheerio");;

/***/ }),

/***/ "(api)/./pages/api/sources.ts":
/*!******************************!*\
  !*** ./pages/api/sources.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mozilla/readability */ \"@mozilla/readability\");\n/* harmony import */ var _mozilla_readability__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mozilla_readability__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheerio */ \"cheerio\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsdom */ \"jsdom\");\n/* harmony import */ var jsdom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsdom__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([cheerio__WEBPACK_IMPORTED_MODULE_1__]);\ncheerio__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Timeout for fetch requests (15 seconds)\nconst FETCH_TIMEOUT = 15000;\n// User agent rotation for requests\nconst USER_AGENTS = [\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36\",\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0\",\n    \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/96.0.4664.53 Mobile/15E148 Safari/604.1\"\n];\n// Get a random user agent\nconst getRandomUserAgent = ()=>USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];\n// Maximum number of retries for fetch requests\nconst MAX_RETRIES = 3;\n// Delay between retries (in ms)\nconst RETRY_DELAY = 1000;\n// Number of sources to return\nconst DEFAULT_SOURCE_COUNT = 4;\n// List of domains to exclude from results\nconst EXCLUDED_DOMAINS = [\n    \"google\",\n    \"facebook\",\n    \"twitter\",\n    \"instagram\",\n    \"youtube\",\n    \"tiktok\",\n    \"bing\",\n    \"duckduckgo\",\n    \"pinterest\",\n    \"linkedin\",\n    \"reddit\",\n    \"quora\"\n];\n/**\n * Enhanced fetch with timeout, retries, and exponential backoff\n */ async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT) {\n    let lastError = null;\n    // Try multiple times with exponential backoff\n    for(let attempt = 0; attempt < MAX_RETRIES; attempt++){\n        const controller = new AbortController();\n        const timeoutMs = timeout * (attempt + 1); // Increase timeout with each retry\n        const id = setTimeout(()=>controller.abort(), timeoutMs);\n        // Add default headers including a random user agent\n        const headers = {\n            \"User-Agent\": getRandomUserAgent(),\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"Cache-Control\": \"no-cache\",\n            \"Pragma\": \"no-cache\",\n            ...options.headers\n        };\n        try {\n            // Add a small delay between retries with exponential backoff\n            if (attempt > 0) {\n                await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * Math.pow(2, attempt - 1)));\n                console.log(`Retry attempt ${attempt + 1} for ${url}`);\n            }\n            const response = await fetch(url, {\n                ...options,\n                headers,\n                signal: controller.signal,\n                redirect: \"follow\"\n            });\n            clearTimeout(id);\n            // Check if we got a successful response\n            if (response.ok) {\n                return response;\n            } else {\n                // For certain status codes, we might want to retry\n                if (response.status === 429 || response.status >= 500) {\n                    lastError = new Error(`HTTP error ${response.status}: ${response.statusText}`);\n                    continue; // Retry\n                }\n                return response; // Return the response even if it's not ok\n            }\n        } catch (error) {\n            clearTimeout(id);\n            lastError = error;\n            // Don't retry if it's a CORS error or if the request was aborted\n            if (error.name === \"AbortError\" || error.message.includes(\"CORS\")) {\n                throw error;\n            }\n        // Continue to next retry attempt\n        }\n    }\n    // If we've exhausted all retries, throw the last error\n    throw lastError || new Error(`Failed to fetch ${url} after ${MAX_RETRIES} attempts`);\n}\n/**\n * Main handler for the sources API\n */ const searchHandler = async (req, res)=>{\n    // Only allow POST requests\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            sources: [],\n            error: \"Method not allowed\"\n        });\n    }\n    const startTime = Date.now();\n    try {\n        const { query , searchEngine =\"google\" , sourceCount =DEFAULT_SOURCE_COUNT  } = req.body;\n        // Validate input\n        if (!query || typeof query !== \"string\") {\n            return res.status(400).json({\n                sources: [],\n                error: \"Invalid query provided\"\n            });\n        }\n        // Limit source count to reasonable values\n        const limitedSourceCount = Math.min(Math.max(1, sourceCount), 8);\n        let allLinks = [];\n        let usedEngines = [];\n        // Get links from selected search engine(s)\n        if (searchEngine === \"all\") {\n            // Fetch from all search engines in parallel\n            console.log(`Fetching from all search engines for query: \"${query}\"`);\n            const [googleLinks, bingLinks, duckduckgoLinks] = await Promise.all([\n                getGoogleLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Google links:\", err);\n                    return [];\n                }),\n                getBingLinks(query).catch((err)=>{\n                    console.error(\"Error fetching Bing links:\", err);\n                    return [];\n                }),\n                getDuckDuckGoLinks(query).catch((err)=>{\n                    console.error(\"Error fetching DuckDuckGo links:\", err);\n                    return [];\n                })\n            ]);\n            console.log(`Found links - Google: ${googleLinks.length}, Bing: ${bingLinks.length}, DuckDuckGo: ${duckduckgoLinks.length}`);\n            if (googleLinks.length > 0) usedEngines.push(\"google\");\n            if (bingLinks.length > 0) usedEngines.push(\"bing\");\n            if (duckduckgoLinks.length > 0) usedEngines.push(\"duckduckgo\");\n            allLinks = [\n                ...googleLinks,\n                ...bingLinks,\n                ...duckduckgoLinks\n            ];\n        } else {\n            // Fetch from a single search engine\n            console.log(`Fetching from ${searchEngine} for query: \"${query}\"`);\n            try {\n                switch(searchEngine){\n                    case \"google\":\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                        break;\n                    case \"bing\":\n                        allLinks = await getBingLinks(query);\n                        usedEngines.push(\"bing\");\n                        break;\n                    case \"duckduckgo\":\n                        allLinks = await getDuckDuckGoLinks(query);\n                        usedEngines.push(\"duckduckgo\");\n                        break;\n                    default:\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines.push(\"google\");\n                }\n                console.log(`Found ${allLinks.length} links from ${searchEngine}`);\n            } catch (error) {\n                console.error(`Error fetching links from ${searchEngine}:`, error);\n                // Try Google as fallback if another engine fails\n                if (searchEngine !== \"google\") {\n                    console.log(\"Trying Google as fallback\");\n                    try {\n                        allLinks = await getGoogleLinks(query);\n                        usedEngines = [\n                            \"google (fallback)\"\n                        ];\n                    } catch (fallbackError) {\n                        console.error(\"Fallback to Google also failed:\", fallbackError);\n                    }\n                }\n            }\n        }\n        // Filter and deduplicate links\n        const filteredLinks = filterAndDeduplicateLinks(allLinks);\n        // Limit to requested number of sources\n        const finalLinks = filteredLinks.slice(0, limitedSourceCount);\n        if (finalLinks.length === 0) {\n            return res.status(200).json({\n                sources: [],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: 0,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 0\n                }\n            });\n        }\n        // Scrape text from links with timeout and concurrency control\n        const sources = await scrapeSourcesWithTimeout(finalLinks);\n        // Process and clean up sources\n        const processedSources = processSources(sources);\n        // If we still don't have any valid sources after processing, create a fallback source\n        if (processedSources.length === 0) {\n            // Create a fallback source with search information\n            const fallbackSource = {\n                url: `https://www.google.com/search?q=${encodeURIComponent(query)}`,\n                title: `Search results for: ${query}`,\n                text: `We couldn't extract detailed information from the search results for \"${query}\".\n        This could be due to various reasons such as website restrictions or content formatting.\n\n        You can try:\n        1. Rephrasing your query to be more specific\n        2. Using a different search engine (try Bing or DuckDuckGo)\n        3. Searching for a related but different topic\n\n        The search was performed using ${usedEngines.join(\"+\")} and found ${allLinks.length} potential sources.`\n            };\n            // Return the fallback source\n            res.status(200).json({\n                sources: [\n                    fallbackSource\n                ],\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: 1,\n                    fallback: true\n                }\n            });\n        } else {\n            // Return the processed sources\n            res.status(200).json({\n                sources: processedSources,\n                metadata: {\n                    engine: usedEngines.join(\"+\"),\n                    totalResults: allLinks.length,\n                    searchTime: Date.now() - startTime,\n                    filteredSources: processedSources.length\n                }\n            });\n        }\n    } catch (err) {\n        console.error(\"Error in sources API:\", err);\n        res.status(500).json({\n            sources: [],\n            error: \"Failed to fetch sources. Please try again.\"\n        });\n    }\n};\n/**\n * Filter and deduplicate links\n */ function filterAndDeduplicateLinks(links) {\n    // First, filter out invalid URLs and excluded domains\n    const validLinks = links.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const domain = url.hostname;\n            // Check if domain is in exclude list\n            return !EXCLUDED_DOMAINS.some((excluded)=>domain.includes(excluded));\n        } catch  {\n            return false;\n        }\n    });\n    // Then, deduplicate by domain\n    const uniqueDomains = new Set();\n    return validLinks.filter((link)=>{\n        try {\n            const domain = new URL(link).hostname;\n            if (uniqueDomains.has(domain)) return false;\n            uniqueDomains.add(domain);\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n}\n/**\n * Process and clean up sources\n */ function processSources(sources) {\n    const filteredSources = sources.filter((source)=>source !== undefined && source.text && source.text.length > 100);\n    // Truncate long texts and add metadata\n    return filteredSources.map((source)=>({\n            ...source,\n            text: source.text.slice(0, 1500),\n            title: extractTitle(source.url)\n        }));\n}\n/**\n * Extract a readable title from URL\n */ function extractTitle(url) {\n    try {\n        const { hostname , pathname  } = new URL(url);\n        // Get domain without www\n        const domain = hostname.replace(/^www\\./, \"\");\n        // Get last path segment without extension\n        const pathSegment = pathname.split(\"/\").filter(Boolean).pop() || \"\";\n        const cleanPathSegment = pathSegment.replace(/\\.\\w+$/, \"\").replace(/-|_/g, \" \");\n        if (cleanPathSegment) {\n            return `${cleanPathSegment.charAt(0).toUpperCase() + cleanPathSegment.slice(1)} - ${domain}`;\n        }\n        return domain;\n    } catch  {\n        return url;\n    }\n}\n/**\n * Scrape sources with timeout\n */ /**\n * Advanced web scraping with multiple extraction techniques and smart content detection\n */ async function scrapeSourcesWithTimeout(links) {\n    // Use a more controlled approach with concurrency limit and prioritization\n    const MAX_CONCURRENT = 4;\n    const results = [];\n    // Prioritize links based on domain reputation and URL structure\n    const prioritizedLinks = prioritizeLinks([\n        ...links\n    ]);\n    const pendingLinks = prioritizedLinks;\n    console.log(`Scraping ${pendingLinks.length} links with priority order`);\n    // Process links in batches to control concurrency\n    while(pendingLinks.length > 0){\n        const batch = pendingLinks.splice(0, MAX_CONCURRENT);\n        console.log(`Processing batch of ${batch.length} links`);\n        const batchResults = await Promise.all(batch.map(async (link)=>{\n            try {\n                // Try multiple extraction techniques\n                for(let technique = 0; technique < 3; technique++){\n                    try {\n                        console.log(`Fetching ${link} with technique ${technique + 1}`);\n                        // Adjust timeout based on technique\n                        const techniqueTimeout = FETCH_TIMEOUT + technique * 5000;\n                        // Use different fetch options based on technique\n                        const fetchOptions = {\n                            headers: {\n                                // Add referer for some techniques\n                                ...technique > 0 ? {\n                                    \"Referer\": \"https://www.google.com/\"\n                                } : {}\n                            }\n                        };\n                        const response = await fetchWithTimeout(link, fetchOptions, techniqueTimeout);\n                        if (!response.ok) {\n                            console.warn(`Failed to fetch ${link}: ${response.status}, technique ${technique + 1}`);\n                            // For certain status codes, we might want to skip to next technique\n                            if (response.status === 403 || response.status === 429) {\n                                continue;\n                            }\n                            // For other status codes, we might want to try a different approach\n                            if (technique < 2) {\n                                continue;\n                            } else {\n                                break; // Give up on this link after all techniques fail\n                            }\n                        }\n                        // Get content type to handle different types of content\n                        const contentType = response.headers.get(\"content-type\") || \"\";\n                        // Skip non-HTML content\n                        if (!contentType.includes(\"text/html\") && !contentType.includes(\"application/xhtml+xml\") && !contentType.includes(\"text/plain\")) {\n                            console.warn(`Skipping non-HTML content: ${contentType} for ${link}`);\n                            continue;\n                        }\n                        const html = await response.text();\n                        // Skip if we got a very small response (likely an error page)\n                        if (html.length < 800) {\n                            console.warn(`Too small response from ${link}: ${html.length} chars`);\n                            continue;\n                        }\n                        // Check for common error patterns in the HTML\n                        if (html.includes(\"captcha\") || html.includes(\"CAPTCHA\") || html.includes(\"access denied\") || html.includes(\"Access Denied\") || html.includes(\"403 Forbidden\")) {\n                            console.warn(`Detected access restriction in ${link}`);\n                            continue;\n                        }\n                        // Parse the HTML with different methods based on technique\n                        let extractedContent = null;\n                        // Technique 1: Use Readability\n                        if (technique === 0) {\n                            extractedContent = await extractWithReadability(html, link);\n                        }\n                        // Technique 2: Use custom content extraction\n                        if (technique === 1 || !extractedContent) {\n                            extractedContent = await extractWithCustomSelectors(html, link);\n                        }\n                        // Technique 3: Use simplified extraction\n                        if (technique === 2 || !extractedContent) {\n                            extractedContent = await extractWithSimplifiedMethod(html, link);\n                        }\n                        // If we successfully extracted content\n                        if (extractedContent && extractedContent.text.length > 200) {\n                            console.log(`Successfully extracted ${extractedContent.text.length} chars from ${link}`);\n                            // Clean and process the text\n                            const processedText = processExtractedText(extractedContent.text);\n                            return {\n                                url: link,\n                                text: processedText,\n                                title: extractedContent.title || extractTitle(link)\n                            };\n                        }\n                    } catch (techniqueError) {\n                        console.warn(`Technique ${technique + 1} failed for ${link}:`, techniqueError);\n                    }\n                }\n                // All techniques failed\n                console.error(`All extraction techniques failed for ${link}`);\n                return null;\n            } catch (error) {\n                console.error(`Error scraping ${link}:`, error);\n                return null;\n            }\n        }));\n        results.push(...batchResults);\n        // If we have enough good results, we can stop early\n        const validResults = results.filter(Boolean);\n        if (validResults.length >= 3) {\n            console.log(`Got ${validResults.length} good results, stopping early`);\n            break;\n        }\n    }\n    // Filter out null results and ensure we have at least some content\n    const validSources = results.filter(Boolean);\n    // Sort sources by content quality (length and readability)\n    const sortedSources = sortSourcesByQuality(validSources);\n    // If we have no valid sources, create intelligent fallback sources\n    if (sortedSources.length === 0 && links.length > 0) {\n        console.log(\"No valid sources found, creating fallback sources\");\n        return createFallbackSources(links);\n    }\n    return sortedSources;\n}\n/**\n * Prioritize links based on domain reputation and URL structure\n */ function prioritizeLinks(links) {\n    // Score each link\n    const scoredLinks = links.map((link)=>{\n        try {\n            const url = new URL(link);\n            let score = 0;\n            // Prefer certain domains\n            const hostname = url.hostname.toLowerCase();\n            // Higher score for reputable domains\n            if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\") || hostname.includes(\"github.com\") || hostname.includes(\"stackoverflow.com\") || hostname.includes(\"medium.com\")) {\n                score += 30;\n            }\n            // Prefer shorter URLs (often main pages)\n            score -= url.pathname.split(\"/\").length * 2;\n            // Prefer URLs without query parameters\n            score -= url.search.length > 0 ? 5 : 0;\n            // Avoid certain patterns\n            if (url.pathname.includes(\"login\") || url.pathname.includes(\"signup\") || url.pathname.includes(\"account\")) {\n                score -= 20;\n            }\n            return {\n                link,\n                score\n            };\n        } catch  {\n            return {\n                link,\n                score: -100\n            }; // Invalid URLs get lowest priority\n        }\n    });\n    // Sort by score (highest first)\n    scoredLinks.sort((a, b)=>b.score - a.score);\n    // Return just the links\n    return scoredLinks.map((item)=>item.link);\n}\n/**\n * Extract content using Mozilla's Readability\n */ async function extractWithReadability(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url,\n            runScripts: \"outside-only\",\n            pretendToBeVisual: true\n        });\n        const reader = new _mozilla_readability__WEBPACK_IMPORTED_MODULE_0__.Readability(dom.window.document);\n        const article = reader.parse();\n        if (article && article.textContent && article.textContent.length > 200) {\n            return {\n                text: article.textContent,\n                title: article.title || dom.window.document.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Readability extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Extract content using custom selectors for different site types\n */ async function extractWithCustomSelectors(html, url) {\n    try {\n        const dom = new jsdom__WEBPACK_IMPORTED_MODULE_2__.JSDOM(html, {\n            url\n        });\n        const doc = dom.window.document;\n        // Get the hostname to apply site-specific selectors\n        const hostname = new URL(url).hostname.toLowerCase();\n        // Define selectors for different site types\n        let selectors = [];\n        // Wikipedia-specific selectors\n        if (hostname.includes(\"wikipedia.org\")) {\n            selectors = [\n                \"#mw-content-text\",\n                \".mw-parser-output\"\n            ];\n        } else if (hostname.includes(\"github.com\")) {\n            selectors = [\n                \".markdown-body\",\n                \"article.markdown-body\",\n                \".repository-content\"\n            ];\n        } else if (hostname.includes(\"stackoverflow.com\")) {\n            selectors = [\n                \".post-text\",\n                \".answer\"\n            ];\n        } else if (hostname.includes(\"news\") || hostname.includes(\"bbc\") || hostname.includes(\"cnn\") || hostname.includes(\"nytimes\")) {\n            selectors = [\n                \".article-body\",\n                \".story-body\",\n                \".article__content\",\n                '[itemprop=\"articleBody\"]'\n            ];\n        } else {\n            selectors = [\n                \"main\",\n                \"article\",\n                '[role=\"main\"]',\n                \"#content\",\n                \".content\",\n                \".post-content\",\n                \".entry-content\",\n                \".article-content\",\n                \".post-body\",\n                \".page-content\",\n                \".main-content\",\n                \".body-content\"\n            ];\n        }\n        // Try each selector\n        for (const selector of selectors){\n            const elements = doc.querySelectorAll(selector);\n            if (elements.length > 0) {\n                // Combine text from all matching elements\n                let combinedText = \"\";\n                elements.forEach((el)=>{\n                    combinedText += el.textContent + \"\\n\\n\";\n                });\n                if (combinedText.length > 200) {\n                    return {\n                        text: combinedText,\n                        title: doc.title || extractTitle(url)\n                    };\n                }\n            }\n        }\n        // If no content found with selectors, try to find the largest text block\n        const textBlocks = findLargestTextBlocks(doc);\n        if (textBlocks && textBlocks.length > 200) {\n            return {\n                text: textBlocks,\n                title: doc.title || extractTitle(url)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Custom extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Extract content using a simplified method (fallback)\n */ async function extractWithSimplifiedMethod(html, url) {\n    try {\n        // Use cheerio for lightweight parsing\n        const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n        // Remove script, style, nav, footer, and other non-content elements\n        $(\"script, style, nav, footer, header, aside, .sidebar, .footer, .header, .navigation, .nav, .menu, .comments, .ads, .ad\").remove();\n        // Get the title\n        const title = $(\"title\").text() || extractTitle(url);\n        // Get all paragraphs\n        const paragraphs = [];\n        $(\"p\").each((_, el)=>{\n            const text = $(el).text().trim();\n            if (text.length > 20) {\n                paragraphs.push(text);\n            }\n        });\n        // If we found paragraphs, join them\n        if (paragraphs.length > 0) {\n            return {\n                text: paragraphs.join(\"\\n\\n\"),\n                title\n            };\n        }\n        // Fallback: get all text from body\n        const bodyText = $(\"body\").text();\n        if (bodyText.length > 200) {\n            // Clean up the text\n            const cleanedText = bodyText.replace(/\\s+/g, \" \").trim().split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 20).join(\"\\n\\n\");\n            if (cleanedText.length > 200) {\n                return {\n                    text: cleanedText,\n                    title\n                };\n            }\n        }\n        return null;\n    } catch (error) {\n        console.warn(`Simplified extraction failed for ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Find the largest text blocks in a document\n */ function findLargestTextBlocks(doc) {\n    // Get all elements with substantial text\n    const textElements = [];\n    // Function to recursively process elements\n    function processElement(element) {\n        // Skip certain elements\n        const tagName = element.tagName.toLowerCase();\n        if ([\n            \"script\",\n            \"style\",\n            \"nav\",\n            \"header\",\n            \"footer\"\n        ].includes(tagName)) {\n            return;\n        }\n        // Check if this element has direct text\n        const directText = Array.from(element.childNodes).filter((node)=>node.nodeType === 3) // Text nodes only\n        .map((node)=>node.textContent || \"\").join(\"\").trim();\n        // If this element has substantial direct text, add it\n        if (directText.length > 50) {\n            textElements.push({\n                element,\n                length: directText.length\n            });\n        }\n        // Process children\n        Array.from(element.children).forEach(processElement);\n    }\n    // Start processing from body\n    processElement(doc.body);\n    // Sort by text length (largest first)\n    textElements.sort((a, b)=>b.length - a.length);\n    // Take the top elements that likely contain main content\n    const mainContentElements = textElements.slice(0, 10);\n    // Extract and join their text\n    return mainContentElements.map((item)=>item.element.textContent || \"\").join(\"\\n\\n\");\n}\n/**\n * Process and clean extracted text\n */ function processExtractedText(text) {\n    // Remove excessive whitespace\n    let processed = text.replace(/\\s+/g, \" \");\n    // Split into lines and clean each line\n    processed = processed.split(\"\\n\").map((line)=>line.trim()).filter((line)=>line.length > 0).join(\"\\n\");\n    // Remove duplicate paragraphs\n    const paragraphs = processed.split(\"\\n\\n\");\n    const uniqueParagraphs = Array.from(new Set(paragraphs));\n    processed = uniqueParagraphs.join(\"\\n\\n\");\n    // Limit length to avoid extremely long texts\n    if (processed.length > 8000) {\n        processed = processed.substring(0, 8000) + \"...\";\n    }\n    return processed;\n}\n/**\n * Sort sources by quality\n */ function sortSourcesByQuality(sources) {\n    return [\n        ...sources\n    ].sort((a, b)=>{\n        // Calculate quality score based on text length and other factors\n        const scoreA = calculateContentQualityScore(a);\n        const scoreB = calculateContentQualityScore(b);\n        return scoreB - scoreA;\n    });\n}\n/**\n * Calculate content quality score\n */ function calculateContentQualityScore(source) {\n    let score = 0;\n    // Length is a primary factor\n    score += Math.min(source.text.length / 100, 50);\n    // Prefer sources with titles\n    score += source.title ? 10 : 0;\n    // Prefer sources from reputable domains\n    try {\n        const hostname = new URL(source.url).hostname.toLowerCase();\n        if (hostname.includes(\".edu\") || hostname.includes(\".gov\") || hostname.includes(\"wikipedia.org\")) {\n            score += 20;\n        }\n    } catch  {\n    // Invalid URL\n    }\n    return score;\n}\n/**\n * Create fallback sources when extraction fails\n */ function createFallbackSources(links) {\n    // Create at least one fallback source\n    const fallbackSources = [];\n    // Try to create sources from the top 3 links\n    const topLinks = links.slice(0, 3);\n    for (const link of topLinks){\n        try {\n            const domain = new URL(link).hostname.replace(\"www.\", \"\");\n            fallbackSources.push({\n                url: link,\n                text: `This information is from ${domain}. The content could not be fully extracted due to website restrictions. Please visit the website directly for complete information.`,\n                title: `Information from ${domain}`\n            });\n        } catch  {\n        // Skip invalid URLs\n        }\n    }\n    // If we couldn't create any fallback sources, create a generic one\n    if (fallbackSources.length === 0 && links.length > 0) {\n        fallbackSources.push({\n            url: links[0],\n            text: `Information could not be retrieved from the sources. This might be due to website restrictions or technical limitations. Try refining your search query or visiting the websites directly.`,\n            title: `Search Results`\n        });\n    }\n    return fallbackSources;\n}\n/**\n * Advanced Google search with multiple extraction techniques and fallbacks\n */ async function getGoogleLinks(query) {\n    try {\n        console.log(`Making Google search request for: \"${query}\"`);\n        // Try multiple search variations to improve results\n        const searchVariations = [\n            // Standard search\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=30`,\n            // Search with verbatim option to get exact matches\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=li:1`,\n            // Search with recent results\n            `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20&tbs=qdr:y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying search variation ${i + 1}: ${searchUrl}`);\n                // Add additional headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.google.com/\",\n                        \"DNT\": \"1\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\",\n                        \"sec-ch-ua\": '\"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"',\n                        \"sec-ch-ua-mobile\": \"?0\",\n                        \"sec-ch-ua-platform\": '\"Windows\"'\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Google search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Google variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                if (html.includes(\"unusual traffic\") || html.includes(\"CAPTCHA\") || html.includes(\"detected unusual traffic\")) {\n                    console.warn(`Google variation ${i + 1} blocked or returned a CAPTCHA`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractGoogleLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Google variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Google search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Google`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Google links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from Google search results HTML using multiple methods\n */ function extractGoogleLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Standard Google search results - look for redirects\n    $(\"a\").each((_, link)=>{\n        const href = $(link).attr(\"href\");\n        if (href && href.startsWith(\"/url?q=\")) {\n            try {\n                const cleanedHref = decodeURIComponent(href.replace(\"/url?q=\", \"\").split(\"&\")[0]);\n                if (isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Look for result containers and extract links\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 2\");\n        // Modern Google selectors\n        $(\".g .yuRUbf > a, .g .rc > a, .g h3.r > a, .tF2Cxc > div.yuRUbf > a, .hlcw0c .yuRUbf > a\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.startsWith(\"http\") && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    // Method 3: Extract from cite elements\n    if (links.length < 5) {\n        console.log(\"Using Google extraction method 3\");\n        $(\".iUh30, .tjvcx, .qzEoUe\").each((_, element)=>{\n            const parentLink = $(element).closest(\"a\").attr(\"href\");\n            if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n                links.push(parentLink);\n            } else {\n                // Try to construct URL from cite text\n                const citeText = $(element).text().trim();\n                if (citeText && !citeText.includes(\"...\") && citeText.includes(\".\")) {\n                    try {\n                        let url = citeText;\n                        if (!url.startsWith(\"http\")) {\n                            url = \"https://\" + url;\n                        }\n                        if (isValidUrl(url) && !links.includes(url)) {\n                            links.push(url);\n                        }\n                    } catch (e) {\n                    // Skip invalid URLs\n                    }\n                }\n            }\n        });\n    }\n    // Method 4: Last resort - find any external links\n    if (links.length < 3) {\n        console.log(\"Using Google extraction method 4 (last resort)\");\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"google.com\") && !href.includes(\"accounts.\") && !href.includes(\"support.\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\n * Filter and clean a list of URLs\n */ function filterAndCleanLinks(links) {\n    // Remove duplicates\n    let uniqueLinks = Array.from(new Set(links));\n    // Filter out invalid and unwanted URLs\n    uniqueLinks = uniqueLinks.filter((link)=>{\n        try {\n            const url = new URL(link);\n            const hostname = url.hostname.toLowerCase();\n            // Filter out common non-content domains\n            const invalidDomains = [\n                \"google.com\",\n                \"youtube.com\",\n                \"facebook.com\",\n                \"twitter.com\",\n                \"instagram.com\",\n                \"linkedin.com\",\n                \"pinterest.com\",\n                \"amazon.com\",\n                \"ebay.com\",\n                \"netflix.com\",\n                \"apple.com\",\n                \"microsoft.com\",\n                \"play.google.com\",\n                \"accounts.google.com\",\n                \"support.google.com\",\n                \"maps.google.com\",\n                \"policies.google.com\",\n                \"translate.google.com\",\n                \"chrome.google.com\",\n                \"docs.google.com\",\n                \"drive.google.com\",\n                \"mail.google.com\",\n                \"calendar.google.com\"\n            ];\n            if (invalidDomains.some((domain)=>hostname.includes(domain))) {\n                return false;\n            }\n            // Filter out URLs with certain patterns\n            const invalidPatterns = [\n                \"/search?\",\n                \"/login\",\n                \"/signin\",\n                \"/signup\",\n                \"/register\",\n                \"/account\",\n                \"/cart\",\n                \"/checkout\",\n                \"/privacy\",\n                \"/terms\",\n                \"/contact\",\n                \"/about\",\n                \"/help\",\n                \"/support\",\n                \"/faq\",\n                \"/download\",\n                \"/subscribe\",\n                \"/membership\",\n                \"/pricing\"\n            ];\n            if (invalidPatterns.some((pattern)=>url.pathname.includes(pattern))) {\n                return false;\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    });\n    // Limit to a reasonable number\n    return uniqueLinks.slice(0, 20);\n}\n/**\n * Validate if a string is a valid URL and meets content criteria\n */ function isValidUrl(url) {\n    try {\n        new URL(url);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Enhanced Bing search with multiple extraction techniques\n */ async function getBingLinks(query) {\n    try {\n        console.log(`Making Bing search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard search\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&count=30`,\n            // Search with news\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=news`,\n            // Search with freshness filter\n            `https://www.bing.com/search?q=${encodeURIComponent(query)}&filters=ex1%3a\"ez5\"`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from Bing, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying Bing search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://www.bing.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`Bing search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from Bing variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using multiple methods\n                const extractedLinks = extractBingLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from Bing variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with Bing search variation ${i + 1}:`, variationError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from Bing`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching Bing links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from Bing search results HTML\n */ function extractBingLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main search results\n    $(\".b_algo h2 a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 2: Extract from cite elements\n    $(\".b_caption cite\").each((_, element)=>{\n        const parentLink = $(element).closest(\".b_algo\").find(\"h2 a\").attr(\"href\");\n        if (parentLink && parentLink.startsWith(\"http\") && !links.includes(parentLink)) {\n            links.push(parentLink);\n        }\n    });\n    // Method 3: Extract from deep links\n    $(\".b_deeplinks a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href && href.startsWith(\"http\") && !links.includes(href)) {\n            links.push(href);\n        }\n    });\n    // Method 4: Last resort - find any external links\n    if (links.length < 5) {\n        $(\"a[href^='http']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && !href.includes(\"bing.com\") && !href.includes(\"microsoft.com\") && !href.includes(\"msn.com\") && isValidUrl(href) && !links.includes(href)) {\n                links.push(href);\n            }\n        });\n    }\n    return links;\n}\n/**\n * Enhanced DuckDuckGo search with multiple extraction techniques\n */ async function getDuckDuckGoLinks(query) {\n    try {\n        console.log(`Making DuckDuckGo search request for: \"${query}\"`);\n        // Try multiple search variations\n        const searchVariations = [\n            // Standard HTML search\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`,\n            // With region set to US\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&kl=us-en`,\n            // With time filter for recent results\n            `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}&df=y`\n        ];\n        let allLinks = [];\n        // Try each search variation\n        for(let i = 0; i < searchVariations.length; i++){\n            if (allLinks.length >= 15) {\n                console.log(`Already found ${allLinks.length} links from DuckDuckGo, skipping remaining variations`);\n                break;\n            }\n            try {\n                const searchUrl = searchVariations[i];\n                console.log(`Trying DuckDuckGo search variation ${i + 1}: ${searchUrl}`);\n                // Add headers to mimic a real browser\n                const response = await fetchWithTimeout(searchUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                        \"Accept-Language\": \"en-US,en;q=0.5\",\n                        \"Referer\": \"https://duckduckgo.com/\",\n                        \"Connection\": \"keep-alive\",\n                        \"Upgrade-Insecure-Requests\": \"1\",\n                        \"Cache-Control\": \"max-age=0\"\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(`DuckDuckGo search variation ${i + 1} failed: ${response.status}`);\n                    continue;\n                }\n                const html = await response.text();\n                // Check if we got a valid response\n                if (html.length < 1000) {\n                    console.warn(`Too small response from DuckDuckGo variation ${i + 1}: ${html.length} chars`);\n                    continue;\n                }\n                // Extract links using our custom function\n                const extractedLinks = extractDuckDuckGoLinks(html);\n                if (extractedLinks.length > 0) {\n                    console.log(`Found ${extractedLinks.length} links from DuckDuckGo variation ${i + 1}`);\n                    // Add new unique links\n                    extractedLinks.forEach((link)=>{\n                        if (!allLinks.includes(link)) {\n                            allLinks.push(link);\n                        }\n                    });\n                }\n            } catch (variationError) {\n                console.error(`Error with DuckDuckGo search variation ${i + 1}:`, variationError);\n            }\n        }\n        // If HTML search failed, try the lite version as fallback\n        if (allLinks.length === 0) {\n            try {\n                console.log(\"Trying DuckDuckGo Lite as fallback\");\n                const liteUrl = `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(query)}`;\n                const response = await fetchWithTimeout(liteUrl, {\n                    headers: {\n                        \"User-Agent\": getRandomUserAgent(),\n                        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\"\n                    }\n                });\n                if (response.ok) {\n                    const html = await response.text();\n                    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n                    // Extract links from the lite version\n                    $(\"a[href^='http']\").each((_, element)=>{\n                        const href = $(element).attr(\"href\");\n                        if (href && !href.includes(\"duckduckgo.com\") && isValidUrl(href) && !allLinks.includes(href)) {\n                            allLinks.push(href);\n                        }\n                    });\n                    console.log(`Found ${allLinks.length} links from DuckDuckGo Lite fallback`);\n                }\n            } catch (liteError) {\n                console.error(\"Error with DuckDuckGo Lite fallback:\", liteError);\n            }\n        }\n        // Filter and clean the links\n        const filteredLinks = filterAndCleanLinks(allLinks);\n        console.log(`Found ${filteredLinks.length} unique valid links from DuckDuckGo`);\n        return filteredLinks;\n    } catch (error) {\n        console.error(\"Error fetching DuckDuckGo links:\", error);\n        return [];\n    }\n}\n/**\n * Extract links from DuckDuckGo search results HTML\n */ function extractDuckDuckGoLinks(html) {\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    let links = [];\n    // Method 1: Extract from main result links\n    $(\".result__a\").each((_, element)=>{\n        const href = $(element).attr(\"href\");\n        if (href) {\n            try {\n                // DuckDuckGo uses relative URLs with parameters\n                const url = new URL(href, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 2: Extract from result snippets\n    $(\".result__snippet\").each((_, element)=>{\n        const parentLink = $(element).closest(\".result\").find(\".result__a\").attr(\"href\");\n        if (parentLink) {\n            try {\n                const url = new URL(parentLink, \"https://duckduckgo.com\");\n                const cleanedHref = url.searchParams.get(\"uddg\");\n                if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                    links.push(cleanedHref);\n                }\n            } catch (e) {\n            // Skip invalid URLs\n            }\n        }\n    });\n    // Method 3: Last resort - find any external links\n    if (links.length < 3) {\n        $(\"a[href^='/']\").each((_, element)=>{\n            const href = $(element).attr(\"href\");\n            if (href && href.includes(\"uddg=\")) {\n                try {\n                    const url = new URL(href, \"https://duckduckgo.com\");\n                    const cleanedHref = url.searchParams.get(\"uddg\");\n                    if (cleanedHref && isValidUrl(cleanedHref) && !links.includes(cleanedHref)) {\n                        links.push(cleanedHref);\n                    }\n                } catch (e) {\n                // Skip invalid URLs\n                }\n            }\n        });\n    }\n    return links;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (searchHandler);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1lBQ1Ysb0JBQW9CO1lBQ3RCO1FBQ0YsQ0FBQztJQUNIO0lBRUEsa0RBQWtEO0lBQ2xELElBQUkzSCxNQUFNbkYsTUFBTSxHQUFHLEdBQUc7UUFDcEJtSyxFQUFFLGdCQUFnQkksSUFBSSxDQUFDLENBQUNDLEdBQUdPLFVBQVk7WUFDckMsTUFBTXlCLE9BQU9yQyxFQUFFWSxTQUFTMEIsSUFBSSxDQUFDO1lBQzdCLElBQUlELFFBQVFBLEtBQUtySyxRQUFRLENBQUMsVUFBVTtnQkFDbEMsSUFBSTtvQkFDRixNQUFNN0IsTUFBTSxJQUFJaUYsSUFBSWlILE1BQU07b0JBQzFCLE1BQU1HLGNBQWNyTSxJQUFJcU4sWUFBWSxDQUFDakcsR0FBRyxDQUFDO29CQUV6QyxJQUFJaUYsZUFBZUUsV0FBV0YsZ0JBQWdCLENBQUN4SCxNQUFNaEQsUUFBUSxDQUFDd0ssY0FBYzt3QkFDMUV4SCxNQUFNcEIsSUFBSSxDQUFDNEk7b0JBQ2IsQ0FBQztnQkFDSCxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1Ysb0JBQW9CO2dCQUN0QjtZQUNGLENBQUM7UUFDSDtJQUNGLENBQUM7SUFFRCxPQUFPM0g7QUFDVDtBQUVBLGlFQUFlL0MsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZzZWFyY2gvLi9wYWdlcy9hcGkvc291cmNlcy50cz9lOWUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvdXJjZSB9IGZyb20gXCJAL3R5cGVzXCI7XG5pbXBvcnQgeyBSZWFkYWJpbGl0eSB9IGZyb20gXCJAbW96aWxsYS9yZWFkYWJpbGl0eVwiO1xuaW1wb3J0ICogYXMgY2hlZXJpbyBmcm9tIFwiY2hlZXJpb1wiO1xuaW1wb3J0IHsgSlNET00gfSBmcm9tIFwianNkb21cIjtcbmltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gXCJuZXh0XCI7XG5cbi8vIERlZmluZSByZXNwb25zZSB0eXBlXG50eXBlIFNvdXJjZXNSZXNwb25zZSA9IHtcbiAgc291cmNlczogU291cmNlW107XG4gIG1ldGFkYXRhPzoge1xuICAgIGVuZ2luZTogc3RyaW5nO1xuICAgIHRvdGFsUmVzdWx0cz86IG51bWJlcjtcbiAgICBzZWFyY2hUaW1lPzogbnVtYmVyO1xuICAgIGZpbHRlcmVkU291cmNlcz86IG51bWJlcjtcbiAgfTtcbiAgZXJyb3I/OiBzdHJpbmc7XG59O1xuXG4vLyBEZWZpbmUgc2VhcmNoIGVuZ2luZSB0eXBlXG5leHBvcnQgdHlwZSBTZWFyY2hFbmdpbmUgPSBcImdvb2dsZVwiIHwgXCJiaW5nXCIgfCBcImR1Y2tkdWNrZ29cIiB8IFwiYWxsXCI7XG5cbi8vIFRpbWVvdXQgZm9yIGZldGNoIHJlcXVlc3RzICgxNSBzZWNvbmRzKVxuY29uc3QgRkVUQ0hfVElNRU9VVCA9IDE1MDAwO1xuXG4vLyBVc2VyIGFnZW50IHJvdGF0aW9uIGZvciByZXF1ZXN0c1xuY29uc3QgVVNFUl9BR0VOVFMgPSBbXG4gIFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk2LjAuNDY2NC4xMTAgU2FmYXJpLzUzNy4zNlwiLFxuICBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1XzcpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xNS4wIFNhZmFyaS82MDUuMS4xNVwiLFxuICBcIk1vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk2LjAuNDY2NC40NSBTYWZhcmkvNTM3LjM2XCIsXG4gIFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NDsgcnY6OTQuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC85NC4wXCIsXG4gIFwiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxNV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgQ3JpT1MvOTYuMC40NjY0LjUzIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xXCJcbl07XG5cbi8vIEdldCBhIHJhbmRvbSB1c2VyIGFnZW50XG5jb25zdCBnZXRSYW5kb21Vc2VyQWdlbnQgPSAoKSA9PiBVU0VSX0FHRU5UU1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBVU0VSX0FHRU5UUy5sZW5ndGgpXTtcblxuLy8gTWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBmb3IgZmV0Y2ggcmVxdWVzdHNcbmNvbnN0IE1BWF9SRVRSSUVTID0gMztcblxuLy8gRGVsYXkgYmV0d2VlbiByZXRyaWVzIChpbiBtcylcbmNvbnN0IFJFVFJZX0RFTEFZID0gMTAwMDtcblxuLy8gTnVtYmVyIG9mIHNvdXJjZXMgdG8gcmV0dXJuXG5jb25zdCBERUZBVUxUX1NPVVJDRV9DT1VOVCA9IDQ7XG5cbi8vIExpc3Qgb2YgZG9tYWlucyB0byBleGNsdWRlIGZyb20gcmVzdWx0c1xuY29uc3QgRVhDTFVERURfRE9NQUlOUyA9IFtcbiAgXCJnb29nbGVcIiwgXCJmYWNlYm9va1wiLCBcInR3aXR0ZXJcIiwgXCJpbnN0YWdyYW1cIiwgXCJ5b3V0dWJlXCIsIFwidGlrdG9rXCIsXG4gIFwiYmluZ1wiLCBcImR1Y2tkdWNrZ29cIiwgXCJwaW50ZXJlc3RcIiwgXCJsaW5rZWRpblwiLCBcInJlZGRpdFwiLCBcInF1b3JhXCJcbl07XG5cbi8qKlxuICogRW5oYW5jZWQgZmV0Y2ggd2l0aCB0aW1lb3V0LCByZXRyaWVzLCBhbmQgZXhwb25lbnRpYWwgYmFja29mZlxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9LCB0aW1lb3V0ID0gRkVUQ0hfVElNRU9VVCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcblxuICAvLyBUcnkgbXVsdGlwbGUgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dE1zID0gdGltZW91dCAqIChhdHRlbXB0ICsgMSk7IC8vIEluY3JlYXNlIHRpbWVvdXQgd2l0aCBlYWNoIHJldHJ5XG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dE1zKTtcblxuICAgIC8vIEFkZCBkZWZhdWx0IGhlYWRlcnMgaW5jbHVkaW5nIGEgcmFuZG9tIHVzZXIgYWdlbnRcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcbiAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2Uvd2VicCwqLyo7cT0wLjgnLFxuICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuNScsXG4gICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJzogJzEnLFxuICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgJ1ByYWdtYSc6ICduby1jYWNoZScsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IGJldHdlZW4gcmV0cmllcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFJldHJ5IGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZm9yICR7dXJsfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICByZWRpcmVjdDogJ2ZvbGxvdydcbiAgICAgIH0pO1xuXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gc3RhdHVzIGNvZGVzLCB3ZSBtaWdodCB3YW50IHRvIHJldHJ5XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSB8fCByZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgbGFzdEVycm9yID0gbmV3IEVycm9yKGBIVFRQIGVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBSZXRyeVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTsgLy8gUmV0dXJuIHRoZSByZXNwb25zZSBldmVuIGlmIGl0J3Mgbm90IG9rXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuXG4gICAgICAvLyBEb24ndCByZXRyeSBpZiBpdCdzIGEgQ09SUyBlcnJvciBvciBpZiB0aGUgcmVxdWVzdCB3YXMgYWJvcnRlZFxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJyB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdDT1JTJykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmV0cnkgYXR0ZW1wdFxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlJ3ZlIGV4aGF1c3RlZCBhbGwgcmV0cmllcywgdGhyb3cgdGhlIGxhc3QgZXJyb3JcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7dXJsfSBhZnRlciAke01BWF9SRVRSSUVTfSBhdHRlbXB0c2ApO1xufVxuXG4vKipcbiAqIE1haW4gaGFuZGxlciBmb3IgdGhlIHNvdXJjZXMgQVBJXG4gKi9cbmNvbnN0IHNlYXJjaEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2U8U291cmNlc1Jlc3BvbnNlPikgPT4ge1xuICAvLyBPbmx5IGFsbG93IFBPU1QgcmVxdWVzdHNcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IHNvdXJjZXM6IFtdLCBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XG4gIH1cblxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBxdWVyeSwgc2VhcmNoRW5naW5lID0gXCJnb29nbGVcIiwgc291cmNlQ291bnQgPSBERUZBVUxUX1NPVVJDRV9DT1VOVCB9ID0gcmVxLmJvZHkgYXMge1xuICAgICAgcXVlcnk6IHN0cmluZztcbiAgICAgIHNlYXJjaEVuZ2luZT86IFNlYXJjaEVuZ2luZTtcbiAgICAgIHNvdXJjZUNvdW50PzogbnVtYmVyO1xuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgIGlmICghcXVlcnkgfHwgdHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcbiAgICAgICAgc291cmNlczogW10sXG4gICAgICAgIGVycm9yOiAnSW52YWxpZCBxdWVyeSBwcm92aWRlZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIExpbWl0IHNvdXJjZSBjb3VudCB0byByZWFzb25hYmxlIHZhbHVlc1xuICAgIGNvbnN0IGxpbWl0ZWRTb3VyY2VDb3VudCA9IE1hdGgubWluKE1hdGgubWF4KDEsIHNvdXJjZUNvdW50KSwgOCk7XG5cbiAgICBsZXQgYWxsTGlua3M6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHVzZWRFbmdpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gR2V0IGxpbmtzIGZyb20gc2VsZWN0ZWQgc2VhcmNoIGVuZ2luZShzKVxuICAgIGlmIChzZWFyY2hFbmdpbmUgPT09IFwiYWxsXCIpIHtcbiAgICAgIC8vIEZldGNoIGZyb20gYWxsIHNlYXJjaCBlbmdpbmVzIGluIHBhcmFsbGVsXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZnJvbSBhbGwgc2VhcmNoIGVuZ2luZXMgZm9yIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgKTtcblxuICAgICAgY29uc3QgW2dvb2dsZUxpbmtzLCBiaW5nTGlua3MsIGR1Y2tkdWNrZ29MaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEdvb2dsZUxpbmtzKHF1ZXJ5KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIEdvb2dsZSBsaW5rczpcIiwgZXJyKTtcbiAgICAgICAgICByZXR1cm4gW10gYXMgc3RyaW5nW107XG4gICAgICAgIH0pLFxuICAgICAgICBnZXRCaW5nTGlua3MocXVlcnkpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgQmluZyBsaW5rczpcIiwgZXJyKTtcbiAgICAgICAgICByZXR1cm4gW10gYXMgc3RyaW5nW107XG4gICAgICAgIH0pLFxuICAgICAgICBnZXREdWNrRHVja0dvTGlua3MocXVlcnkpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgRHVja0R1Y2tHbyBsaW5rczpcIiwgZXJyKTtcbiAgICAgICAgICByZXR1cm4gW10gYXMgc3RyaW5nW107XG4gICAgICAgIH0pXG4gICAgICBdKTtcblxuICAgICAgY29uc29sZS5sb2coYEZvdW5kIGxpbmtzIC0gR29vZ2xlOiAke2dvb2dsZUxpbmtzLmxlbmd0aH0sIEJpbmc6ICR7YmluZ0xpbmtzLmxlbmd0aH0sIER1Y2tEdWNrR286ICR7ZHVja2R1Y2tnb0xpbmtzLmxlbmd0aH1gKTtcblxuICAgICAgaWYgKGdvb2dsZUxpbmtzLmxlbmd0aCA+IDApIHVzZWRFbmdpbmVzLnB1c2goXCJnb29nbGVcIik7XG4gICAgICBpZiAoYmluZ0xpbmtzLmxlbmd0aCA+IDApIHVzZWRFbmdpbmVzLnB1c2goXCJiaW5nXCIpO1xuICAgICAgaWYgKGR1Y2tkdWNrZ29MaW5rcy5sZW5ndGggPiAwKSB1c2VkRW5naW5lcy5wdXNoKFwiZHVja2R1Y2tnb1wiKTtcblxuICAgICAgYWxsTGlua3MgPSBbLi4uZ29vZ2xlTGlua3MsIC4uLmJpbmdMaW5rcywgLi4uZHVja2R1Y2tnb0xpbmtzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmV0Y2ggZnJvbSBhIHNpbmdsZSBzZWFyY2ggZW5naW5lXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZnJvbSAke3NlYXJjaEVuZ2luZX0gZm9yIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3dpdGNoIChzZWFyY2hFbmdpbmUpIHtcbiAgICAgICAgICBjYXNlIFwiZ29vZ2xlXCI6XG4gICAgICAgICAgICBhbGxMaW5rcyA9IGF3YWl0IGdldEdvb2dsZUxpbmtzKHF1ZXJ5KTtcbiAgICAgICAgICAgIHVzZWRFbmdpbmVzLnB1c2goXCJnb29nbGVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYmluZ1wiOlxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRCaW5nTGlua3MocXVlcnkpO1xuICAgICAgICAgICAgdXNlZEVuZ2luZXMucHVzaChcImJpbmdcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZHVja2R1Y2tnb1wiOlxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXREdWNrRHVja0dvTGlua3MocXVlcnkpO1xuICAgICAgICAgICAgdXNlZEVuZ2luZXMucHVzaChcImR1Y2tkdWNrZ29cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYWxsTGlua3MgPSBhd2FpdCBnZXRHb29nbGVMaW5rcyhxdWVyeSk7XG4gICAgICAgICAgICB1c2VkRW5naW5lcy5wdXNoKFwiZ29vZ2xlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tICR7c2VhcmNoRW5naW5lfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGlua3MgZnJvbSAke3NlYXJjaEVuZ2luZX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBUcnkgR29vZ2xlIGFzIGZhbGxiYWNrIGlmIGFub3RoZXIgZW5naW5lIGZhaWxzXG4gICAgICAgIGlmIChzZWFyY2hFbmdpbmUgIT09IFwiZ29vZ2xlXCIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyeWluZyBHb29nbGUgYXMgZmFsbGJhY2tcIik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFsbExpbmtzID0gYXdhaXQgZ2V0R29vZ2xlTGlua3MocXVlcnkpO1xuICAgICAgICAgICAgdXNlZEVuZ2luZXMgPSBbXCJnb29nbGUgKGZhbGxiYWNrKVwiXTtcbiAgICAgICAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFsbGJhY2sgdG8gR29vZ2xlIGFsc28gZmFpbGVkOlwiLCBmYWxsYmFja0Vycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYW5kIGRlZHVwbGljYXRlIGxpbmtzXG4gICAgY29uc3QgZmlsdGVyZWRMaW5rcyA9IGZpbHRlckFuZERlZHVwbGljYXRlTGlua3MoYWxsTGlua3MpO1xuXG4gICAgLy8gTGltaXQgdG8gcmVxdWVzdGVkIG51bWJlciBvZiBzb3VyY2VzXG4gICAgY29uc3QgZmluYWxMaW5rcyA9IGZpbHRlcmVkTGlua3Muc2xpY2UoMCwgbGltaXRlZFNvdXJjZUNvdW50KTtcblxuICAgIGlmIChmaW5hbExpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgICAgc291cmNlczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZW5naW5lOiB1c2VkRW5naW5lcy5qb2luKCcrJyksXG4gICAgICAgICAgdG90YWxSZXN1bHRzOiAwLFxuICAgICAgICAgIHNlYXJjaFRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgZmlsdGVyZWRTb3VyY2VzOiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNjcmFwZSB0ZXh0IGZyb20gbGlua3Mgd2l0aCB0aW1lb3V0IGFuZCBjb25jdXJyZW5jeSBjb250cm9sXG4gICAgY29uc3Qgc291cmNlcyA9IGF3YWl0IHNjcmFwZVNvdXJjZXNXaXRoVGltZW91dChmaW5hbExpbmtzKTtcblxuICAgIC8vIFByb2Nlc3MgYW5kIGNsZWFuIHVwIHNvdXJjZXNcbiAgICBjb25zdCBwcm9jZXNzZWRTb3VyY2VzID0gcHJvY2Vzc1NvdXJjZXMoc291cmNlcyk7XG5cbiAgICAvLyBJZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGFueSB2YWxpZCBzb3VyY2VzIGFmdGVyIHByb2Nlc3NpbmcsIGNyZWF0ZSBhIGZhbGxiYWNrIHNvdXJjZVxuICAgIGlmIChwcm9jZXNzZWRTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQ3JlYXRlIGEgZmFsbGJhY2sgc291cmNlIHdpdGggc2VhcmNoIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBmYWxsYmFja1NvdXJjZTogU291cmNlID0ge1xuICAgICAgICB1cmw6IGBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gLFxuICAgICAgICB0aXRsZTogYFNlYXJjaCByZXN1bHRzIGZvcjogJHtxdWVyeX1gLFxuICAgICAgICB0ZXh0OiBgV2UgY291bGRuJ3QgZXh0cmFjdCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZWFyY2ggcmVzdWx0cyBmb3IgXCIke3F1ZXJ5fVwiLlxuICAgICAgICBUaGlzIGNvdWxkIGJlIGR1ZSB0byB2YXJpb3VzIHJlYXNvbnMgc3VjaCBhcyB3ZWJzaXRlIHJlc3RyaWN0aW9ucyBvciBjb250ZW50IGZvcm1hdHRpbmcuXG5cbiAgICAgICAgWW91IGNhbiB0cnk6XG4gICAgICAgIDEuIFJlcGhyYXNpbmcgeW91ciBxdWVyeSB0byBiZSBtb3JlIHNwZWNpZmljXG4gICAgICAgIDIuIFVzaW5nIGEgZGlmZmVyZW50IHNlYXJjaCBlbmdpbmUgKHRyeSBCaW5nIG9yIER1Y2tEdWNrR28pXG4gICAgICAgIDMuIFNlYXJjaGluZyBmb3IgYSByZWxhdGVkIGJ1dCBkaWZmZXJlbnQgdG9waWNcblxuICAgICAgICBUaGUgc2VhcmNoIHdhcyBwZXJmb3JtZWQgdXNpbmcgJHt1c2VkRW5naW5lcy5qb2luKCcrJyl9IGFuZCBmb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gcG90ZW50aWFsIHNvdXJjZXMuYFxuICAgICAgfTtcblxuICAgICAgLy8gUmV0dXJuIHRoZSBmYWxsYmFjayBzb3VyY2VcbiAgICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgICAgc291cmNlczogW2ZhbGxiYWNrU291cmNlXSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBlbmdpbmU6IHVzZWRFbmdpbmVzLmpvaW4oJysnKSxcbiAgICAgICAgICB0b3RhbFJlc3VsdHM6IGFsbExpbmtzLmxlbmd0aCxcbiAgICAgICAgICBzZWFyY2hUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIGZpbHRlcmVkU291cmNlczogMSxcbiAgICAgICAgICBmYWxsYmFjazogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0dXJuIHRoZSBwcm9jZXNzZWQgc291cmNlc1xuICAgICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICBzb3VyY2VzOiBwcm9jZXNzZWRTb3VyY2VzLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGVuZ2luZTogdXNlZEVuZ2luZXMuam9pbignKycpLFxuICAgICAgICAgIHRvdGFsUmVzdWx0czogYWxsTGlua3MubGVuZ3RoLFxuICAgICAgICAgIHNlYXJjaFRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgZmlsdGVyZWRTb3VyY2VzOiBwcm9jZXNzZWRTb3VyY2VzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNvdXJjZXMgQVBJOlwiLCBlcnIpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggc291cmNlcy4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVyIGFuZCBkZWR1cGxpY2F0ZSBsaW5rc1xuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmREZWR1cGxpY2F0ZUxpbmtzKGxpbmtzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgLy8gRmlyc3QsIGZpbHRlciBvdXQgaW52YWxpZCBVUkxzIGFuZCBleGNsdWRlZCBkb21haW5zXG4gIGNvbnN0IHZhbGlkTGlua3MgPSBsaW5rcy5maWx0ZXIobGluayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gICAgICBjb25zdCBkb21haW4gPSB1cmwuaG9zdG5hbWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIGRvbWFpbiBpcyBpbiBleGNsdWRlIGxpc3RcbiAgICAgIHJldHVybiAhRVhDTFVERURfRE9NQUlOUy5zb21lKGV4Y2x1ZGVkID0+IGRvbWFpbi5pbmNsdWRlcyhleGNsdWRlZCkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlbiwgZGVkdXBsaWNhdGUgYnkgZG9tYWluXG4gIGNvbnN0IHVuaXF1ZURvbWFpbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcmV0dXJuIHZhbGlkTGlua3MuZmlsdGVyKGxpbmsgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkb21haW4gPSBuZXcgVVJMKGxpbmspLmhvc3RuYW1lO1xuICAgICAgaWYgKHVuaXF1ZURvbWFpbnMuaGFzKGRvbWFpbikpIHJldHVybiBmYWxzZTtcblxuICAgICAgdW5pcXVlRG9tYWlucy5hZGQoZG9tYWluKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbmQgY2xlYW4gdXAgc291cmNlc1xuICovXG5mdW5jdGlvbiBwcm9jZXNzU291cmNlcyhzb3VyY2VzOiBTb3VyY2VbXSk6IFNvdXJjZVtdIHtcbiAgY29uc3QgZmlsdGVyZWRTb3VyY2VzID0gc291cmNlcy5maWx0ZXIoc291cmNlID0+XG4gICAgc291cmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICBzb3VyY2UudGV4dCAmJlxuICAgIHNvdXJjZS50ZXh0Lmxlbmd0aCA+IDEwMFxuICApO1xuXG4gIC8vIFRydW5jYXRlIGxvbmcgdGV4dHMgYW5kIGFkZCBtZXRhZGF0YVxuICByZXR1cm4gZmlsdGVyZWRTb3VyY2VzLm1hcChzb3VyY2UgPT4gKHtcbiAgICAuLi5zb3VyY2UsXG4gICAgdGV4dDogc291cmNlLnRleHQuc2xpY2UoMCwgMTUwMCksXG4gICAgdGl0bGU6IGV4dHJhY3RUaXRsZShzb3VyY2UudXJsKVxuICB9KSk7XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIHJlYWRhYmxlIHRpdGxlIGZyb20gVVJMXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RUaXRsZSh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBob3N0bmFtZSwgcGF0aG5hbWUgfSA9IG5ldyBVUkwodXJsKTtcblxuICAgIC8vIEdldCBkb21haW4gd2l0aG91dCB3d3dcbiAgICBjb25zdCBkb21haW4gPSBob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXG4gICAgLy8gR2V0IGxhc3QgcGF0aCBzZWdtZW50IHdpdGhvdXQgZXh0ZW5zaW9uXG4gICAgY29uc3QgcGF0aFNlZ21lbnQgPSBwYXRobmFtZS5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKS5wb3AoKSB8fCAnJztcbiAgICBjb25zdCBjbGVhblBhdGhTZWdtZW50ID0gcGF0aFNlZ21lbnQucmVwbGFjZSgvXFwuXFx3KyQvLCAnJykucmVwbGFjZSgvLXxfL2csICcgJyk7XG5cbiAgICBpZiAoY2xlYW5QYXRoU2VnbWVudCkge1xuICAgICAgcmV0dXJuIGAke2NsZWFuUGF0aFNlZ21lbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjbGVhblBhdGhTZWdtZW50LnNsaWNlKDEpfSAtICR7ZG9tYWlufWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufVxuXG4vKipcbiAqIFNjcmFwZSBzb3VyY2VzIHdpdGggdGltZW91dFxuICovXG4vKipcbiAqIEFkdmFuY2VkIHdlYiBzY3JhcGluZyB3aXRoIG11bHRpcGxlIGV4dHJhY3Rpb24gdGVjaG5pcXVlcyBhbmQgc21hcnQgY29udGVudCBkZXRlY3Rpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2NyYXBlU291cmNlc1dpdGhUaW1lb3V0KGxpbmtzOiBzdHJpbmdbXSk6IFByb21pc2U8U291cmNlW10+IHtcbiAgLy8gVXNlIGEgbW9yZSBjb250cm9sbGVkIGFwcHJvYWNoIHdpdGggY29uY3VycmVuY3kgbGltaXQgYW5kIHByaW9yaXRpemF0aW9uXG4gIGNvbnN0IE1BWF9DT05DVVJSRU5UID0gNDtcbiAgY29uc3QgcmVzdWx0czogKFNvdXJjZSB8IG51bGwpW10gPSBbXTtcblxuICAvLyBQcmlvcml0aXplIGxpbmtzIGJhc2VkIG9uIGRvbWFpbiByZXB1dGF0aW9uIGFuZCBVUkwgc3RydWN0dXJlXG4gIGNvbnN0IHByaW9yaXRpemVkTGlua3MgPSBwcmlvcml0aXplTGlua3MoWy4uLmxpbmtzXSk7XG4gIGNvbnN0IHBlbmRpbmdMaW5rcyA9IHByaW9yaXRpemVkTGlua3M7XG5cbiAgY29uc29sZS5sb2coYFNjcmFwaW5nICR7cGVuZGluZ0xpbmtzLmxlbmd0aH0gbGlua3Mgd2l0aCBwcmlvcml0eSBvcmRlcmApO1xuXG4gIC8vIFByb2Nlc3MgbGlua3MgaW4gYmF0Y2hlcyB0byBjb250cm9sIGNvbmN1cnJlbmN5XG4gIHdoaWxlIChwZW5kaW5nTGlua3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGJhdGNoID0gcGVuZGluZ0xpbmtzLnNwbGljZSgwLCBNQVhfQ09OQ1VSUkVOVCk7XG4gICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgYmF0Y2ggb2YgJHtiYXRjaC5sZW5ndGh9IGxpbmtzYCk7XG5cbiAgICBjb25zdCBiYXRjaFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGJhdGNoLm1hcChhc3luYyAobGluaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXNcbiAgICAgICAgICBmb3IgKGxldCB0ZWNobmlxdWUgPSAwOyB0ZWNobmlxdWUgPCAzOyB0ZWNobmlxdWUrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nICR7bGlua30gd2l0aCB0ZWNobmlxdWUgJHt0ZWNobmlxdWUgKyAxfWApO1xuXG4gICAgICAgICAgICAgIC8vIEFkanVzdCB0aW1lb3V0IGJhc2VkIG9uIHRlY2huaXF1ZVxuICAgICAgICAgICAgICBjb25zdCB0ZWNobmlxdWVUaW1lb3V0ID0gRkVUQ0hfVElNRU9VVCArICh0ZWNobmlxdWUgKiA1MDAwKTtcblxuICAgICAgICAgICAgICAvLyBVc2UgZGlmZmVyZW50IGZldGNoIG9wdGlvbnMgYmFzZWQgb24gdGVjaG5pcXVlXG4gICAgICAgICAgICAgIGNvbnN0IGZldGNoT3B0aW9uczogUmVxdWVzdEluaXQgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgLy8gQWRkIHJlZmVyZXIgZm9yIHNvbWUgdGVjaG5pcXVlc1xuICAgICAgICAgICAgICAgICAgLi4uKHRlY2huaXF1ZSA+IDAgPyB7ICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vJyB9IDoge30pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChsaW5rLCBmZXRjaE9wdGlvbnMsIHRlY2huaXF1ZVRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCAke2xpbmt9OiAke3Jlc3BvbnNlLnN0YXR1c30sIHRlY2huaXF1ZSAke3RlY2huaXF1ZSArIDF9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgY2VydGFpbiBzdGF0dXMgY29kZXMsIHdlIG1pZ2h0IHdhbnQgdG8gc2tpcCB0byBuZXh0IHRlY2huaXF1ZVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIHN0YXR1cyBjb2Rlcywgd2UgbWlnaHQgd2FudCB0byB0cnkgYSBkaWZmZXJlbnQgYXBwcm9hY2hcbiAgICAgICAgICAgICAgICBpZiAodGVjaG5pcXVlIDwgMikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBHaXZlIHVwIG9uIHRoaXMgbGluayBhZnRlciBhbGwgdGVjaG5pcXVlcyBmYWlsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR2V0IGNvbnRlbnQgdHlwZSB0byBoYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIGNvbnRlbnRcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG5cbiAgICAgICAgICAgICAgLy8gU2tpcCBub24tSFRNTCBjb250ZW50XG4gICAgICAgICAgICAgIGlmICghY29udGVudFR5cGUuaW5jbHVkZXMoJ3RleHQvaHRtbCcpICYmXG4gICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcpICYmXG4gICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgbm9uLUhUTUwgY29udGVudDogJHtjb250ZW50VHlwZX0gZm9yICR7bGlua31gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBnb3QgYSB2ZXJ5IHNtYWxsIHJlc3BvbnNlIChsaWtlbHkgYW4gZXJyb3IgcGFnZSlcbiAgICAgICAgICAgICAgaWYgKGh0bWwubGVuZ3RoIDwgODAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUb28gc21hbGwgcmVzcG9uc2UgZnJvbSAke2xpbmt9OiAke2h0bWwubGVuZ3RofSBjaGFyc2ApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBlcnJvciBwYXR0ZXJucyBpbiB0aGUgSFRNTFxuICAgICAgICAgICAgICBpZiAoaHRtbC5pbmNsdWRlcygnY2FwdGNoYScpIHx8XG4gICAgICAgICAgICAgICAgICBodG1sLmluY2x1ZGVzKCdDQVBUQ0hBJykgfHxcbiAgICAgICAgICAgICAgICAgIGh0bWwuaW5jbHVkZXMoJ2FjY2VzcyBkZW5pZWQnKSB8fFxuICAgICAgICAgICAgICAgICAgaHRtbC5pbmNsdWRlcygnQWNjZXNzIERlbmllZCcpIHx8XG4gICAgICAgICAgICAgICAgICBodG1sLmluY2x1ZGVzKCc0MDMgRm9yYmlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERldGVjdGVkIGFjY2VzcyByZXN0cmljdGlvbiBpbiAke2xpbmt9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgSFRNTCB3aXRoIGRpZmZlcmVudCBtZXRob2RzIGJhc2VkIG9uIHRlY2huaXF1ZVxuICAgICAgICAgICAgICBsZXQgZXh0cmFjdGVkQ29udGVudDogeyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgIC8vIFRlY2huaXF1ZSAxOiBVc2UgUmVhZGFiaWxpdHlcbiAgICAgICAgICAgICAgaWYgKHRlY2huaXF1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgPSBhd2FpdCBleHRyYWN0V2l0aFJlYWRhYmlsaXR5KGh0bWwsIGxpbmspO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVGVjaG5pcXVlIDI6IFVzZSBjdXN0b20gY29udGVudCBleHRyYWN0aW9uXG4gICAgICAgICAgICAgIGlmICh0ZWNobmlxdWUgPT09IDEgfHwgIWV4dHJhY3RlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFdpdGhDdXN0b21TZWxlY3RvcnMoaHRtbCwgbGluayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUZWNobmlxdWUgMzogVXNlIHNpbXBsaWZpZWQgZXh0cmFjdGlvblxuICAgICAgICAgICAgICBpZiAodGVjaG5pcXVlID09PSAyIHx8ICFleHRyYWN0ZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCA9IGF3YWl0IGV4dHJhY3RXaXRoU2ltcGxpZmllZE1ldGhvZChodG1sLCBsaW5rKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIHdlIHN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgY29udGVudFxuICAgICAgICAgICAgICBpZiAoZXh0cmFjdGVkQ29udGVudCAmJiBleHRyYWN0ZWRDb250ZW50LnRleHQubGVuZ3RoID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgJHtleHRyYWN0ZWRDb250ZW50LnRleHQubGVuZ3RofSBjaGFycyBmcm9tICR7bGlua31gKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIGFuZCBwcm9jZXNzIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9IHByb2Nlc3NFeHRyYWN0ZWRUZXh0KGV4dHJhY3RlZENvbnRlbnQudGV4dCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdXJsOiBsaW5rLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcHJvY2Vzc2VkVGV4dCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBleHRyYWN0ZWRDb250ZW50LnRpdGxlIHx8IGV4dHJhY3RUaXRsZShsaW5rKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBjYXRjaCAodGVjaG5pcXVlRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUZWNobmlxdWUgJHt0ZWNobmlxdWUgKyAxfSBmYWlsZWQgZm9yICR7bGlua306YCwgdGVjaG5pcXVlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFsbCB0ZWNobmlxdWVzIGZhaWxlZFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFsbCBleHRyYWN0aW9uIHRlY2huaXF1ZXMgZmFpbGVkIGZvciAke2xpbmt9YCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2NyYXBpbmcgJHtsaW5rfTpgLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJlc3VsdHMucHVzaCguLi5iYXRjaFJlc3VsdHMpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZ29vZCByZXN1bHRzLCB3ZSBjYW4gc3RvcCBlYXJseVxuICAgIGNvbnN0IHZhbGlkUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKEJvb2xlYW4pIGFzIFNvdXJjZVtdO1xuICAgIGlmICh2YWxpZFJlc3VsdHMubGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBHb3QgJHt2YWxpZFJlc3VsdHMubGVuZ3RofSBnb29kIHJlc3VsdHMsIHN0b3BwaW5nIGVhcmx5YCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBGaWx0ZXIgb3V0IG51bGwgcmVzdWx0cyBhbmQgZW5zdXJlIHdlIGhhdmUgYXQgbGVhc3Qgc29tZSBjb250ZW50XG4gIGNvbnN0IHZhbGlkU291cmNlcyA9IHJlc3VsdHMuZmlsdGVyKEJvb2xlYW4pIGFzIFNvdXJjZVtdO1xuXG4gIC8vIFNvcnQgc291cmNlcyBieSBjb250ZW50IHF1YWxpdHkgKGxlbmd0aCBhbmQgcmVhZGFiaWxpdHkpXG4gIGNvbnN0IHNvcnRlZFNvdXJjZXMgPSBzb3J0U291cmNlc0J5UXVhbGl0eSh2YWxpZFNvdXJjZXMpO1xuXG4gIC8vIElmIHdlIGhhdmUgbm8gdmFsaWQgc291cmNlcywgY3JlYXRlIGludGVsbGlnZW50IGZhbGxiYWNrIHNvdXJjZXNcbiAgaWYgKHNvcnRlZFNvdXJjZXMubGVuZ3RoID09PSAwICYmIGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zb2xlLmxvZyhcIk5vIHZhbGlkIHNvdXJjZXMgZm91bmQsIGNyZWF0aW5nIGZhbGxiYWNrIHNvdXJjZXNcIik7XG4gICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrU291cmNlcyhsaW5rcyk7XG4gIH1cblxuICByZXR1cm4gc29ydGVkU291cmNlcztcbn1cblxuLyoqXG4gKiBQcmlvcml0aXplIGxpbmtzIGJhc2VkIG9uIGRvbWFpbiByZXB1dGF0aW9uIGFuZCBVUkwgc3RydWN0dXJlXG4gKi9cbmZ1bmN0aW9uIHByaW9yaXRpemVMaW5rcyhsaW5rczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIC8vIFNjb3JlIGVhY2ggbGlua1xuICBjb25zdCBzY29yZWRMaW5rcyA9IGxpbmtzLm1hcChsaW5rID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChsaW5rKTtcbiAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgIC8vIFByZWZlciBjZXJ0YWluIGRvbWFpbnNcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gdXJsLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIC8vIEhpZ2hlciBzY29yZSBmb3IgcmVwdXRhYmxlIGRvbWFpbnNcbiAgICAgIGlmIChob3N0bmFtZS5pbmNsdWRlcygnLmVkdScpIHx8XG4gICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJy5nb3YnKSB8fFxuICAgICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCd3aWtpcGVkaWEub3JnJykgfHxcbiAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnZ2l0aHViLmNvbScpIHx8XG4gICAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ3N0YWNrb3ZlcmZsb3cuY29tJykgfHxcbiAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnbWVkaXVtLmNvbScpKSB7XG4gICAgICAgIHNjb3JlICs9IDMwO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXIgc2hvcnRlciBVUkxzIChvZnRlbiBtYWluIHBhZ2VzKVxuICAgICAgc2NvcmUgLT0gdXJsLnBhdGhuYW1lLnNwbGl0KCcvJykubGVuZ3RoICogMjtcblxuICAgICAgLy8gUHJlZmVyIFVSTHMgd2l0aG91dCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICBzY29yZSAtPSB1cmwuc2VhcmNoLmxlbmd0aCA+IDAgPyA1IDogMDtcblxuICAgICAgLy8gQXZvaWQgY2VydGFpbiBwYXR0ZXJuc1xuICAgICAgaWYgKHVybC5wYXRobmFtZS5pbmNsdWRlcygnbG9naW4nKSB8fFxuICAgICAgICAgIHVybC5wYXRobmFtZS5pbmNsdWRlcygnc2lnbnVwJykgfHxcbiAgICAgICAgICB1cmwucGF0aG5hbWUuaW5jbHVkZXMoJ2FjY291bnQnKSkge1xuICAgICAgICBzY29yZSAtPSAyMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgbGluaywgc2NvcmUgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB7IGxpbmssIHNjb3JlOiAtMTAwIH07IC8vIEludmFsaWQgVVJMcyBnZXQgbG93ZXN0IHByaW9yaXR5XG4gICAgfVxuICB9KTtcblxuICAvLyBTb3J0IGJ5IHNjb3JlIChoaWdoZXN0IGZpcnN0KVxuICBzY29yZWRMaW5rcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG5cbiAgLy8gUmV0dXJuIGp1c3QgdGhlIGxpbmtzXG4gIHJldHVybiBzY29yZWRMaW5rcy5tYXAoaXRlbSA9PiBpdGVtLmxpbmspO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgY29udGVudCB1c2luZyBNb3ppbGxhJ3MgUmVhZGFiaWxpdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFdpdGhSZWFkYWJpbGl0eShodG1sOiBzdHJpbmcsIHVybDogc3RyaW5nKTogUHJvbWlzZTx7IHRleHQ6IHN0cmluZywgdGl0bGU6IHN0cmluZyB9IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRvbSA9IG5ldyBKU0RPTShodG1sLCB7XG4gICAgICB1cmwsXG4gICAgICBydW5TY3JpcHRzOiBcIm91dHNpZGUtb25seVwiLFxuICAgICAgcHJldGVuZFRvQmVWaXN1YWw6IHRydWVcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkYWJpbGl0eShkb20ud2luZG93LmRvY3VtZW50KTtcbiAgICBjb25zdCBhcnRpY2xlID0gcmVhZGVyLnBhcnNlKCk7XG5cbiAgICBpZiAoYXJ0aWNsZSAmJiBhcnRpY2xlLnRleHRDb250ZW50ICYmIGFydGljbGUudGV4dENvbnRlbnQubGVuZ3RoID4gMjAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBhcnRpY2xlLnRleHRDb250ZW50LFxuICAgICAgICB0aXRsZTogYXJ0aWNsZS50aXRsZSB8fCBkb20ud2luZG93LmRvY3VtZW50LnRpdGxlIHx8IGV4dHJhY3RUaXRsZSh1cmwpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgUmVhZGFiaWxpdHkgZXh0cmFjdGlvbiBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbnRlbnQgdXNpbmcgY3VzdG9tIHNlbGVjdG9ycyBmb3IgZGlmZmVyZW50IHNpdGUgdHlwZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFdpdGhDdXN0b21TZWxlY3RvcnMoaHRtbDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkb20gPSBuZXcgSlNET00oaHRtbCwgeyB1cmwgfSk7XG4gICAgY29uc3QgZG9jID0gZG9tLndpbmRvdy5kb2N1bWVudDtcblxuICAgIC8vIEdldCB0aGUgaG9zdG5hbWUgdG8gYXBwbHkgc2l0ZS1zcGVjaWZpYyBzZWxlY3RvcnNcbiAgICBjb25zdCBob3N0bmFtZSA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRGVmaW5lIHNlbGVjdG9ycyBmb3IgZGlmZmVyZW50IHNpdGUgdHlwZXNcbiAgICBsZXQgc2VsZWN0b3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gV2lraXBlZGlhLXNwZWNpZmljIHNlbGVjdG9yc1xuICAgIGlmIChob3N0bmFtZS5pbmNsdWRlcygnd2lraXBlZGlhLm9yZycpKSB7XG4gICAgICBzZWxlY3RvcnMgPSBbJyNtdy1jb250ZW50LXRleHQnLCAnLm13LXBhcnNlci1vdXRwdXQnXTtcbiAgICB9XG4gICAgLy8gR2l0SHViLXNwZWNpZmljIHNlbGVjdG9yc1xuICAgIGVsc2UgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRodWIuY29tJykpIHtcbiAgICAgIHNlbGVjdG9ycyA9IFsnLm1hcmtkb3duLWJvZHknLCAnYXJ0aWNsZS5tYXJrZG93bi1ib2R5JywgJy5yZXBvc2l0b3J5LWNvbnRlbnQnXTtcbiAgICB9XG4gICAgLy8gU3RhY2tPdmVyZmxvdy1zcGVjaWZpYyBzZWxlY3RvcnNcbiAgICBlbHNlIGlmIChob3N0bmFtZS5pbmNsdWRlcygnc3RhY2tvdmVyZmxvdy5jb20nKSkge1xuICAgICAgc2VsZWN0b3JzID0gWycucG9zdC10ZXh0JywgJy5hbnN3ZXInXTtcbiAgICB9XG4gICAgLy8gTmV3cyBzaXRlIHNlbGVjdG9yc1xuICAgIGVsc2UgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCduZXdzJykgfHxcbiAgICAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnYmJjJykgfHxcbiAgICAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnY25uJykgfHxcbiAgICAgICAgICAgICBob3N0bmFtZS5pbmNsdWRlcygnbnl0aW1lcycpKSB7XG4gICAgICBzZWxlY3RvcnMgPSBbJy5hcnRpY2xlLWJvZHknLCAnLnN0b3J5LWJvZHknLCAnLmFydGljbGVfX2NvbnRlbnQnLCAnW2l0ZW1wcm9wPVwiYXJ0aWNsZUJvZHlcIl0nXTtcbiAgICB9XG4gICAgLy8gRGVmYXVsdCBjb250ZW50IHNlbGVjdG9yc1xuICAgIGVsc2Uge1xuICAgICAgc2VsZWN0b3JzID0gW1xuICAgICAgICAnbWFpbicsICdhcnRpY2xlJywgJ1tyb2xlPVwibWFpblwiXScsICcjY29udGVudCcsICcuY29udGVudCcsXG4gICAgICAgICcucG9zdC1jb250ZW50JywgJy5lbnRyeS1jb250ZW50JywgJy5hcnRpY2xlLWNvbnRlbnQnLCAnLnBvc3QtYm9keScsXG4gICAgICAgICcucGFnZS1jb250ZW50JywgJy5tYWluLWNvbnRlbnQnLCAnLmJvZHktY29udGVudCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgLy8gVHJ5IGVhY2ggc2VsZWN0b3JcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDb21iaW5lIHRleHQgZnJvbSBhbGwgbWF0Y2hpbmcgZWxlbWVudHNcbiAgICAgICAgbGV0IGNvbWJpbmVkVGV4dCA9ICcnO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBjb21iaW5lZFRleHQgKz0gZWwudGV4dENvbnRlbnQgKyAnXFxuXFxuJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbWJpbmVkVGV4dC5sZW5ndGggPiAyMDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogY29tYmluZWRUZXh0LFxuICAgICAgICAgICAgdGl0bGU6IGRvYy50aXRsZSB8fCBleHRyYWN0VGl0bGUodXJsKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBjb250ZW50IGZvdW5kIHdpdGggc2VsZWN0b3JzLCB0cnkgdG8gZmluZCB0aGUgbGFyZ2VzdCB0ZXh0IGJsb2NrXG4gICAgY29uc3QgdGV4dEJsb2NrcyA9IGZpbmRMYXJnZXN0VGV4dEJsb2Nrcyhkb2MpO1xuICAgIGlmICh0ZXh0QmxvY2tzICYmIHRleHRCbG9ja3MubGVuZ3RoID4gMjAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiB0ZXh0QmxvY2tzLFxuICAgICAgICB0aXRsZTogZG9jLnRpdGxlIHx8IGV4dHJhY3RUaXRsZSh1cmwpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgQ3VzdG9tIGV4dHJhY3Rpb24gZmFpbGVkIGZvciAke3VybH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBjb250ZW50IHVzaW5nIGEgc2ltcGxpZmllZCBtZXRob2QgKGZhbGxiYWNrKVxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFNpbXBsaWZpZWRNZXRob2QoaHRtbDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgY2hlZXJpbyBmb3IgbGlnaHR3ZWlnaHQgcGFyc2luZ1xuICAgIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XG5cbiAgICAvLyBSZW1vdmUgc2NyaXB0LCBzdHlsZSwgbmF2LCBmb290ZXIsIGFuZCBvdGhlciBub24tY29udGVudCBlbGVtZW50c1xuICAgICQoJ3NjcmlwdCwgc3R5bGUsIG5hdiwgZm9vdGVyLCBoZWFkZXIsIGFzaWRlLCAuc2lkZWJhciwgLmZvb3RlciwgLmhlYWRlciwgLm5hdmlnYXRpb24sIC5uYXYsIC5tZW51LCAuY29tbWVudHMsIC5hZHMsIC5hZCcpLnJlbW92ZSgpO1xuXG4gICAgLy8gR2V0IHRoZSB0aXRsZVxuICAgIGNvbnN0IHRpdGxlID0gJCgndGl0bGUnKS50ZXh0KCkgfHwgZXh0cmFjdFRpdGxlKHVybCk7XG5cbiAgICAvLyBHZXQgYWxsIHBhcmFncmFwaHNcbiAgICBjb25zdCBwYXJhZ3JhcGhzOiBzdHJpbmdbXSA9IFtdO1xuICAgICQoJ3AnKS5lYWNoKChfLCBlbCkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9ICQoZWwpLnRleHQoKS50cmltKCk7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAyMCkgeyAvLyBPbmx5IGluY2x1ZGUgc3Vic3RhbnRpYWwgcGFyYWdyYXBoc1xuICAgICAgICBwYXJhZ3JhcGhzLnB1c2godGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiB3ZSBmb3VuZCBwYXJhZ3JhcGhzLCBqb2luIHRoZW1cbiAgICBpZiAocGFyYWdyYXBocy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhzLmpvaW4oJ1xcblxcbicpLFxuICAgICAgICB0aXRsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjazogZ2V0IGFsbCB0ZXh0IGZyb20gYm9keVxuICAgIGNvbnN0IGJvZHlUZXh0ID0gJCgnYm9keScpLnRleHQoKTtcbiAgICBpZiAoYm9keVRleHQubGVuZ3RoID4gMjAwKSB7XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgdGV4dFxuICAgICAgY29uc3QgY2xlYW5lZFRleHQgPSBib2R5VGV4dFxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKGxpbmUgPT4gbGluZS50cmltKCkpXG4gICAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDIwKVxuICAgICAgICAuam9pbignXFxuXFxuJyk7XG5cbiAgICAgIGlmIChjbGVhbmVkVGV4dC5sZW5ndGggPiAyMDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0OiBjbGVhbmVkVGV4dCxcbiAgICAgICAgICB0aXRsZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgU2ltcGxpZmllZCBleHRyYWN0aW9uIGZhaWxlZCBmb3IgJHt1cmx9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGxhcmdlc3QgdGV4dCBibG9ja3MgaW4gYSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBmaW5kTGFyZ2VzdFRleHRCbG9ja3MoZG9jOiBEb2N1bWVudCk6IHN0cmluZyB7XG4gIC8vIEdldCBhbGwgZWxlbWVudHMgd2l0aCBzdWJzdGFudGlhbCB0ZXh0XG4gIGNvbnN0IHRleHRFbGVtZW50czoge2VsZW1lbnQ6IEVsZW1lbnQsIGxlbmd0aDogbnVtYmVyfVtdID0gW107XG5cbiAgLy8gRnVuY3Rpb24gdG8gcmVjdXJzaXZlbHkgcHJvY2VzcyBlbGVtZW50c1xuICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudChlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgLy8gU2tpcCBjZXJ0YWluIGVsZW1lbnRzXG4gICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChbJ3NjcmlwdCcsICdzdHlsZScsICduYXYnLCAnaGVhZGVyJywgJ2Zvb3RlciddLmluY2x1ZGVzKHRhZ05hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBlbGVtZW50IGhhcyBkaXJlY3QgdGV4dFxuICAgIGNvbnN0IGRpcmVjdFRleHQgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2RlcylcbiAgICAgIC5maWx0ZXIobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSAzKSAvLyBUZXh0IG5vZGVzIG9ubHlcbiAgICAgIC5tYXAobm9kZSA9PiBub2RlLnRleHRDb250ZW50IHx8ICcnKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAudHJpbSgpO1xuXG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBzdWJzdGFudGlhbCBkaXJlY3QgdGV4dCwgYWRkIGl0XG4gICAgaWYgKGRpcmVjdFRleHQubGVuZ3RoID4gNTApIHtcbiAgICAgIHRleHRFbGVtZW50cy5wdXNoKHtlbGVtZW50LCBsZW5ndGg6IGRpcmVjdFRleHQubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBjaGlsZHJlblxuICAgIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaChwcm9jZXNzRWxlbWVudCk7XG4gIH1cblxuICAvLyBTdGFydCBwcm9jZXNzaW5nIGZyb20gYm9keVxuICBwcm9jZXNzRWxlbWVudChkb2MuYm9keSk7XG5cbiAgLy8gU29ydCBieSB0ZXh0IGxlbmd0aCAobGFyZ2VzdCBmaXJzdClcbiAgdGV4dEVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xuXG4gIC8vIFRha2UgdGhlIHRvcCBlbGVtZW50cyB0aGF0IGxpa2VseSBjb250YWluIG1haW4gY29udGVudFxuICBjb25zdCBtYWluQ29udGVudEVsZW1lbnRzID0gdGV4dEVsZW1lbnRzLnNsaWNlKDAsIDEwKTtcblxuICAvLyBFeHRyYWN0IGFuZCBqb2luIHRoZWlyIHRleHRcbiAgcmV0dXJuIG1haW5Db250ZW50RWxlbWVudHNcbiAgICAubWFwKGl0ZW0gPT4gaXRlbS5lbGVtZW50LnRleHRDb250ZW50IHx8ICcnKVxuICAgIC5qb2luKCdcXG5cXG4nKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuZCBjbGVhbiBleHRyYWN0ZWQgdGV4dFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXh0cmFjdGVkVGV4dCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHdoaXRlc3BhY2VcbiAgbGV0IHByb2Nlc3NlZCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gIC8vIFNwbGl0IGludG8gbGluZXMgYW5kIGNsZWFuIGVhY2ggbGluZVxuICBwcm9jZXNzZWQgPSBwcm9jZXNzZWRcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIC5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApXG4gICAgLmpvaW4oJ1xcbicpO1xuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGUgcGFyYWdyYXBoc1xuICBjb25zdCBwYXJhZ3JhcGhzID0gcHJvY2Vzc2VkLnNwbGl0KCdcXG5cXG4nKTtcbiAgY29uc3QgdW5pcXVlUGFyYWdyYXBocyA9IEFycmF5LmZyb20obmV3IFNldChwYXJhZ3JhcGhzKSk7XG4gIHByb2Nlc3NlZCA9IHVuaXF1ZVBhcmFncmFwaHMuam9pbignXFxuXFxuJyk7XG5cbiAgLy8gTGltaXQgbGVuZ3RoIHRvIGF2b2lkIGV4dHJlbWVseSBsb25nIHRleHRzXG4gIGlmIChwcm9jZXNzZWQubGVuZ3RoID4gODAwMCkge1xuICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5zdWJzdHJpbmcoMCwgODAwMCkgKyAnLi4uJztcbiAgfVxuXG4gIHJldHVybiBwcm9jZXNzZWQ7XG59XG5cbi8qKlxuICogU29ydCBzb3VyY2VzIGJ5IHF1YWxpdHlcbiAqL1xuZnVuY3Rpb24gc29ydFNvdXJjZXNCeVF1YWxpdHkoc291cmNlczogU291cmNlW10pOiBTb3VyY2VbXSB7XG4gIHJldHVybiBbLi4uc291cmNlc10uc29ydCgoYSwgYikgPT4ge1xuICAgIC8vIENhbGN1bGF0ZSBxdWFsaXR5IHNjb3JlIGJhc2VkIG9uIHRleHQgbGVuZ3RoIGFuZCBvdGhlciBmYWN0b3JzXG4gICAgY29uc3Qgc2NvcmVBID0gY2FsY3VsYXRlQ29udGVudFF1YWxpdHlTY29yZShhKTtcbiAgICBjb25zdCBzY29yZUIgPSBjYWxjdWxhdGVDb250ZW50UXVhbGl0eVNjb3JlKGIpO1xuXG4gICAgcmV0dXJuIHNjb3JlQiAtIHNjb3JlQTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnRlbnQgcXVhbGl0eSBzY29yZVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250ZW50UXVhbGl0eVNjb3JlKHNvdXJjZTogU291cmNlKTogbnVtYmVyIHtcbiAgbGV0IHNjb3JlID0gMDtcblxuICAvLyBMZW5ndGggaXMgYSBwcmltYXJ5IGZhY3RvclxuICBzY29yZSArPSBNYXRoLm1pbihzb3VyY2UudGV4dC5sZW5ndGggLyAxMDAsIDUwKTtcblxuICAvLyBQcmVmZXIgc291cmNlcyB3aXRoIHRpdGxlc1xuICBzY29yZSArPSBzb3VyY2UudGl0bGUgPyAxMCA6IDA7XG5cbiAgLy8gUHJlZmVyIHNvdXJjZXMgZnJvbSByZXB1dGFibGUgZG9tYWluc1xuICB0cnkge1xuICAgIGNvbnN0IGhvc3RuYW1lID0gbmV3IFVSTChzb3VyY2UudXJsKS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChob3N0bmFtZS5pbmNsdWRlcygnLmVkdScpIHx8XG4gICAgICAgIGhvc3RuYW1lLmluY2x1ZGVzKCcuZ292JykgfHxcbiAgICAgICAgaG9zdG5hbWUuaW5jbHVkZXMoJ3dpa2lwZWRpYS5vcmcnKSkge1xuICAgICAgc2NvcmUgKz0gMjA7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBJbnZhbGlkIFVSTFxuICB9XG5cbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBmYWxsYmFjayBzb3VyY2VzIHdoZW4gZXh0cmFjdGlvbiBmYWlsc1xuICovXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1NvdXJjZXMobGlua3M6IHN0cmluZ1tdKTogU291cmNlW10ge1xuICAvLyBDcmVhdGUgYXQgbGVhc3Qgb25lIGZhbGxiYWNrIHNvdXJjZVxuICBjb25zdCBmYWxsYmFja1NvdXJjZXM6IFNvdXJjZVtdID0gW107XG5cbiAgLy8gVHJ5IHRvIGNyZWF0ZSBzb3VyY2VzIGZyb20gdGhlIHRvcCAzIGxpbmtzXG4gIGNvbnN0IHRvcExpbmtzID0gbGlua3Muc2xpY2UoMCwgMyk7XG5cbiAgZm9yIChjb25zdCBsaW5rIG9mIHRvcExpbmtzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IG5ldyBVUkwobGluaykuaG9zdG5hbWUucmVwbGFjZSgnd3d3LicsICcnKTtcblxuICAgICAgZmFsbGJhY2tTb3VyY2VzLnB1c2goe1xuICAgICAgICB1cmw6IGxpbmssXG4gICAgICAgIHRleHQ6IGBUaGlzIGluZm9ybWF0aW9uIGlzIGZyb20gJHtkb21haW59LiBUaGUgY29udGVudCBjb3VsZCBub3QgYmUgZnVsbHkgZXh0cmFjdGVkIGR1ZSB0byB3ZWJzaXRlIHJlc3RyaWN0aW9ucy4gUGxlYXNlIHZpc2l0IHRoZSB3ZWJzaXRlIGRpcmVjdGx5IGZvciBjb21wbGV0ZSBpbmZvcm1hdGlvbi5gLFxuICAgICAgICB0aXRsZTogYEluZm9ybWF0aW9uIGZyb20gJHtkb21haW59YFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGNvdWxkbid0IGNyZWF0ZSBhbnkgZmFsbGJhY2sgc291cmNlcywgY3JlYXRlIGEgZ2VuZXJpYyBvbmVcbiAgaWYgKGZhbGxiYWNrU291cmNlcy5sZW5ndGggPT09IDAgJiYgbGlua3MubGVuZ3RoID4gMCkge1xuICAgIGZhbGxiYWNrU291cmNlcy5wdXNoKHtcbiAgICAgIHVybDogbGlua3NbMF0sXG4gICAgICB0ZXh0OiBgSW5mb3JtYXRpb24gY291bGQgbm90IGJlIHJldHJpZXZlZCBmcm9tIHRoZSBzb3VyY2VzLiBUaGlzIG1pZ2h0IGJlIGR1ZSB0byB3ZWJzaXRlIHJlc3RyaWN0aW9ucyBvciB0ZWNobmljYWwgbGltaXRhdGlvbnMuIFRyeSByZWZpbmluZyB5b3VyIHNlYXJjaCBxdWVyeSBvciB2aXNpdGluZyB0aGUgd2Vic2l0ZXMgZGlyZWN0bHkuYCxcbiAgICAgIHRpdGxlOiBgU2VhcmNoIFJlc3VsdHNgXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tTb3VyY2VzO1xufVxuXG4vKipcbiAqIEFkdmFuY2VkIEdvb2dsZSBzZWFyY2ggd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXMgYW5kIGZhbGxiYWNrc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRHb29nbGVMaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgR29vZ2xlIHNlYXJjaCByZXF1ZXN0IGZvcjogXCIke3F1ZXJ5fVwiYCk7XG5cbiAgICAvLyBUcnkgbXVsdGlwbGUgc2VhcmNoIHZhcmlhdGlvbnMgdG8gaW1wcm92ZSByZXN1bHRzXG4gICAgY29uc3Qgc2VhcmNoVmFyaWF0aW9ucyA9IFtcbiAgICAgIC8vIFN0YW5kYXJkIHNlYXJjaFxuICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZudW09MzBgLFxuICAgICAgLy8gU2VhcmNoIHdpdGggdmVyYmF0aW0gb3B0aW9uIHRvIGdldCBleGFjdCBtYXRjaGVzXG4gICAgICBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9Jm51bT0yMCZ0YnM9bGk6MWAsXG4gICAgICAvLyBTZWFyY2ggd2l0aCByZWNlbnQgcmVzdWx0c1xuICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZudW09MjAmdGJzPXFkcjp5YFxuICAgIF07XG5cbiAgICBsZXQgYWxsTGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBUcnkgZWFjaCBzZWFyY2ggdmFyaWF0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hWYXJpYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWxsTGlua3MubGVuZ3RoID49IDE1KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBbHJlYWR5IGZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcywgc2tpcHBpbmcgcmVtYWluaW5nIHZhcmlhdGlvbnNgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IHNlYXJjaFZhcmlhdGlvbnNbaV07XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcnlpbmcgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfTogJHtzZWFyY2hVcmx9YCk7XG5cbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgaGVhZGVycyB0byBtaW1pYyBhIHJlYWwgYnJvd3NlclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICAgICAgc2VhcmNoVXJsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCcsXG4gICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjUnLFxuICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5nb29nbGUuY29tLycsXG4gICAgICAgICAgICAgICdETlQnOiAnMScsXG4gICAgICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgICAgICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZT0wJyxcbiAgICAgICAgICAgICAgJ3NlYy1jaC11YSc6ICdcIkdvb2dsZSBDaHJvbWVcIjt2PVwiMTA1XCIsIFwiTm90KUE7QnJhbmRcIjt2PVwiOFwiLCBcIkNocm9taXVtXCI7dj1cIjEwNVwiJyxcbiAgICAgICAgICAgICAgJ3NlYy1jaC11YS1tb2JpbGUnOiAnPzAnLFxuICAgICAgICAgICAgICAnc2VjLWNoLXVhLXBsYXRmb3JtJzogJ1wiV2luZG93c1wiJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb29nbGUgc2VhcmNoIHZhcmlhdGlvbiAke2kgKyAxfSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgYSB2YWxpZCByZXNwb25zZVxuICAgICAgICBpZiAoaHRtbC5sZW5ndGggPCAxMDAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBUb28gc21hbGwgcmVzcG9uc2UgZnJvbSBHb29nbGUgdmFyaWF0aW9uICR7aSArIDF9OiAke2h0bWwubGVuZ3RofSBjaGFyc2ApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoXCJ1bnVzdWFsIHRyYWZmaWNcIikgfHxcbiAgICAgICAgICAgIGh0bWwuaW5jbHVkZXMoXCJDQVBUQ0hBXCIpIHx8XG4gICAgICAgICAgICBodG1sLmluY2x1ZGVzKFwiZGV0ZWN0ZWQgdW51c3VhbCB0cmFmZmljXCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb29nbGUgdmFyaWF0aW9uICR7aSArIDF9IGJsb2NrZWQgb3IgcmV0dXJuZWQgYSBDQVBUQ0hBYCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRyYWN0IGxpbmtzIHVzaW5nIG11bHRpcGxlIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3MgPSBleHRyYWN0R29vZ2xlTGlua3MoaHRtbCk7XG5cbiAgICAgICAgaWYgKGV4dHJhY3RlZExpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtleHRyYWN0ZWRMaW5rcy5sZW5ndGh9IGxpbmtzIGZyb20gR29vZ2xlIHZhcmlhdGlvbiAke2kgKyAxfWApO1xuXG4gICAgICAgICAgLy8gQWRkIG5ldyB1bmlxdWUgbGlua3NcbiAgICAgICAgICBleHRyYWN0ZWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbGxMaW5rcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2YXJpYXRpb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aXRoIEdvb2dsZSBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OmAsIHZhcmlhdGlvbkVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYW5kIGNsZWFuIHRoZSBsaW5rc1xuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmRDbGVhbkxpbmtzKGFsbExpbmtzKTtcblxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkTGlua3MubGVuZ3RofSB1bmlxdWUgdmFsaWQgbGlua3MgZnJvbSBHb29nbGVgKTtcbiAgICByZXR1cm4gZmlsdGVyZWRMaW5rcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgR29vZ2xlIGxpbmtzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBsaW5rcyBmcm9tIEdvb2dsZSBzZWFyY2ggcmVzdWx0cyBIVE1MIHVzaW5nIG11bHRpcGxlIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEdvb2dsZUxpbmtzKGh0bWw6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgJCA9IGNoZWVyaW8ubG9hZChodG1sKTtcbiAgbGV0IGxpbmtzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIE1ldGhvZCAxOiBTdGFuZGFyZCBHb29nbGUgc2VhcmNoIHJlc3VsdHMgLSBsb29rIGZvciByZWRpcmVjdHNcbiAgJChcImFcIikuZWFjaCgoXywgbGluaykgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSAkKGxpbmspLmF0dHIoXCJocmVmXCIpO1xuICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcIi91cmw/cT1cIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRIcmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KGhyZWYucmVwbGFjZShcIi91cmw/cT1cIiwgXCJcIikuc3BsaXQoXCImXCIpWzBdKTtcbiAgICAgICAgaWYgKGlzVmFsaWRVcmwoY2xlYW5lZEhyZWYpICYmICFsaW5rcy5pbmNsdWRlcyhjbGVhbmVkSHJlZikpIHtcbiAgICAgICAgICBsaW5rcy5wdXNoKGNsZWFuZWRIcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDI6IExvb2sgZm9yIHJlc3VsdCBjb250YWluZXJzIGFuZCBleHRyYWN0IGxpbmtzXG4gIGlmIChsaW5rcy5sZW5ndGggPCA1KSB7XG4gICAgY29uc29sZS5sb2coXCJVc2luZyBHb29nbGUgZXh0cmFjdGlvbiBtZXRob2QgMlwiKTtcblxuICAgIC8vIE1vZGVybiBHb29nbGUgc2VsZWN0b3JzXG4gICAgJChcIi5nIC55dVJVYmYgPiBhLCAuZyAucmMgPiBhLCAuZyBoMy5yID4gYSwgLnRGMkN4YyA+IGRpdi55dVJVYmYgPiBhLCAuaGxjdzBjIC55dVJVYmYgPiBhXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgaWYgKGhyZWYgJiYgaHJlZi5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMoaHJlZikpIHtcbiAgICAgICAgbGlua3MucHVzaChocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1ldGhvZCAzOiBFeHRyYWN0IGZyb20gY2l0ZSBlbGVtZW50c1xuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgR29vZ2xlIGV4dHJhY3Rpb24gbWV0aG9kIDNcIik7XG5cbiAgICAkKFwiLmlVaDMwLCAudGp2Y3gsIC5xekVvVWVcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50TGluayA9ICQoZWxlbWVudCkuY2xvc2VzdChcImFcIikuYXR0cihcImhyZWZcIik7XG4gICAgICBpZiAocGFyZW50TGluayAmJiBwYXJlbnRMaW5rLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmICFsaW5rcy5pbmNsdWRlcyhwYXJlbnRMaW5rKSkge1xuICAgICAgICBsaW5rcy5wdXNoKHBhcmVudExpbmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBVUkwgZnJvbSBjaXRlIHRleHRcbiAgICAgICAgY29uc3QgY2l0ZVRleHQgPSAkKGVsZW1lbnQpLnRleHQoKS50cmltKCk7XG4gICAgICAgIGlmIChjaXRlVGV4dCAmJiAhY2l0ZVRleHQuaW5jbHVkZXMoXCIuLi5cIikgJiYgY2l0ZVRleHQuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB1cmwgPSBjaXRlVGV4dDtcbiAgICAgICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9cIiArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkVXJsKHVybCkgJiYgIWxpbmtzLmluY2x1ZGVzKHVybCkpIHtcbiAgICAgICAgICAgICAgbGlua3MucHVzaCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBVUkxzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBNZXRob2QgNDogTGFzdCByZXNvcnQgLSBmaW5kIGFueSBleHRlcm5hbCBsaW5rc1xuICBpZiAobGlua3MubGVuZ3RoIDwgMykge1xuICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgR29vZ2xlIGV4dHJhY3Rpb24gbWV0aG9kIDQgKGxhc3QgcmVzb3J0KVwiKTtcblxuICAgICQoXCJhW2hyZWZePSdodHRwJ11cIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XG4gICAgICBpZiAoaHJlZiAmJlxuICAgICAgICAgICFocmVmLmluY2x1ZGVzKFwiZ29vZ2xlLmNvbVwiKSAmJlxuICAgICAgICAgICFocmVmLmluY2x1ZGVzKFwiYWNjb3VudHMuXCIpICYmXG4gICAgICAgICAgIWhyZWYuaW5jbHVkZXMoXCJzdXBwb3J0LlwiKSAmJlxuICAgICAgICAgIGlzVmFsaWRVcmwoaHJlZikgJiZcbiAgICAgICAgICAhbGlua3MuaW5jbHVkZXMoaHJlZikpIHtcbiAgICAgICAgbGlua3MucHVzaChocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsaW5rcztcbn1cblxuLyoqXG4gKiBGaWx0ZXIgYW5kIGNsZWFuIGEgbGlzdCBvZiBVUkxzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckFuZENsZWFuTGlua3MobGlua3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICBsZXQgdW5pcXVlTGlua3MgPSBBcnJheS5mcm9tKG5ldyBTZXQobGlua3MpKTtcblxuICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgYW5kIHVud2FudGVkIFVSTHNcbiAgdW5pcXVlTGlua3MgPSB1bmlxdWVMaW5rcy5maWx0ZXIobGluayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gICAgICBjb25zdCBob3N0bmFtZSA9IHVybC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAvLyBGaWx0ZXIgb3V0IGNvbW1vbiBub24tY29udGVudCBkb21haW5zXG4gICAgICBjb25zdCBpbnZhbGlkRG9tYWlucyA9IFtcbiAgICAgICAgJ2dvb2dsZS5jb20nLCAneW91dHViZS5jb20nLCAnZmFjZWJvb2suY29tJywgJ3R3aXR0ZXIuY29tJywgJ2luc3RhZ3JhbS5jb20nLFxuICAgICAgICAnbGlua2VkaW4uY29tJywgJ3BpbnRlcmVzdC5jb20nLCAnYW1hem9uLmNvbScsICdlYmF5LmNvbScsICduZXRmbGl4LmNvbScsXG4gICAgICAgICdhcHBsZS5jb20nLCAnbWljcm9zb2Z0LmNvbScsICdwbGF5Lmdvb2dsZS5jb20nLCAnYWNjb3VudHMuZ29vZ2xlLmNvbScsXG4gICAgICAgICdzdXBwb3J0Lmdvb2dsZS5jb20nLCAnbWFwcy5nb29nbGUuY29tJywgJ3BvbGljaWVzLmdvb2dsZS5jb20nLFxuICAgICAgICAndHJhbnNsYXRlLmdvb2dsZS5jb20nLCAnY2hyb21lLmdvb2dsZS5jb20nLCAnZG9jcy5nb29nbGUuY29tJyxcbiAgICAgICAgJ2RyaXZlLmdvb2dsZS5jb20nLCAnbWFpbC5nb29nbGUuY29tJywgJ2NhbGVuZGFyLmdvb2dsZS5jb20nXG4gICAgICBdO1xuXG4gICAgICBpZiAoaW52YWxpZERvbWFpbnMuc29tZShkb21haW4gPT4gaG9zdG5hbWUuaW5jbHVkZXMoZG9tYWluKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0ZXIgb3V0IFVSTHMgd2l0aCBjZXJ0YWluIHBhdHRlcm5zXG4gICAgICBjb25zdCBpbnZhbGlkUGF0dGVybnMgPSBbXG4gICAgICAgICcvc2VhcmNoPycsICcvbG9naW4nLCAnL3NpZ25pbicsICcvc2lnbnVwJywgJy9yZWdpc3RlcicsXG4gICAgICAgICcvYWNjb3VudCcsICcvY2FydCcsICcvY2hlY2tvdXQnLCAnL3ByaXZhY3knLCAnL3Rlcm1zJyxcbiAgICAgICAgJy9jb250YWN0JywgJy9hYm91dCcsICcvaGVscCcsICcvc3VwcG9ydCcsICcvZmFxJyxcbiAgICAgICAgJy9kb3dubG9hZCcsICcvc3Vic2NyaWJlJywgJy9tZW1iZXJzaGlwJywgJy9wcmljaW5nJ1xuICAgICAgXTtcblxuICAgICAgaWYgKGludmFsaWRQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gdXJsLnBhdGhuYW1lLmluY2x1ZGVzKHBhdHRlcm4pKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTGltaXQgdG8gYSByZWFzb25hYmxlIG51bWJlclxuICByZXR1cm4gdW5pcXVlTGlua3Muc2xpY2UoMCwgMjApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgVVJMIGFuZCBtZWV0cyBjb250ZW50IGNyaXRlcmlhXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VkIEJpbmcgc2VhcmNoIHdpdGggbXVsdGlwbGUgZXh0cmFjdGlvbiB0ZWNobmlxdWVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEJpbmdMaW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgQmluZyBzZWFyY2ggcmVxdWVzdCBmb3I6IFwiJHtxdWVyeX1cImApO1xuXG4gICAgLy8gVHJ5IG11bHRpcGxlIHNlYXJjaCB2YXJpYXRpb25zXG4gICAgY29uc3Qgc2VhcmNoVmFyaWF0aW9ucyA9IFtcbiAgICAgIC8vIFN0YW5kYXJkIHNlYXJjaFxuICAgICAgYGh0dHBzOi8vd3d3LmJpbmcuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mY291bnQ9MzBgLFxuICAgICAgLy8gU2VhcmNoIHdpdGggbmV3c1xuICAgICAgYGh0dHBzOi8vd3d3LmJpbmcuY29tL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0mZmlsdGVycz1uZXdzYCxcbiAgICAgIC8vIFNlYXJjaCB3aXRoIGZyZXNobmVzcyBmaWx0ZXJcbiAgICAgIGBodHRwczovL3d3dy5iaW5nLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmZpbHRlcnM9ZXgxJTNhXCJlejVcImBcbiAgICBdO1xuXG4gICAgbGV0IGFsbExpbmtzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gVHJ5IGVhY2ggc2VhcmNoIHZhcmlhdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoVmFyaWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFsbExpbmtzLmxlbmd0aCA+PSAxNSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWxyZWFkeSBmb3VuZCAke2FsbExpbmtzLmxlbmd0aH0gbGlua3MgZnJvbSBCaW5nLCBza2lwcGluZyByZW1haW5pbmcgdmFyaWF0aW9uc2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoVXJsID0gc2VhcmNoVmFyaWF0aW9uc1tpXTtcbiAgICAgICAgY29uc29sZS5sb2coYFRyeWluZyBCaW5nIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX06ICR7c2VhcmNoVXJsfWApO1xuXG4gICAgICAgIC8vIEFkZCBoZWFkZXJzIHRvIG1pbWljIGEgcmVhbCBicm93c2VyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChcbiAgICAgICAgICBzZWFyY2hVcmwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGdldFJhbmRvbVVzZXJBZ2VudCgpLFxuICAgICAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsKi8qO3E9MC44JyxcbiAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuNScsXG4gICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmJpbmcuY29tLycsXG4gICAgICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgICAgICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZT0wJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBCaW5nIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX0gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgZ290IGEgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgaWYgKGh0bWwubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gQmluZyB2YXJpYXRpb24gJHtpICsgMX06ICR7aHRtbC5sZW5ndGh9IGNoYXJzYCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRyYWN0IGxpbmtzIHVzaW5nIG11bHRpcGxlIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3MgPSBleHRyYWN0QmluZ0xpbmtzKGh0bWwpO1xuXG4gICAgICAgIGlmIChleHRyYWN0ZWRMaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIEJpbmcgdmFyaWF0aW9uICR7aSArIDF9YCk7XG5cbiAgICAgICAgICAvLyBBZGQgbmV3IHVuaXF1ZSBsaW5rc1xuICAgICAgICAgIGV4dHJhY3RlZExpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICBpZiAoIWFsbExpbmtzLmluY2x1ZGVzKGxpbmspKSB7XG4gICAgICAgICAgICAgIGFsbExpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZhcmlhdGlvbkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdpdGggQmluZyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OmAsIHZhcmlhdGlvbkVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYW5kIGNsZWFuIHRoZSBsaW5rc1xuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBmaWx0ZXJBbmRDbGVhbkxpbmtzKGFsbExpbmtzKTtcblxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkTGlua3MubGVuZ3RofSB1bmlxdWUgdmFsaWQgbGlua3MgZnJvbSBCaW5nYCk7XG4gICAgcmV0dXJuIGZpbHRlcmVkTGlua3M7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIEJpbmcgbGlua3M6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGxpbmtzIGZyb20gQmluZyBzZWFyY2ggcmVzdWx0cyBIVE1MXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCaW5nTGlua3MoaHRtbDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xuICBsZXQgbGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gTWV0aG9kIDE6IEV4dHJhY3QgZnJvbSBtYWluIHNlYXJjaCByZXN1bHRzXG4gICQoXCIuYl9hbGdvIGgyIGFcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XG4gICAgICBsaW5rcy5wdXNoKGhyZWYpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDI6IEV4dHJhY3QgZnJvbSBjaXRlIGVsZW1lbnRzXG4gICQoXCIuYl9jYXB0aW9uIGNpdGVcIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudExpbmsgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoXCIuYl9hbGdvXCIpLmZpbmQoXCJoMiBhXCIpLmF0dHIoXCJocmVmXCIpO1xuICAgIGlmIChwYXJlbnRMaW5rICYmIHBhcmVudExpbmsuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWxpbmtzLmluY2x1ZGVzKHBhcmVudExpbmspKSB7XG4gICAgICBsaW5rcy5wdXNoKHBhcmVudExpbmspO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWV0aG9kIDM6IEV4dHJhY3QgZnJvbSBkZWVwIGxpbmtzXG4gICQoXCIuYl9kZWVwbGlua3MgYVwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XG4gICAgaWYgKGhyZWYgJiYgaHJlZi5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhbGlua3MuaW5jbHVkZXMoaHJlZikpIHtcbiAgICAgIGxpbmtzLnB1c2goaHJlZik7XG4gICAgfVxuICB9KTtcblxuICAvLyBNZXRob2QgNDogTGFzdCByZXNvcnQgLSBmaW5kIGFueSBleHRlcm5hbCBsaW5rc1xuICBpZiAobGlua3MubGVuZ3RoIDwgNSkge1xuICAgICQoXCJhW2hyZWZePSdodHRwJ11cIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XG4gICAgICBpZiAoaHJlZiAmJlxuICAgICAgICAgICFocmVmLmluY2x1ZGVzKFwiYmluZy5jb21cIikgJiZcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcIm1pY3Jvc29mdC5jb21cIikgJiZcbiAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcIm1zbi5jb21cIikgJiZcbiAgICAgICAgICBpc1ZhbGlkVXJsKGhyZWYpICYmXG4gICAgICAgICAgIWxpbmtzLmluY2x1ZGVzKGhyZWYpKSB7XG4gICAgICAgIGxpbmtzLnB1c2goaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGlua3M7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgRHVja0R1Y2tHbyBzZWFyY2ggd2l0aCBtdWx0aXBsZSBleHRyYWN0aW9uIHRlY2huaXF1ZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RHVja0R1Y2tHb0xpbmtzKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYE1ha2luZyBEdWNrRHVja0dvIHNlYXJjaCByZXF1ZXN0IGZvcjogXCIke3F1ZXJ5fVwiYCk7XG5cbiAgICAvLyBUcnkgbXVsdGlwbGUgc2VhcmNoIHZhcmlhdGlvbnNcbiAgICBjb25zdCBzZWFyY2hWYXJpYXRpb25zID0gW1xuICAgICAgLy8gU3RhbmRhcmQgSFRNTCBzZWFyY2hcbiAgICAgIGBodHRwczovL2h0bWwuZHVja2R1Y2tnby5jb20vaHRtbC8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCxcbiAgICAgIC8vIFdpdGggcmVnaW9uIHNldCB0byBVU1xuICAgICAgYGh0dHBzOi8vaHRtbC5kdWNrZHVja2dvLmNvbS9odG1sLz9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0ma2w9dXMtZW5gLFxuICAgICAgLy8gV2l0aCB0aW1lIGZpbHRlciBmb3IgcmVjZW50IHJlc3VsdHNcbiAgICAgIGBodHRwczovL2h0bWwuZHVja2R1Y2tnby5jb20vaHRtbC8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmRmPXlgXG4gICAgXTtcblxuICAgIGxldCBhbGxMaW5rczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFRyeSBlYWNoIHNlYXJjaCB2YXJpYXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaFZhcmlhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbGxMaW5rcy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFscmVhZHkgZm91bmQgJHthbGxMaW5rcy5sZW5ndGh9IGxpbmtzIGZyb20gRHVja0R1Y2tHbywgc2tpcHBpbmcgcmVtYWluaW5nIHZhcmlhdGlvbnNgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IHNlYXJjaFZhcmlhdGlvbnNbaV07XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcnlpbmcgRHVja0R1Y2tHbyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OiAke3NlYXJjaFVybH1gKTtcblxuICAgICAgICAvLyBBZGQgaGVhZGVycyB0byBtaW1pYyBhIHJlYWwgYnJvd3NlclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICAgICAgc2VhcmNoVXJsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCcsXG4gICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjUnLFxuICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL2R1Y2tkdWNrZ28uY29tLycsXG4gICAgICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgICAgICAgICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cyc6ICcxJyxcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZT0wJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBEdWNrRHVja0dvIHNlYXJjaCB2YXJpYXRpb24gJHtpICsgMX0gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgZ290IGEgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgaWYgKGh0bWwubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vIHNtYWxsIHJlc3BvbnNlIGZyb20gRHVja0R1Y2tHbyB2YXJpYXRpb24gJHtpICsgMX06ICR7aHRtbC5sZW5ndGh9IGNoYXJzYCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRyYWN0IGxpbmtzIHVzaW5nIG91ciBjdXN0b20gZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3MgPSBleHRyYWN0RHVja0R1Y2tHb0xpbmtzKGh0bWwpO1xuXG4gICAgICAgIGlmIChleHRyYWN0ZWRMaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIER1Y2tEdWNrR28gdmFyaWF0aW9uICR7aSArIDF9YCk7XG5cbiAgICAgICAgICAvLyBBZGQgbmV3IHVuaXF1ZSBsaW5rc1xuICAgICAgICAgIGV4dHJhY3RlZExpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICBpZiAoIWFsbExpbmtzLmluY2x1ZGVzKGxpbmspKSB7XG4gICAgICAgICAgICAgIGFsbExpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZhcmlhdGlvbkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdpdGggRHVja0R1Y2tHbyBzZWFyY2ggdmFyaWF0aW9uICR7aSArIDF9OmAsIHZhcmlhdGlvbkVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBIVE1MIHNlYXJjaCBmYWlsZWQsIHRyeSB0aGUgbGl0ZSB2ZXJzaW9uIGFzIGZhbGxiYWNrXG4gICAgaWYgKGFsbExpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgRHVja0R1Y2tHbyBMaXRlIGFzIGZhbGxiYWNrXCIpO1xuICAgICAgICBjb25zdCBsaXRlVXJsID0gYGh0dHBzOi8vbGl0ZS5kdWNrZHVja2dvLmNvbS9saXRlLz9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChcbiAgICAgICAgICBsaXRlVXJsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBnZXRSYW5kb21Vc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLCovKjtxPTAuOCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xuXG4gICAgICAgICAgLy8gRXh0cmFjdCBsaW5rcyBmcm9tIHRoZSBsaXRlIHZlcnNpb25cbiAgICAgICAgICAkKFwiYVtocmVmXj0naHR0cCddXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgICAgICAgaWYgKGhyZWYgJiZcbiAgICAgICAgICAgICAgICAhaHJlZi5pbmNsdWRlcyhcImR1Y2tkdWNrZ28uY29tXCIpICYmXG4gICAgICAgICAgICAgICAgaXNWYWxpZFVybChocmVmKSAmJlxuICAgICAgICAgICAgICAgICFhbGxMaW5rcy5pbmNsdWRlcyhocmVmKSkge1xuICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsTGlua3MubGVuZ3RofSBsaW5rcyBmcm9tIER1Y2tEdWNrR28gTGl0ZSBmYWxsYmFja2ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChsaXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdpdGggRHVja0R1Y2tHbyBMaXRlIGZhbGxiYWNrOlwiLCBsaXRlRXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBhbmQgY2xlYW4gdGhlIGxpbmtzXG4gICAgY29uc3QgZmlsdGVyZWRMaW5rcyA9IGZpbHRlckFuZENsZWFuTGlua3MoYWxsTGlua3MpO1xuXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZmlsdGVyZWRMaW5rcy5sZW5ndGh9IHVuaXF1ZSB2YWxpZCBsaW5rcyBmcm9tIER1Y2tEdWNrR29gKTtcbiAgICByZXR1cm4gZmlsdGVyZWRMaW5rcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgRHVja0R1Y2tHbyBsaW5rczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgbGlua3MgZnJvbSBEdWNrRHVja0dvIHNlYXJjaCByZXN1bHRzIEhUTUxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdER1Y2tEdWNrR29MaW5rcyhodG1sOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoaHRtbCk7XG4gIGxldCBsaW5rczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBNZXRob2QgMTogRXh0cmFjdCBmcm9tIG1haW4gcmVzdWx0IGxpbmtzXG4gICQoXCIucmVzdWx0X19hXCIpLmVhY2goKF8sIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBocmVmID0gJChlbGVtZW50KS5hdHRyKFwiaHJlZlwiKTtcbiAgICBpZiAoaHJlZikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRHVja0R1Y2tHbyB1c2VzIHJlbGF0aXZlIFVSTHMgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZiwgXCJodHRwczovL2R1Y2tkdWNrZ28uY29tXCIpO1xuICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidWRkZ1wiKTtcblxuICAgICAgICBpZiAoY2xlYW5lZEhyZWYgJiYgaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xuICAgICAgICAgIGxpbmtzLnB1c2goY2xlYW5lZEhyZWYpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNraXAgaW52YWxpZCBVUkxzXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBNZXRob2QgMjogRXh0cmFjdCBmcm9tIHJlc3VsdCBzbmlwcGV0c1xuICAkKFwiLnJlc3VsdF9fc25pcHBldFwiKS5lYWNoKChfLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcGFyZW50TGluayA9ICQoZWxlbWVudCkuY2xvc2VzdChcIi5yZXN1bHRcIikuZmluZChcIi5yZXN1bHRfX2FcIikuYXR0cihcImhyZWZcIik7XG4gICAgaWYgKHBhcmVudExpbmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGFyZW50TGluaywgXCJodHRwczovL2R1Y2tkdWNrZ28uY29tXCIpO1xuICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidWRkZ1wiKTtcblxuICAgICAgICBpZiAoY2xlYW5lZEhyZWYgJiYgaXNWYWxpZFVybChjbGVhbmVkSHJlZikgJiYgIWxpbmtzLmluY2x1ZGVzKGNsZWFuZWRIcmVmKSkge1xuICAgICAgICAgIGxpbmtzLnB1c2goY2xlYW5lZEhyZWYpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNraXAgaW52YWxpZCBVUkxzXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBNZXRob2QgMzogTGFzdCByZXNvcnQgLSBmaW5kIGFueSBleHRlcm5hbCBsaW5rc1xuICBpZiAobGlua3MubGVuZ3RoIDwgMykge1xuICAgICQoXCJhW2hyZWZePScvJ11cIikuZWFjaCgoXywgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9ICQoZWxlbWVudCkuYXR0cihcImhyZWZcIik7XG4gICAgICBpZiAoaHJlZiAmJiBocmVmLmluY2x1ZGVzKFwidWRkZz1cIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYsIFwiaHR0cHM6Ly9kdWNrZHVja2dvLmNvbVwiKTtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkSHJlZiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidWRkZ1wiKTtcblxuICAgICAgICAgIGlmIChjbGVhbmVkSHJlZiAmJiBpc1ZhbGlkVXJsKGNsZWFuZWRIcmVmKSAmJiAhbGlua3MuaW5jbHVkZXMoY2xlYW5lZEhyZWYpKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKGNsZWFuZWRIcmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGlua3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNlYXJjaEhhbmRsZXI7XG4iXSwibmFtZXMiOlsiUmVhZGFiaWxpdHkiLCJjaGVlcmlvIiwiSlNET00iLCJGRVRDSF9USU1FT1VUIiwiVVNFUl9BR0VOVFMiLCJnZXRSYW5kb21Vc2VyQWdlbnQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJNQVhfUkVUUklFUyIsIlJFVFJZX0RFTEFZIiwiREVGQVVMVF9TT1VSQ0VfQ09VTlQiLCJFWENMVURFRF9ET01BSU5TIiwiZmV0Y2hXaXRoVGltZW91dCIsInVybCIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0TXMiLCJpZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsImhlYWRlcnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBvdyIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwicmVkaXJlY3QiLCJjbGVhclRpbWVvdXQiLCJvayIsInN0YXR1cyIsIkVycm9yIiwic3RhdHVzVGV4dCIsImVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsInNlYXJjaEhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJqc29uIiwic291cmNlcyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJxdWVyeSIsInNlYXJjaEVuZ2luZSIsInNvdXJjZUNvdW50IiwiYm9keSIsImxpbWl0ZWRTb3VyY2VDb3VudCIsIm1pbiIsIm1heCIsImFsbExpbmtzIiwidXNlZEVuZ2luZXMiLCJnb29nbGVMaW5rcyIsImJpbmdMaW5rcyIsImR1Y2tkdWNrZ29MaW5rcyIsImFsbCIsImdldEdvb2dsZUxpbmtzIiwiY2F0Y2giLCJlcnIiLCJnZXRCaW5nTGlua3MiLCJnZXREdWNrRHVja0dvTGlua3MiLCJwdXNoIiwiZmFsbGJhY2tFcnJvciIsImZpbHRlcmVkTGlua3MiLCJmaWx0ZXJBbmREZWR1cGxpY2F0ZUxpbmtzIiwiZmluYWxMaW5rcyIsInNsaWNlIiwibWV0YWRhdGEiLCJlbmdpbmUiLCJqb2luIiwidG90YWxSZXN1bHRzIiwic2VhcmNoVGltZSIsImZpbHRlcmVkU291cmNlcyIsInNjcmFwZVNvdXJjZXNXaXRoVGltZW91dCIsInByb2Nlc3NlZFNvdXJjZXMiLCJwcm9jZXNzU291cmNlcyIsImZhbGxiYWNrU291cmNlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidGl0bGUiLCJ0ZXh0IiwiZmFsbGJhY2siLCJsaW5rcyIsInZhbGlkTGlua3MiLCJmaWx0ZXIiLCJsaW5rIiwiVVJMIiwiZG9tYWluIiwiaG9zdG5hbWUiLCJzb21lIiwiZXhjbHVkZWQiLCJ1bmlxdWVEb21haW5zIiwiU2V0IiwiaGFzIiwiYWRkIiwic291cmNlIiwidW5kZWZpbmVkIiwibWFwIiwiZXh0cmFjdFRpdGxlIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwicGF0aFNlZ21lbnQiLCJzcGxpdCIsIkJvb2xlYW4iLCJwb3AiLCJjbGVhblBhdGhTZWdtZW50IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJNQVhfQ09OQ1VSUkVOVCIsInJlc3VsdHMiLCJwcmlvcml0aXplZExpbmtzIiwicHJpb3JpdGl6ZUxpbmtzIiwicGVuZGluZ0xpbmtzIiwiYmF0Y2giLCJzcGxpY2UiLCJiYXRjaFJlc3VsdHMiLCJ0ZWNobmlxdWUiLCJ0ZWNobmlxdWVUaW1lb3V0IiwiZmV0Y2hPcHRpb25zIiwid2FybiIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaHRtbCIsImV4dHJhY3RlZENvbnRlbnQiLCJleHRyYWN0V2l0aFJlYWRhYmlsaXR5IiwiZXh0cmFjdFdpdGhDdXN0b21TZWxlY3RvcnMiLCJleHRyYWN0V2l0aFNpbXBsaWZpZWRNZXRob2QiLCJwcm9jZXNzZWRUZXh0IiwicHJvY2Vzc0V4dHJhY3RlZFRleHQiLCJ0ZWNobmlxdWVFcnJvciIsInZhbGlkUmVzdWx0cyIsInZhbGlkU291cmNlcyIsInNvcnRlZFNvdXJjZXMiLCJzb3J0U291cmNlc0J5UXVhbGl0eSIsImNyZWF0ZUZhbGxiYWNrU291cmNlcyIsInNjb3JlZExpbmtzIiwic2NvcmUiLCJ0b0xvd2VyQ2FzZSIsInNlYXJjaCIsInNvcnQiLCJhIiwiYiIsIml0ZW0iLCJkb20iLCJydW5TY3JpcHRzIiwicHJldGVuZFRvQmVWaXN1YWwiLCJyZWFkZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImFydGljbGUiLCJwYXJzZSIsInRleHRDb250ZW50IiwiZG9jIiwic2VsZWN0b3JzIiwic2VsZWN0b3IiLCJlbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb21iaW5lZFRleHQiLCJmb3JFYWNoIiwiZWwiLCJ0ZXh0QmxvY2tzIiwiZmluZExhcmdlc3RUZXh0QmxvY2tzIiwiJCIsImxvYWQiLCJyZW1vdmUiLCJwYXJhZ3JhcGhzIiwiZWFjaCIsIl8iLCJ0cmltIiwiYm9keVRleHQiLCJjbGVhbmVkVGV4dCIsImxpbmUiLCJ0ZXh0RWxlbWVudHMiLCJwcm9jZXNzRWxlbWVudCIsImVsZW1lbnQiLCJ0YWdOYW1lIiwiZGlyZWN0VGV4dCIsIkFycmF5IiwiZnJvbSIsImNoaWxkTm9kZXMiLCJub2RlIiwibm9kZVR5cGUiLCJjaGlsZHJlbiIsIm1haW5Db250ZW50RWxlbWVudHMiLCJwcm9jZXNzZWQiLCJ1bmlxdWVQYXJhZ3JhcGhzIiwic3Vic3RyaW5nIiwic2NvcmVBIiwiY2FsY3VsYXRlQ29udGVudFF1YWxpdHlTY29yZSIsInNjb3JlQiIsImZhbGxiYWNrU291cmNlcyIsInRvcExpbmtzIiwic2VhcmNoVmFyaWF0aW9ucyIsImkiLCJzZWFyY2hVcmwiLCJleHRyYWN0ZWRMaW5rcyIsImV4dHJhY3RHb29nbGVMaW5rcyIsInZhcmlhdGlvbkVycm9yIiwiZmlsdGVyQW5kQ2xlYW5MaW5rcyIsImhyZWYiLCJhdHRyIiwic3RhcnRzV2l0aCIsImNsZWFuZWRIcmVmIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaXNWYWxpZFVybCIsImUiLCJwYXJlbnRMaW5rIiwiY2xvc2VzdCIsImNpdGVUZXh0IiwidW5pcXVlTGlua3MiLCJpbnZhbGlkRG9tYWlucyIsImludmFsaWRQYXR0ZXJucyIsInBhdHRlcm4iLCJleHRyYWN0QmluZ0xpbmtzIiwiZmluZCIsImV4dHJhY3REdWNrRHVja0dvTGlua3MiLCJsaXRlVXJsIiwibGl0ZUVycm9yIiwic2VhcmNoUGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/sources.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/sources.ts"));
module.exports = __webpack_exports__;

})();